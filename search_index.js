var documenterSearchIndex = {"docs":
[{"location":"watchers/watchers/#Watchers","page":"Interface","title":"Watchers","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"A Watcher type serves as an interface over a data feed. Implementations are available for certain third-party APIs, exchange OHLCV (Open, High, Low, Close, Volume) data construction, and order books.","category":"page"},{"location":"watchers/watchers/#User-Interface","page":"Interface","title":"User Interface","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"To instantiate a watcher, call its related function. For example, ccxt_ohlcv_watcher can be used to instantiate a watcher that tracks trade data from an exchange and builds OHLCV candles for the specified timeframe. ","category":"page"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"A watcher instance provides the following functions:","category":"page"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"get: Primarily used to retrieve the underlying data monitored by the watcher, usually in a processed state (like a DataFrame). It defaults to the watcher buffer (which should keep data in a raw state).\nlength: Returns the length of the underlying buffer.\nlast: Returns the last raw value of the underlying buffer.\nclose: Stops the watcher and flushes the buffer.\nisstale: Evaluates if the watcher is in a degraded state, e.g., when it can't fetch new data.\nfetch!: A watcher runs queries at specified intervals, so you should only use fetch! when you want to ensure that the watcher has the latest data.\nflush!: Like fetch!, the watcher already flushes at predetermined intervals. Use this only to ensure flushing in case of shutdown. The watcher does call flush on destruction through its finalizer, but it does so asynchronously and doesn't ensure the success of the flush operation.\ndelete!: Deletes the watcher data from the storage backend used by flush! (and empties the buffer).\ndeleteat!: Deletes the watcher data within a date range (and empties the buffer).\npush!: Adds an element to the elements the watcher subscribes to (if any).\npop!: Opposite of push!.\nstop: Stops the watcher.\nstart: Restarts the watcher.","category":"page"},{"location":"watchers/watchers/#Implementation-Interface","page":"Interface","title":"Implementation Interface","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"To implement a custom watcher, you need to define functions such that dispatch happens through the watcher name interpreted as a value Val{Symbol(my_watcher_name)}. So a function needs to have a signature like _fetch!(w::Watcher, ::Val{some_symbol}).","category":"page"},{"location":"watchers/watchers/#Required","page":"Interface","title":"Required","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"_fetch!: Fetches the data, like an HTTP request.\n_get: Returns the post-processed data, like a DataFrame.","category":"page"},{"location":"watchers/watchers/#Optional","page":"Interface","title":"Optional","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"_init!: Performs initialization routines.\n_load!: Pre-fills the watcher buffer on construction. It is only called once and runs after _init!.\n_flush!: Saves the watcher buffer somewhere on periodic intervals and on watcher destruction.\n_process!: Updates the view of the raw data, which is what the get function should return.\n_delete!: Deletes all the storage data of the watcher.\n_deleteat!: Deletes the storage data of the watcher within a date range (from, to).\n_push!: Watchers might manage a list of things to track (like Asset symbols).\n_pop!: Inverse of _push!.\n_start: Executed before starting the timer.\n_stop: Executed after stopping the timer.","category":"page"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"Refer to the Watchers and WatchersImpls modules for helper functions.","category":"page"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"Watchers are heavy data structures, try to not use many of them, or join multiple jobs into fewer watchers. If you need an high number of multiple asynchronous fetchers rely instead on tasks (Task) or consider using Rocket.jl.","category":"page"},{"location":"watchers/watchers/#API","page":"Interface","title":"API","text":"","category":"section"},{"location":"watchers/watchers/","page":"Interface","title":"Interface","text":"Modules = [Watchers, Watchers.WatchersImpls]","category":"page"},{"location":"watchers/watchers/#Watchers.Watchers-watchers-watchers","page":"Interface","title":"Watchers.Watchers","text":"Watchers are data feeds, that keep track of stale data.\n\n\n\n\n\n","category":"module"},{"location":"watchers/watchers/#Watchers.Beacon-watchers-watchers","page":"Interface","title":"Watchers.Beacon","text":"The flags that control which operations are notified by the watcher\n\n\n\n\n\n","category":"type"},{"location":"watchers/watchers/#Watchers.Capacity-watchers-watchers","page":"Interface","title":"Watchers.Capacity","text":"The capacity parameters for the watcher\n\n\n\n\n\n","category":"type"},{"location":"watchers/watchers/#Watchers.Exec-watchers-watchers","page":"Interface","title":"Watchers.Exec","text":"The execution variables for the watcher\n\n\n\n\n\n","category":"type"},{"location":"watchers/watchers/#Watchers.HasFunction-watchers-watchers","page":"Interface","title":"Watchers.HasFunction","text":"The flags that control which operations are performed by the watcher\n\n\n\n\n\n","category":"type"},{"location":"watchers/watchers/#Watchers.Interval-watchers-watchers","page":"Interface","title":"Watchers.Interval","text":"The interval parameters for the watcher\n\n\n\n\n\n","category":"type"},{"location":"watchers/watchers/#Watchers.Watcher-watchers-watchers","page":"Interface","title":"Watchers.Watcher","text":"Watchers manage data, they pull from somewhere, keep a cache in memory, and optionally flush periodically to persistent storage.\n\nbuffer\nname\nhas\ninterval\ncapacity\nbeacon\n_exec\n_val\n_stop: Flag to stop the watcher\n_timer: A Timer object used to schedule fetch operations for a watcher\nattempts: Tracks how many consecutive fails have occurred in case of fetching failure\nlast_fetch: The most recent time a fetch operation failed\nlast_flush: The most recent time the flush function was called\nattrs: Additional attributes for the watcher\n\nA Watcher is a mutable struct that manages data. It pulls data from a source, keeps a cache in memory, and optionally flushes the data to persistent storage periodically. The struct contains fields for managing the buffer, scheduling fetch operations, and handling fetch failures.\n\n\n\n\n\n","category":"type"},{"location":"watchers/watchers/#Base.close-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Base.close","text":"Stops the watcher and optionally flushes the data.\n\nclose(w::Watcher; doflush)\n\n\nThe function takes a watcher and an optional doflush argument. If the watcher is not stopped, it stops the watcher. If doflush is true, it flushes the watcher data.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.delete!-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Base.delete!","text":"Deletes all watcher data from storage backend. Also empties the buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.deleteat!-Tuple{Watcher, @NamedTuple{start::Dates.DateTime, stop::Dates.DateTime}}-watchers-watchers","page":"Interface","title":"Base.deleteat!","text":"Delete watcher data from storage backend within the date range specified.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.empty!-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Base.empty!","text":"Empty the watcher buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.get-Tuple{Watcher, Any}-watchers-watchers","page":"Interface","title":"Base.get","text":"Returns the processed view of the watcher data. Accessible also as a view property of the watcher object.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.isempty-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Base.isempty","text":"True if the watcher buffer is empty.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.islocked-Tuple{Watcher, Val{:buffer}}-watchers-watchers","page":"Interface","title":"Base.islocked","text":"True if the buffer lock is locked.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.islocked-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Base.islocked","text":"True if watcher if the fetch lock locked.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.last-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Base.last","text":"The last available data entry.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.length-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Base.length","text":"The length of the watcher buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.lock-Tuple{Any, Watcher, Val{:buffer}}-watchers-watchers","page":"Interface","title":"Base.lock","text":"Lock the buffer lock and execute f.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.lock-Tuple{Any, Watcher}-watchers-watchers","page":"Interface","title":"Base.lock","text":"Lock the fetch lock and execute f.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.lock-Tuple{Watcher, Val{:buffer}}-watchers-watchers","page":"Interface","title":"Base.lock","text":"Lock the buffer lock.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.lock-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Base.lock","text":"Lock the fetch lock.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.pop!-Tuple{Watcher, Any, Vararg{Any}}-watchers-watchers","page":"Interface","title":"Base.pop!","text":"Remove v from the things the watcher is fetching.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.push!-Tuple{Watcher, Any, Vararg{Any}}-watchers-watchers","page":"Interface","title":"Base.push!","text":"Add v to the things the watcher is fetching.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.unlock-Tuple{Watcher, Val{:buffer}}-watchers-watchers","page":"Interface","title":"Base.unlock","text":"Unlock the buffer lock.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Base.unlock-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Base.unlock","text":"Unlock the fetch lock.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Data.DFUtils.lastdate-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Data.DFUtils.lastdate","text":"The date of the last update fetched by the watcher.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#ExchangeTypes.exchange-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"ExchangeTypes.exchange","text":"Get the exchange associated with the watcher.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#ExchangeTypes.exchangeid-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"ExchangeTypes.exchangeid","text":"Get the name of the exchange associated with the watcher.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Misc.load!-Tuple{Watcher, Vararg{Any}}-watchers-watchers","page":"Interface","title":"Misc.load!","text":"Executes the watcher _load! function (defaults to default_loader).\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Misc.start!-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Misc.start!","text":"Resets the watcher timer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Misc.stop!-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Misc.stop!","text":"Stops the watcher timer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.BufferEntry-Tuple{Any}-watchers-watchers","page":"Interface","title":"Watchers.BufferEntry","text":"The single entry in the buffer\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._check_flush_interval-Tuple{Any, Any, Any}-watchers-watchers","page":"Interface","title":"Watchers._check_flush_interval","text":"Checks the appropriateness of the flush interval\n\n_check_flush_interval(flush_interval, fetch_interval, cap)\n\n\nThis function checks if the flush interval is greater than the time it would take to drop an element from the buffer (calculated as the product of the fetch interval and the buffer capacity). If the flush interval is too high, a warning is issued.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._closeall-Tuple{}-watchers-watchers","page":"Interface","title":"Watchers._closeall","text":"Close all watchers.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._deleteat!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._deleteat!","text":"Deletes a range of data from the watcher buffer and storage backend.\n\n_deleteat!(w::Watcher, ::Val; from, to, kwargs...)\n\n\nThe function takes a watcher as an argument, along with optional from and to arguments. It deletes the data from the storage backend and the watcher buffer within the specified range. If no range is specified, it deletes all data.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._fetch!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._fetch!","text":"Appends new data to the watcher buffer, returns true when new data is added, false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._flush!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._flush!","text":"May run after a successful fetch operation, according to the flush_interval. It spawns a task.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._get-watchers-watchers","page":"Interface","title":"Watchers._get","text":"Returns the processed view of the watcher data.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers._init!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._init!","text":"Function to run on watcher initialization, it runs before _load!.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._isserialized-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Watchers._isserialized","text":"Checks if the watcher data is serialized.\n\n_isserialized(w::Watcher) -> Any\n\n\nThe function takes a watcher as an argument and returns a boolean indicating whether the watcher data is serialized or not.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._load!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._load!","text":"Called once on watcher creation, used to pre-fill the watcher buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._pop!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._pop!","text":"Same as _push! but for removing elements.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._process!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._process!","text":"Processes the watcher data, called everytime the watcher fetches new data.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._push!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._push!","text":"If the watcher manager a group of things that it is fetching, _push! should add an element to it.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._schedule_fetch-Tuple{Any, Any, Any}-watchers-watchers","page":"Interface","title":"Watchers._schedule_fetch","text":"Schedules a fetch operation for a watcher\n\n_schedule_fetch(w, timeout, threads; kwargs...) -> Any\n\n\nThis function schedules a fetch operation for a given watcher. It checks if the watcher is locked and if not, it creates a task to fetch data. It also handles timeouts and increments the attempt counter in case of failure. The function ensures that the fetch operation is thread-safe and handles any exceptions that might occur during the fetch operation.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._start!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._start!","text":"Executed before starting the timer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._stop!-Tuple{Watcher, Val}-watchers-watchers","page":"Interface","title":"Watchers._stop!","text":"Executed after the timer has been stopped.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._timer!-Tuple{Any}-watchers-watchers","page":"Interface","title":"Watchers._timer!","text":"_timer is an optional Timer object used to schedule fetch operations for a watcher.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._tryfetch-Tuple{Any}-watchers-watchers","page":"Interface","title":"Watchers._tryfetch","text":"Attempts to fetch data for a watcher\n\n_tryfetch(w) -> Bool\n\n\nThis function tries to fetch data for a given watcher. It locks the watcher, updates the last fetch time, and attempts to fetch data. If the fetch is successful, it returns true, otherwise it logs the error and returns false. It also handles stopping the watcher if needed.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._watcher-watchers-watchers","page":"Interface","title":"Watchers._watcher","text":"Instantiate a watcher.\n\n_watcher(T::Type, name::String; ...) -> Watcher\n_watcher(\n    T::Type,\n    name::String,\n    val::Val;\n    start,\n    load,\n    process,\n    flush,\n    threads,\n    fetch_timeout,\n    fetch_interval,\n    flush_interval,\n    buffer_capacity,\n    view_capacity,\n    attrs\n) -> Watcher\n\n\nThis function creates a new watcher with the specified parameters. It checks the flush interval, initializes the watcher, loads data if necessary, and sets a timer for the watcher if the start parameter is true. It also ensures that the _fetch! function is applicable for the watcher.\n\nwarning: asyncio vs threads\nBuyOrSell _fetch! and _flush! callbacks assume non-blocking asyncio like behaviour. If instead your functions require high computation, pass threads=true, you will have to ensure thread safety.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.allerror-Tuple{Type, Watcher}-watchers-watchers","page":"Interface","title":"Watchers.allerror","text":"Get all logged watcher errors of type t.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.default_flusher-Tuple{Watcher, Any}-watchers-watchers","page":"Interface","title":"Watchers.default_flusher","text":"Saves watcher data to the default DATA_PATH using serialization.\n\ndefault_flusher(\n    w::Watcher,\n    key;\n    reset,\n    buf\n) -> Union{Nothing, Dict{Symbol, Any}}\n\n\nThe function takes a watcher and a key as arguments, along with optional parameters for reset and buffer. If the buffer is empty, the function returns nothing. If the most recent time in the buffer is greater than the last flushed time, the function saves the recent slice of data to the DATA_PATH and updates the last flushed time.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.default_get-Tuple{Watcher, Any}-watchers-watchers","page":"Interface","title":"Watchers.default_get","text":"Returns the processed view of the watcher data.\n\ndefault_get(w::Watcher, def) -> Any\n\n\nThe function takes a watcher as an argument and returns the view attribute of the watcher.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.default_init-watchers-watchers","page":"Interface","title":"Watchers.default_init","text":"Initializes a watcher with default attributes.\n\ndefault_init(w::Watcher) -> Bool\ndefault_init(w::Watcher, dataview) -> Bool\ndefault_init(w::Watcher, dataview, serialized) -> Any\n\n\nThe function takes a watcher and optional dataview and serialized arguments. It sets the view, last_processed, checks, and serialized attributes of the watcher. If a logfile attribute is present, it writes an empty string to the logfile.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.default_loader-Tuple{Watcher, Any}-watchers-watchers","page":"Interface","title":"Watchers.default_loader","text":"Loads watcher data from the default DATA_PATH.\n\ndefault_loader(\n    w::Watcher,\n    key\n) -> Union{Nothing, Dict{Symbol, Any}}\n\n\nThe function takes a watcher and a key as arguments. If the watcher data is not loaded, the function returns nothing. Otherwise, it loads the data from the DATA_PATH, pushes it to the watcher buffer using pushstart!, processes the watcher data if necessary, and sets the loaded attribute of the watcher to true.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.default_process-Tuple{Watcher, Function}-watchers-watchers","page":"Interface","title":"Watchers.default_process","text":"Processes the values of a watcher buffer into a dataframe.\n\ndefault_process(\n    w::Watcher,\n    appendby::Function\n) -> Union{Nothing, Dict{Symbol, Any}}\n\n\nThe function takes a watcher and an appendby function as arguments. If the buffer is empty, the function returns nothing. Otherwise, it checks if the last processed attribute of the watcher is nothing.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.default_view-watchers-watchers","page":"Interface","title":"Watchers.default_view","text":"Returns the default view of the watcher data.\n\ndefault_view(w::Watcher) -> Any\ndefault_view(w::Watcher, def::Union{Function, Type}) -> Any\n\n\nThe function takes a watcher and an optional definition as arguments. If the default view attribute of the watcher is nothing, it returns the result of the definition function. Otherwise, it deletes the default view attribute from the watcher and returns it if it is a function or the result of the function if it is not.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.errors-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Watchers.errors","text":"Get the list of errors that occurred during the execution of a watcher.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.fetch!-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Watchers.fetch!","text":"Fetches a new value from the watcher ignoring the timer.\n\nfetch!(w::Watcher; reset, kwargs...) -> Any\n\n\nThe function takes a watcher as an argument, along with optional reset and kwargs arguments. It schedules a fetch operation, and if reset is true, it resets the timer. The function returns the last value in the watcher buffer or nothing if the buffer is empty.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.flush!-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Watchers.flush!","text":"Executes the flush function of the watcher (defaults to default_flusher).\n\nflush!(w::Watcher; force, sync)\n\n\nThe function takes a watcher as an argument, along with optional force and sync arguments. If force is true or the time since the last flush is greater than the flush interval, it schedules a flush operation. If sync is true, it waits for the flush operation to complete.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.init!-Tuple{Watcher, Vararg{Any}}-watchers-watchers","page":"Interface","title":"Watchers.init!","text":"Executes the watcher _init! function (defaults to default_init).\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.isstale-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Watchers.isstale","text":"True if last available data entry is older than now() + fetch_interval + fetch_timeout.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.isstarted-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Watchers.isstarted","text":"True if timer is running.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.isstopped-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Watchers.isstopped","text":"True if timer is not running.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.lasterror-Tuple{Type, Watcher}-watchers-watchers","page":"Interface","title":"Watchers.lasterror","text":"Get the last logged watcher error of type t.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.lasterror-Tuple{Watcher}-watchers-watchers","page":"Interface","title":"Watchers.lasterror","text":"Get the last logged watcher error.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.logerror-watchers-watchers","page":"Interface","title":"Watchers.logerror","text":"Stores an error to the watcher log journal.\n\nlogerror(w::Watcher, e) -> Any\nlogerror(w::Watcher, e, bt) -> Any\n\n\nThis function logs an error that occurred during the execution of a watcher. The error is stored in the watcher's log journal. If the watcher has a logfile attribute, the error is written to the logfile. Otherwise, the error is pushed to the watcher's error buffer.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.process!-Tuple{Watcher, Vararg{Any}}-watchers-watchers","page":"Interface","title":"Watchers.process!","text":"Executes the watcher _process! function (defaults to default_process).\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.pushnew!-Union{Tuple{T}, Tuple{Watcher{T}, Any}, Tuple{Watcher{T}, Any, Any}} where T-watchers-watchers","page":"Interface","title":"Watchers.pushnew!","text":"Pushes a new value to the watcher buffer if it is different from the last one.\n\npushnew!(\n    w::Watcher{T},\n    value\n) -> Union{Nothing, CircularBuffer{@NamedTuple{time::Dates.DateTime, value::T}} where T}\npushnew!(\n    w::Watcher{T},\n    value,\n    time\n) -> Union{Nothing, CircularBuffer{@NamedTuple{time::Dates.DateTime, value::T}} where T}\n\n\nThe function takes a watcher, a value, and an optional time as arguments. If the value is not nothing and it is different from the last value in the watcher buffer, the function pushes a new tuple containing the time and the value to the watcher buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.pushstart!-Tuple{Watcher, Any}-watchers-watchers","page":"Interface","title":"Watchers.pushstart!","text":"Pushes a vector of values to the watcher buffer.\n\npushstart!(w::Watcher, vec) -> Any\n\n\nThe function takes a watcher and a vector as arguments. If the vector is empty, the function returns nothing. Otherwise, it calculates the minimum of the buffer capacity and the size of the vector, and pushes the values from the vector to the watcher buffer starting from the calculated offset.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.showtrace-watchers-watchers","page":"Interface","title":"Watchers.showtrace","text":"Display the backtrace of the last logged watcher error.\n\nshowtrace(w::Watcher) -> Any\nshowtrace(w::Watcher, rev_idx) -> Any\n\n\nThis function retrieves and displays the backtrace of the last logged error for a given watcher. If no errors have been logged for the watcher, it does nothing.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.watcher-Tuple{Type, String, Vararg{Any}}-watchers-watchers","page":"Interface","title":"Watchers.watcher","text":"Instantiate a watcher and add it to the global watchers list.\n\nwatcher(\n    T::Type,\n    name::String,\n    args...;\n    kwargs...\n) -> Watcher\n\n\nThis function creates a new watcher with the specified parameters and adds it to the global WATCHERS list. If a watcher with the same name already exists in the list, it replaces the old watcher with the new one.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.@logerror-Tuple{Any, Any}-watchers-watchers","page":"Interface","title":"Watchers.@logerror","text":"Logs an error that occurred during the execution of an expression.\n\nThis macro tries to execute the provided expression and logs any error that occurs during its execution. The error is logged to the watcher's log journal. If the watcher has a logfile attribute, the error is written to the logfile. Otherwise, the error is pushed to the watcher's error buffer.\n\n\n\n\n\n","category":"macro"},{"location":"watchers/watchers/#Watchers.@watcher_interface!-Tuple{}-watchers-watchers","page":"Interface","title":"Watchers.@watcher_interface!","text":"Imports the watcher interface functions.\n\nThis macro imports the watcher interface functions into the current scope. These functions are used to define the behavior of a watcher.\n\n\n\n\n\n","category":"macro"},{"location":"watchers/watchers/#Watchers.WatchersImpls.CcxtTicker-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.CcxtTicker","text":"The ccxt ticker object as a NamedTuple.\n\n\n\n\n\n","category":"type"},{"location":"watchers/watchers/#Watchers.WatchersImpls.TempCandle-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.TempCandle","text":"A mutable struct representing a temporary candlestick chart.\n\ntimestamp\nopen\nhigh\nlow\nclose\nvolume\n\nThe TempCandle struct holds the timestamp, open, high, low, close, and volume values for a temporary candlestick chart.\n\n\n\n\n\n","category":"type"},{"location":"watchers/watchers/#Watchers.WatchersImpls._append_ohlcv!-NTuple{5, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._append_ohlcv!","text":"Appends data to a dataframe if it is contiguous\n\n_append_ohlcv!(w, ohlcv_dst, ohlcv_src, left, next) -> Any\n\n\nThis function appends data from a source dataframe to a destination dataframe if the data is contiguous. It checks if the first date in the source dataframe is the next expected date in the destination dataframe. If it is, the function appends the data from the source dataframe to the destination dataframe and checks the continuity of the data.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._checkforstale-Tuple{Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._checkforstale","text":"Checks for stale data in the watcher.\n\n_checkforstale(w)\n\n\nThis function checks for stale data in the watcher by iterating over the symbol states and updating the OHLCV if necessary.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._chill!-Tuple{Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._chill!","text":"_chill! sets the warmup target attribute of the window to the current time applied with the time frame rate.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._delete_ohlcv!-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._delete_ohlcv!","text":"Deletes OHLCV data of a given symbol from the window\n\n_delete_ohlcv!(w) -> Any\n_delete_ohlcv!(w, sym) -> Any\n\n\nThe _delete_ohlcv! function removes OHLCV data of a specified symbol from the window. If no symbol is provided, it defaults to the symbol of the window. It fetches the data associated with the symbol and the current time frame rate, and deletes it.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.WatchersImpls._empty!!-Tuple{DataFrames.DataFrame}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._empty!!","text":"Empties a dataframe\n\n_empty!!(\n    df::DataFrames.DataFrame\n) -> Union{DataFrames.DataFrame, Vector{Bool}}\n\n\nThe _empty!! function tries to empty a dataframe. If calling the empty! function on the dataframe throws an error, it uses the copysubs! function with the empty argument to empty the dataframe.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._empty_candles-Tuple{Any, Watchers.WatchersImpls.Warmed}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._empty_candles","text":"Returns nothing if the watcher status is pending\n\n_empty_candles(w, _::Watchers.WatchersImpls.Warmed)\n\n\nThis function checks the status of the watcher. If the status is pending, it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._ensure_contig!-Tuple{Any, Any, Watchers.WatchersImpls.TempCandle, Any, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._ensure_contig!","text":"Appends temp_candle ensuring contiguity.\n\n_ensure_contig!(\n    w,\n    df,\n    temp_candle::Watchers.WatchersImpls.TempCandle,\n    tf,\n    sym\n) -> Any\n\n\nThis function appends the temporary candle to the DataFrame ensuring contiguity. If the temporary candle is not right adjacent to the last date in the DataFrame, it resolves the gap and then appends the candle.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._fastforward-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._fastforward","text":"Fast forwards the window to the current timestamp\n\n_fastforward(w) -> Any\n_fastforward(w, sym) -> Any\n\n\nThe _fastforward function ensures the window is up-to-date by fast-forwarding to the current timestamp. It checks whether the stored data is empty or corrupted and retrieves available data within the window. If no data is available, it calculates the starting point for fetching new data. Otherwise, it appends the available data to the dataframe, checks the continuity of the data, and updates the starting point. If the starting point is not equal to the current timestamp, it fetches new data up to the current timestamp and checks the data continuity again.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.WatchersImpls._fetch_error-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._fetch_error","text":"Generates an error message when data fetching fails\n\n_fetch_error(w, from, to) -> Any\n_fetch_error(w, from, to, sym, args...) -> Any\n\n\nThe _fetch_error function is used when data fetching for a given symbol fails. It generates an error message detailing the symbol, exchange name, and the time frame for which data fetching failed, unless the quiet attribute of the window is set to true.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.WatchersImpls._fetchto!-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._fetchto!","text":"Fetches and appends or prepends data to a dataframe\n\n_fetchto!(w, df, sym, tf; ...)\n_fetchto!(w, df, sym, tf, op; to, from)\n\n\nThis function fetches data for a given symbol and time frame, and appends or prepends it to a provided dataframe. The operation (append or prepend) is determined by the op parameter. If the dataframe is not empty, it checks for data continuity. If the data is not contiguous and the resync_noncontig attribute of the watcher is set to true, it empties the dataframe and resets the rows count. The function calculates the starting date for fetching new data based on the dataframe, target date, time frame, and operation. It then fetches the data, cleans it, and checks if it can be appended or prepended to the dataframe. If the operation is possible, it performs it and returns true. If the fetched data is empty, it returns false. If the difference between the target date and the starting date is less than or equal to the period of the time frame, it also returns true.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.WatchersImpls._flushfrom!-Tuple{Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._flushfrom!","text":"Ensures the dataframe is up-to-date by flushing data\n\n_flushfrom!(w) -> Union{Nothing, Dict{Symbol, Any}}\n\n\nThis function ensures the dataframe is up-to-date by flushing data. If the dataframe is not empty, it checks the last flushed date and the last date in the dataframe. If these dates are not the same, it saves the data in the dataframe from the last flushed date to the last date in the dataframe and updates the last flushed date.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._from-Tuple{Any, Any, Any, Any, Val{:append}}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._from","text":"Calculates the starting date for appending data to a dataframe\n\n_from(df, to, tf, cap, _::Val{:append}) -> Any\n\n\nThe _from function determines the starting date for appending data to a dataframe. It takes into account a target date, time frame rate, capacity, and the :append flag. The function ensures that the target date is not earlier than the last date in the dataframe. It then calculates the earliest date that can be included in the dataframe based on the capacity and the time frame rate. If the dataframe is empty, this earliest date is returned. Otherwise, the minimum between this date and the last date in the dataframe is returned.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._fromto-NTuple{4, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._fromto","text":"_fromto calculates a starting timestamp given a target timestamp, period, capacity and data kept.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._get_available-Tuple{Any, Any, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._get_available","text":"Returns the available data within the given window\n\n_get_available(\n    w,\n    z,\n    to\n) -> Union{Nothing, DataFrames.DataFrame}\n\n\nThe _get_available function checks if data is available within a given window. It calculates the maximum lookback period and checks if the data in the window is empty. If it is, the function returns nothing. If data is available, it creates a view of the data and checks if the data is too old. If it is, it returns nothing and schedules a background task to update the data. Otherwise, it converts the available data to OHLCV format and returns it.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._load_ob_data-Tuple{Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._load_ob_data","text":"Loads order book data.\n\n_load_ob_data(w) -> Any\n\n\nThis function loads the order book data from the specified location.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._loadall!-Tuple{Watcher, Val{:ccxt_ohlcv_candles}}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._loadall!","text":"Loads the OHLCV data for all symbols.\n\n_loadall!(w::Watcher, _::Val{:ccxt_ohlcv_candles})\n\n\nThis function loads the OHLCV data for all symbols. If the buffer or view of the watcher is empty, the function returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._loadall!-Tuple{Watcher, Val{:ccxt_ohlcv_ticker}}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._loadall!","text":"Loads the OHLCV data for all symbols.\n\n_loadall!(w::Watcher, _::Val{:ccxt_ohlcv_ticker})\n\n\nThis function loads the OHLCV data for all symbols. If the buffer or view of the watcher is empty, the function returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._meanvolume!-Tuple{Any, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._meanvolume!","text":"Adjusts the volume of the temporary candlestick chart.\n\n_meanvolume!(w, state) -> Any\n\n\nThis function adjusts the volume of the temporary candlestick chart by dividing it by the number of ticks and the volume divisor.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._ob_func-Tuple{Any, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._ob_func","text":"Assigns the appropriate order book function based on the level.\n\n_ob_func(attrs, level)\n\n\nThe function assigns the appropriate order book function to the attrs dictionary based on the level provided. It tries to assign the function in the order of preference and breaks the loop as soon as a function is successfully assigned. If no function can be assigned, it throws an assertion error.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._ob_to_df-Tuple{Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._ob_to_df","text":"Converts order book data to a DataFrame.\n\n_ob_to_df(ob) -> DataFrames.DataFrame\n\n\nThis function takes an order book and converts it into a DataFrame. It creates separate columns for timestamp, bid price, bid amount, ask price, and ask amount. The function also ensures that the DataFrame is created even if the bids and asks are uneven by using the zip function.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._parsedatez-Tuple{AbstractString}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._parsedatez","text":"Removes trailing 'Z' from a string and parses it into a DateTime object.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._resolve-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._resolve","text":"Ensures the dataframe is up-to-date by fetching and appending data\n\n_resolve(w, ohlcv_dst, date_candidate::Dates.DateTime)\n_resolve(w, ohlcv_dst, date_candidate::Dates.DateTime, sym)\n\n\nThis function ensures the dataframe is up-to-date by fetching and appending data for a given symbol and time frame. It checks whether the stored data is empty or corrupted and retrieves available data within the window. If no data is available, it calculates the starting point for fetching new data. Otherwise, it appends the available data to the dataframe, checks the continuity of the data, and updates the starting point. If the starting point is not equal to the current timestamp, it fetches new data up to the current timestamp and checks the data continuity again.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.WatchersImpls._sticky_fetchto!-Tuple-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._sticky_fetchto!","text":"Continuously attempts to fetch and append or prepend data to a dataframe until successful\n\n_sticky_fetchto!(args...; kwargs...)\n\n\nThis function continuously calls the _fetchto! function until it successfully fetches and appends or prepends data to a dataframe. If the _fetchto! function fails, the function waits for a certain period before trying again. The waiting period increases with each failed attempt.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls._update_sym_ohlcv-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._update_sym_ohlcv","text":"Updates the OHLCV for a specific symbol.\n\n_update_sym_ohlcv(\n    w,\n    ticker,\n    latest_timestamp\n) -> Union{Nothing, Int64}\n_update_sym_ohlcv(\n    w,\n    ticker,\n    latest_timestamp,\n    sym\n) -> Union{Nothing, Int64}\n\n\nThis function updates the OHLCV for a specific symbol based on the latest timestamp and price from the ticker. It resets the temporary candlestick chart if the timestamp is newer than the current one and ensures contiguity when appending the candle to the DataFrame.\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.WatchersImpls._warmup!-Tuple{Any, Watchers.WatchersImpls.Pending}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls._warmup!","text":"Checks if we can start processing data, after we are past the initial incomplete timeframe.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls.ccxt_ohlcv_tickers_watcher-Tuple{Exchange}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.ccxt_ohlcv_tickers_watcher","text":"OHLCV watcher based on exchange tickers data. This differs from the ohlcv watcher based on trades.\n\nThe OHLCV ticker watcher can monitor a group of symbols, while the trades watcher only one symbol per instance.\nThe OHLCV ticker watcher candles do not match 1:1 the exchange candles, since they rely on polled data.\nThe OHLCV ticker watcher is intended to be lazy. It won't pre-load/fetch data for all symbols, it will only\n\nprocess new candles from the time it is started w.r.t. the timeframe provided.\n\nThe source price chooses which price to use to build the candles any of :last, :vwap, :bid, :ask (default :last).\n\nTo back-fill the view (DataFrame) of a particular symbol, call load!(watcher, symbol), which will fill the view up to the watcher view_capacity.\n\nlogfile: optional path to save errors.\ndiff_volume: calculate volume by subtracting the rolling 1d snapshots (true)\nn_jobs: concurrent startup fetching jobs for ohlcv\ncallback: function fn(df, sym) called every time a dataframe is updated\n\n!!! \"warning\" startup times     The higher the number of symbols, the longer it will take to load initial OHLCV candles. When the semaphore (w[:sem]) is not full anymore, all the symbols should then start to trail the latest (full) candle as soon as possible.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls.ccxt_ohlcv_watcher-Tuple{Exchange, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.ccxt_ohlcv_watcher","text":"Create a Watcher instance that tracks ohlcv for an exchange (ccxt).\n\nOn startup candles are initially loaded from storage (if any).\nThen they are fastfowarded to the last available candle.\nAfter which, fetching happen on trades\nOnce time crosses the timeframe, new candles are created from trades.\n\nIf The watcher is restarted, a new call for OHLCV data is made to re-fastfoward. If no trades happen during a timeframe, an empty candle for that timeframe is added. The view of the watcher SHOULD NOT have duplicate candles (same timestamp), and all the candles SHOULD be contiguous (the time difference between adjacent candles is always equal to the timeframe).\n\nIf these constraints are not met that's a bug.\n\nwarning: Watcher data.\n\n\nThe data saved by the watcher on disk SHOULD NOT be relied upon to be contiguous, since the watcher doesn't ensure it, it only uses it to reduce the number of candles to fetch from the exchange at startup.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls.ccxt_orderbook_watcher-Tuple{Exchange, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.ccxt_orderbook_watcher","text":"Creates a watcher for the order book of a given exchange and symbol.\n\nccxt_orderbook_watcher(\n    exc::Exchange,\n    sym;\n    level,\n    interval\n) -> Any\n\n\nThis function creates a watcher for the order book of a given exchange and symbol. It sets up the watcher with the specified level, interval, and other parameters. The watcher is then started and returned for use. The function checks for timeout, sets up the attributes, and assigns the appropriate order book function based on the level.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls.ccxt_tickers_watcher-Tuple{Exchange}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.ccxt_tickers_watcher","text":"Create a Watcher instance that tracks all markets for an exchange (ccxt)\n\nccxt_tickers_watcher(\n    exc::Exchange;\n    val,\n    wid,\n    syms,\n    interval,\n    start,\n    load,\n    process,\n    buffer_capacity,\n    view_capacity,\n    flush,\n    iswatch\n) -> Watcher{Dict{String, @NamedTuple{symbol::String, timestamp::Union{Nothing, Dates.DateTime}, open::Float64, high::Float64, low::Float64, close::Float64, previousClose::Union{Nothing, Float64}, bid::Float64, ask::Float64, bidVolume::Union{Nothing, Float64}, askVolume::Union{Nothing, Float64}, last::Float64, vwap::Float64, change::Float64, percentage::Float64, average::Float64, baseVolume::Float64, quoteVolume::Float64}}}\n\n\nThis function creates a Watcher instance that tracks all markets for an exchange (ccxt). It sets the symbol, exchange, and time frame for the watcher, and prepares the trades buffer. It also sets the watcher's status to pending and initializes the last fetched and last flushed timestamps.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls.cg_derivatives_watcher-Tuple{Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.cg_derivatives_watcher","text":"Create a Watcher instance that tracks all the derivatives from an exchange.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls.cg_ticker_watcher-Tuple{AbstractVector}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.cg_ticker_watcher","text":"Create a Watcher instance that tracks the price of some currencies on an exchange (coingecko).\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls.cp_markets_watcher-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.cp_markets_watcher","text":"Create a Watcher instance that tracks all markets for an exchange (coinpaprika).\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.WatchersImpls.cp_twitter_watcher-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.cp_twitter_watcher","text":"Create a Watcher instance that tracks all markets for an exchange (coinpaprika).\n\n\n\n\n\n","category":"function"},{"location":"watchers/watchers/#Watchers.WatchersImpls.resetcandle!-Tuple{Any, Watchers.WatchersImpls.TempCandle, Any, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.resetcandle!","text":"Resets the temporary candlestick chart with a new timestamp and price.\n\nresetcandle!(\n    w,\n    cdl::Watchers.WatchersImpls.TempCandle,\n    ts,\n    price\n) -> Float64\n\n\nThis function resets the temporary candlestick chart with a new timestamp and price. It also resets the high and low prices to their extreme values and the volume to zero if the price source is not vwap.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._fetch!-Tuple{Watcher, Val{:ccxt_ohlcv}}-watchers-watchers","page":"Interface","title":"Watchers._fetch!","text":"Fetches trades and updates the watcher's trades buffer\n\n_fetch!(w::Watcher, _::Val{:ccxt_ohlcv}) -> Any\n\n\nThis function fetches trades for the watcher's symbol and time frame, and updates the watcher's trades buffer. If new trades are fetched, they are appended to the trades buffer and the last fetched timestamp is updated.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._fetch!-Tuple{Watcher, Val{:ccxt_order_book}}-watchers-watchers","page":"Interface","title":"Watchers._fetch!","text":"Fetches the order book data and pushes it to the watcher.\n\n_fetch!(w::Watcher, _::Val{:ccxt_order_book}) -> Bool\n\n\nThis function fetches the order book data using the appropriate function and symbol. If the fetched order book has data, it is converted to a DataFrame and pushed to the watcher. The function returns true if data was fetched and pushed, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._fetch!-Tuple{Watcher, Val{:ccxt_ticker}}-watchers-watchers","page":"Interface","title":"Watchers._fetch!","text":"Fetches trades and updates the watcher's trades buffer\n\n_fetch!(w::Watcher, _::Val{:ccxt_ticker}) -> Any\n\n\nThis function fetches trades for the watcher's symbol and time frame, and updates the watcher's trades buffer. If new trades are fetched, they are appended to the trades buffer and the last fetched timestamp is updated.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._flush!-Tuple{Watcher, Val{:ccxt_order_book}}-watchers-watchers","page":"Interface","title":"Watchers._flush!","text":"Flushes the watcher data.\n\n_flush!(\n    w::Watcher,\n    _::Val{:ccxt_order_book}\n) -> Union{Nothing, Dict{Symbol, Any}}\n\n\nThis function checks if the watcher view is empty and returns nothing if it is. Otherwise, it gets the range of data after the last flushed time from the buffer and saves it if the range has data. The last flushed time is then updated to the time of the last data in the buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._init!-Tuple{Watcher, Val{:ccxt_ohlcv_ticker}}-watchers-watchers","page":"Interface","title":"Watchers._init!","text":"Initializes the watcher for the OHLCV ticker.\n\n_init!(\n    w::Watcher,\n    _::Val{:ccxt_ohlcv_ticker}\n) -> Dict{Symbol, Any}\n\n\nThis function initializes the watcher with default view, temporary OHLCV, candle ticks, loaded symbols, and symbol locks. It also initializes the symbols and checks for the watcher.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._init!-Tuple{Watcher, Val{:ccxt_ohlcv}}-watchers-watchers","page":"Interface","title":"Watchers._init!","text":"Initializes the watcher\n\n_init!(w::Watcher, _::Val{:ccxt_ohlcv}) -> Dict{Symbol, Any}\n\n\nThis function initializes the watcher by setting up its attributes and preparing it for data fetching and processing. It sets the symbol, exchange, and time frame for the watcher, and prepares the trades buffer. It also sets the watcher's status to pending and initializes the last fetched and last flushed timestamps.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._load!-Tuple{Watcher, Val{:ccxt_ohlcv_candles}, Any}-watchers-watchers","page":"Interface","title":"Watchers._load!","text":"Loads the OHLCV data for a specific symbol.\n\n_load!(\n    w::Watcher,\n    _::Val{:ccxt_ohlcv_candles},\n    sym\n) -> Union{Nothing, Bool}\n\n\nThis function loads the OHLCV data for a specific symbol. If the symbol is not being tracked by the watcher or if the data for the symbol has already been loaded, the function returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._load!-Tuple{Watcher, Val{:ccxt_ohlcv_ticker}, Any}-watchers-watchers","page":"Interface","title":"Watchers._load!","text":"Loads the OHLCV data for a specific symbol.\n\n_load!(\n    w::Watcher,\n    _::Val{:ccxt_ohlcv_ticker},\n    sym\n) -> Union{Nothing, Bool}\n\n\nThis function loads the OHLCV data for a specific symbol. If the symbol is not being tracked by the watcher or if the data for the symbol has already been loaded, the function returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._process!-Tuple{Watcher, Val{:ccxt_ohlcv_ticker}}-watchers-watchers","page":"Interface","title":"Watchers._process!","text":"Processes the watcher data.\n\n_process!(w::Watcher, _::Val{:ccxt_ohlcv_ticker})\n\n\nThis function processes the watcher data by updating the OHLCV for each symbol in the last fetch. It does this in a synchronous manner, ensuring that all updates are completed before proceeding.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._process!-Tuple{Watcher, Val{:ccxt_ohlcv}}-watchers-watchers","page":"Interface","title":"Watchers._process!","text":"Processes the watcher data and updates the dataframe\n\n_process!(w::Watcher, _::Val{:ccxt_ohlcv})\n\n\nThis function processes the watcher data and updates the dataframe. It first ensures that when no trades happen, candles are still updated. Then, it converts trades to OHLCV format and appends the resulting data to the dataframe. If the dataframe is not empty, it resolves any discrepancies between the dataframe and the new data. Finally, it removes processed trades from the trades buffer.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._process!-Tuple{Watcher, Val{:ccxt_order_book}}-watchers-watchers","page":"Interface","title":"Watchers._process!","text":"Processes the watcher data.\n\n_process!(\n    w::Watcher,\n    _::Val{:ccxt_order_book}\n) -> Union{Nothing, Dict{Symbol, Any}}\n\n\nThis function processes the watcher data by appending it to the view. It uses the appendby function to append the last buffer value to the view, with a capacity limit.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers._start!-Tuple{Watcher, Val{:ccxt_ohlcv}}-watchers-watchers","page":"Interface","title":"Watchers._start!","text":"Starts the watcher and fetches data\n\n_start!(w::Watcher, _::Val{:ccxt_ohlcv}) -> Any\n\n\nThis function starts the watcher and fetches data for the watcher's symbol and time frame. If the dataframe is not empty, it fetches data from the last date in the dataframe to the current date. It then checks the continuity of the data in the dataframe.\n\n\n\n\n\n","category":"method"},{"location":"watchers/watchers/#Watchers.WatchersImpls.@append_dict_data-Tuple{Any, Any, Any}-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.@append_dict_data","text":"Defines a closure that appends new data on each symbol dataframe\n\nThe append_dict_data macro takes a dictionary, data, and a maximum length variable. It defines a closure doappend that appends new data to each symbol dataframe in the dictionary. The macro ensures that the length of the dataframe does not exceed the provided maximum length.\n\n\n\n\n\n","category":"macro"},{"location":"watchers/watchers/#Watchers.WatchersImpls.@collect_buffer_data-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.@collect_buffer_data","text":"Collects data from a buffer and stores it in a dictionary\n\nThe collect_buffer_data macro takes a buffer variable, key type, value type, and an optional push function. It escapses the provided parameters and initializes a dictionary with the key type and vector of the value type. The push function is used to populate the dictionary with data from the buffer. If no push function is provided, a default one is used which pushes the ticker data into the dictionary. The dictionary is then returned after collecting all data from the buffer.\n\n\n\n\n\n","category":"macro"},{"location":"watchers/watchers/#Watchers.WatchersImpls.@parsedata-watchers-watchers","page":"Interface","title":"Watchers.WatchersImpls.@parsedata","text":"Converts market data into a NamedTuple.\n\nThis macro takes a tick type, a collection of market data, and an optional key (defaulting to \"symbol\"). It then converts each market data item into the specified tick type and constructs a NamedTuple where each entry corresponds to a market, with the key being the market's symbol and the value being the converted data.\n\n\n\n\n\n","category":"macro"},{"location":"exchanges/#Exchanges","page":"Exchanges","title":"Exchanges","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Every trade, order, asset instance, and strategy is parameterized against an ExchangeID, which is a type constructed from the name (Symbol) of an exchange. Currently, the bot supports CCXT with exchanges subtypes of CcxtExchange.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"There is only one exchange instance (one sandbox and one non-sandbox) constructed per exchange, so calling PingPong.Engine.Exchanges.getexchange! will always return the same object for each exchange. The sandbox instance is generally a test-net with synthetic markets.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"We try to parse as much info from the (CCXT) exchange such that we can fill attributes such as:","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Markets\nTimeframes\nAsset trading fees, limits, precision\nFunding rates","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"The support for exchanges is a best-effort basis. To overview if the exchange is likely compatible with the bot, call check:","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"using PingPong\n@environment!\ne = getexchange!(:bybit)\nexs.check(e, type=:basic) # for backtesting and paper trading\nexs.check(e, type=:live) # for live support","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"The bot tries to use the WebSocket API if available, otherwise, it falls back to the basic REST API. The API keys are read from a file in the user/ directory named after the exchange name like user/bybit.json for the Bybit exchange or user/bybit_sandbox.json for the respective sandbox API keys. The JSON file has to contain the fields apiKey, secret, and password.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"The strategy quote currency and each asset currency is a subtype of PingPong.Engine.Exchanges.CurrencyCash, which is a Number where operations respect the precision defined by the exchange.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Some commonly fetched information is cached with a TTL, like tickers, markets, and balances.","category":"page"},{"location":"exchanges/#Exchange-Types","page":"Exchanges","title":"Exchange Types","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Basic exchange types, and global exchange vars.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [PingPong.Exchanges.ExchangeTypes]","category":"page"},{"location":"exchanges/#ExchangeTypes.HOOKS-exchanges","page":"Exchanges","title":"ExchangeTypes.HOOKS","text":"Functions f(::Exchange) to call when an exchange is loaded\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#ExchangeTypes.exc-exchanges","page":"Exchanges","title":"ExchangeTypes.exc","text":"Global var implicit exchange instance.\n\nWhen working interactively, a global exc variable is available, updated through globalexchange!, which is used as the default for some functions when the exchange argument is omitted.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#ExchangeTypes.exchangeIds-exchanges","page":"Exchanges","title":"ExchangeTypes.exchangeIds","text":"All possible exchanges that can be instantiated by ccxt.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#ExchangeTypes.exchanges-exchanges","page":"Exchanges","title":"ExchangeTypes.exchanges","text":"Global var holding Exchange instances. Used as a cache.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#ExchangeTypes.sb_exchanges-exchanges","page":"Exchanges","title":"ExchangeTypes.sb_exchanges","text":"Global var holding Sandbox Exchange instances. Used as a cache.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#ExchangeTypes.CcxtExchange-exchanges","page":"Exchanges","title":"ExchangeTypes.CcxtExchange","text":"The CcxtExchange type wraps a ccxt exchange instance. Some attributes frequently accessed are copied over to avoid round tripping python. More attributes might be added in the future. To instantiate an exchange call getexchange! or setexchange!.\n\n\n\n\n\n","category":"type"},{"location":"exchanges/#ExchangeTypes.ExcPrecisionMode-exchanges","page":"Exchanges","title":"ExchangeTypes.ExcPrecisionMode","text":"Same as ccxt precision mode enums.\n\n\n\n\n\n","category":"type"},{"location":"exchanges/#ExchangeTypes.Exchange-Tuple{Py}-exchanges","page":"Exchanges","title":"ExchangeTypes.Exchange","text":"Instantiates a new Exchange wrapper for the provided x Python object.\n\nThis constructs a CcxtExchange struct with the provided Python object. It extracts the exchange ID, name, and other metadata. It runs any registered hook functions for that exchange. It sets a finalizer to close the exchange when garbage collected.\n\nReturns the new Exchange instance, or an empty one if x is None.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#ExchangeTypes.Exchange-exchanges","page":"Exchanges","title":"ExchangeTypes.Exchange","text":"Abstract exchange type.\n\nDefines the interface for interacting with crypto exchanges. Implemented for CCXT in CcxtExchange.\n\n\n\n\n\n","category":"type"},{"location":"exchanges/#ExchangeTypes.ExchangeID-exchanges","page":"Exchanges","title":"ExchangeTypes.ExchangeID","text":"A structure for handling Exchange IDs in CCXT.\n\nThis structure is used to manage Exchange IDs in the CCXT library. It contains methods for creating an Exchange ID from a symbol, a Python object, or directly from a symbol type. It ensures that the symbol is in the list of valid exchange IDs.\n\n\n\n\n\n","category":"type"},{"location":"exchanges/#Base.first-Tuple{Exchange, Vararg{Symbol}}-exchanges","page":"Exchanges","title":"Base.first","text":"Return the first available property from a variable number of Symbol arguments in the given Exchange.\n\nfirst(exc::Exchange, args::Symbol...) -> Any\n\n\nThis function iterates through the provided Symbols and returns the value of the first property that exists in the Exchange object.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Base.getproperty-Union{Tuple{E}, Tuple{E, Symbol}} where E<:Exchange-exchanges","page":"Exchanges","title":"Base.getproperty","text":"Attributes not matching the Exchange struct fields are forwarded to the wrapped ccxt class instance.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Base.hash-Tuple{Exchange, UInt64}-exchanges","page":"Exchanges","title":"Base.hash","text":"The hash of an exchange object is reduced to its symbol (the function used to instantiate the object from ccxt).\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#ExchangeTypes._has-Tuple{Symbol}-exchanges","page":"Exchanges","title":"ExchangeTypes._has","text":"Checks if the specified feature feat is supported by any of the exchanges available through the ccxt library.\n\nArguments\n\ns::Symbol: The feature to check for support across exchanges.\nfull::Bool=true: If true, checks both static and instantiated properties of the exchange for support.\n\nReturns\n\nVector{String}: A list of exchange names that support the specified feature.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#ExchangeTypes.close_exc-Tuple{ExchangeTypes.CcxtExchange}-exchanges","page":"Exchanges","title":"ExchangeTypes.close_exc","text":"Closes the given exchange.\n\nclose_exc(\n    exc::ExchangeTypes.CcxtExchange\n) -> Union{Nothing, Task}\n\n\nThis function attempts to close the given exchange if it exists. It checks if the exchange has a 'close' attribute and if so, it schedules the 'close' coroutine for execution.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#ExchangeTypes.decimal_to_size-Tuple{Any, ExcPrecisionMode}-exchanges","page":"Exchanges","title":"ExchangeTypes.decimal_to_size","text":"Converts value v to integer size with precision p.\n\ndecimal_to_size(v, p::ExcPrecisionMode) -> Any\n\n\nUsed when converting exchange API responses to integer sizes for orders.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#ExchangeTypes.eids-Tuple-exchanges","page":"Exchanges","title":"ExchangeTypes.eids","text":"Union type of many exchange ids (from Symbol arguments)\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#ExchangeTypes.exchangeid-Tuple{ExchangeID}-exchanges","page":"Exchanges","title":"ExchangeTypes.exchangeid","text":"Return the given ExchangeID instance.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#ExchangeTypes.exchangeid-Tuple{Symbol}-exchanges","page":"Exchanges","title":"ExchangeTypes.exchangeid","text":"Create an ExchangeID instance from a symbol.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#ExchangeTypes.globalexchange!-Tuple{Exchange}-exchanges","page":"Exchanges","title":"ExchangeTypes.globalexchange!","text":"Updates the global exchange exc variable.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Construct-and-query-exchanges","page":"Exchanges","title":"Construct and query exchanges","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Helper module for downloading data off exchanges.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [PingPong.Engine.Exchanges]\nPages = [\"exchanges.jl\", \"tickers.jl\", \"-data.jl\"]","category":"page"},{"location":"exchanges/#Exchanges.LEVERAGED_PAIR_OPTIONS-exchanges","page":"Exchanges","title":"Exchanges.LEVERAGED_PAIR_OPTIONS","text":"A leveraged pair is a pair like BTC3L/USD.\n\n:yes : Leveraged pairs will not be filtered.\n:only : ONLY leveraged will be kept.\n:from : Selects non leveraged pairs, that also have at least one leveraged sibling.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Exchanges.activeCache1Min-exchanges","page":"Exchanges","title":"Exchanges.activeCache1Min","text":"Caches active states (1minute).\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Exchanges.marketsCache1Min-exchanges","page":"Exchanges","title":"Exchanges.marketsCache1Min","text":"Caches markets (1minute).\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Exchanges.tickersCache10Sec-exchanges","page":"Exchanges","title":"Exchanges.tickersCache10Sec","text":"Caches tickers (10seconds).\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Exchanges.tickersLockDict-exchanges","page":"Exchanges","title":"Exchanges.tickersLockDict","text":"Lock held when fetching tickers (per ticker).\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Exchanges.has_leverage-Tuple{Any, Any}-exchanges","page":"Exchanges","title":"Exchanges.has_leverage","text":"True if pair is a leveraged pair.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.hasvolume-Tuple{Any, Any}-exchanges","page":"Exchanges","title":"Exchanges.hasvolume","text":"True if symbol sym has a quote volume less than min_vol.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.is_pair_active-exchanges","page":"Exchanges","title":"Exchanges.is_pair_active","text":"Check if a currency pair is active on an exchange.\n\nis_pair_active(pair::AbstractString) -> Any\nis_pair_active(pair::AbstractString, exc::Exchange) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"exchanges/#Exchanges.ismargin-Tuple{Any}-exchanges","page":"Exchanges","title":"Exchanges.ismargin","text":"True if mkt is a leveraged market.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.isquote-Tuple{Any, Any}-exchanges","page":"Exchanges","title":"Exchanges.isquote","text":"True if id is a quote id.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.lastprice-Tuple{AbstractString, Exchange}-exchanges","page":"Exchanges","title":"Exchanges.lastprice","text":"Fetch the latest price for a specific pair from an exchange.\n\nlastprice(\n    pair::AbstractString,\n    exc::Exchange;\n    kwargs...\n) -> Any\n\n\npair: a string representing the currency pair to fetch the latest price for.\nexc: an Exchange object to fetch the latest price from.\nkwargs (optional): any additional keyword arguments are passed on to the underlying fetch operation.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.leverage_func-exchanges","page":"Exchanges","title":"Exchanges.leverage_func","text":"Constructor that returns a function that checks if a pair is leveraged.\n\n\n\n\n\n","category":"function"},{"location":"exchanges/#Exchanges.market!-exchanges","page":"Exchanges","title":"Exchanges.market!","text":"Retrieves a cached market (1minute) or fetches it from exchange.\n\nmarket!(pair) -> Any\nmarket!(pair, exc::Exchange) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"exchanges/#Exchanges.market_fees-exchanges","page":"Exchanges","title":"Exchanges.market_fees","text":"Fetch the market fees for a specific pair from an exchange.\n\nmarket_fees(\n    pair::AbstractString;\n    ...\n) -> NamedTuple{(:taker, :maker, :min, :max), <:NTuple{4, Any}}\nmarket_fees(\n    pair::AbstractString,\n    exc::Exchange;\n    only_taker\n) -> NamedTuple{(:taker, :maker, :min, :max), <:NTuple{4, Any}}\n\n\npair: a string representing the currency pair to fetch the market fees for.\nexc (optional, default is the current exchange): an Exchange object to fetch the market fees from.\nonly_taker (optional, default is nothing): a boolean indicating whether to fetch only the taker fee. If nothing, both maker and taker fees are fetched.\n\n\n\n\n\n","category":"function"},{"location":"exchanges/#Exchanges.market_limits-Tuple{AbstractString, Exchange}-exchanges","page":"Exchanges","title":"Exchanges.market_limits","text":"Fetch the market limits for a specific pair from an exchange.\n\nmarket_limits(\n    pair::AbstractString,\n    exc::Exchange;\n    precision,\n    default_leverage,\n    default_amount,\n    default_price,\n    default_cost\n) -> NamedTuple\n\n\npair: a string representing the currency pair to fetch the market limits for.\nexc: an Exchange object to fetch the market limits from.\nprecision (optional, default is price=nothing, amount=nothing): a named tuple specifying the precision for price and amount.\ndefault_leverage (optional, default is DEFAULT_LEVERAGE): the default leverage to use if not specified in the market data.\ndefault_amount (optional, default is DEFAULT_AMOUNT): the default amount to use if not specified in the market data.\ndefault_price (optional, default is DEFAULT_PRICE): the default price to use if not specified in the market data.\ndefault_cost (optional, default is DEFAULT_COST for non-fiat quote pairs and DEFAULT_FIAT_COST for fiat quote pairs): the default cost to use if not specified in the market data.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.market_precision-Tuple{AbstractString, Exchange}-exchanges","page":"Exchanges","title":"Exchanges.market_precision","text":"Precision of the (base, quote) currencies of the market.\n\nmarket_precision(\n    pair::AbstractString,\n    exc::Exchange\n) -> NamedTuple{(:amount, :price), <:Tuple{Any, Any}}\n\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.marketsid-Tuple{Exchange, Vararg{Any}}-exchanges","page":"Exchanges","title":"Exchanges.marketsid","text":"Get the exchange market ids.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.quoteid-Tuple{Any}-exchanges","page":"Exchanges","title":"Exchanges.quoteid","text":"Quote id of the market.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.ticker!-Tuple{Any, Exchange}-exchanges","page":"Exchanges","title":"Exchanges.ticker!","text":"Fetch the ticker for a specific pair from an exchange.\n\nticker!(pair, exc::Exchange; timeout, func, delay) -> Any\n\n\nThe ticker! function takes the following parameters:\n\npair: a string representing the currency pair to fetch the ticker for.\nexc: an Exchange object to fetch the ticker from.\ntimeout (optional, default is 3 seconds): the maximum time to wait for the ticker fetch operation.\nfunc (optional, default is the result of _tickerfunc(exc)): the function to use to fetch the ticker.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.tickers-Tuple{Exchange, Any}-exchanges","page":"Exchanges","title":"Exchanges.tickers","text":"Get the exchange tickers.\n\ntickers(\n    exc::Exchange,\n    quot;\n    min_vol,\n    skip_fiat,\n    with_margin,\n    with_leverage,\n    as_vec,\n    verbose,\n    type\n)\n\n\nexc: an Exchange object to fetch the tickers from.\nquot: only choose pairs where the quote currency equals quot.\nmin_vol: the minimum volume of each pair.\nskip_fiat (optional, default is true): ignore fiat/fiat pairs.\nwith_margin (optional, default is the result of config.margin != NoMargin()): only choose pairs enabled for margin trading.\nwith_leverage (optional, default is :no): if :no, skip all pairs where the base currency matches the leverage_pair_rgx regex.\nas_vec (optional, default is false): return the pair list as a Vector instead of as a Dict.\nverbose (optional, default is true): print detailed output about the operation.\ntype (optional, default is the result of markettype(exc)): the type of markets to fetch tickers for.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Exchanges.tickers-Tuple{Symbol, Vararg{Any}}-exchanges","page":"Exchanges","title":"Exchanges.tickers","text":"Get the tickers matching quote currency quot.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetching-data-from-exchanges","page":"Exchanges","title":"Fetching data from exchanges","text":"","category":"section"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Helper module for downloading data off exchanges.","category":"page"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [Fetch]","category":"page"},{"location":"exchanges/#Fetch.FUNDING_RATES_CACHE-exchanges","page":"Exchanges","title":"Fetch.FUNDING_RATES_CACHE","text":"Initializes a safe TTL cache for storing multiple funding rates with a specified TTL.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.FUNDING_RATE_CACHE-exchanges","page":"Exchanges","title":"Fetch.FUNDING_RATE_CACHE","text":"Initializes a safe TTL cache for storing funding rates with a specified TTL.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.FUNDING_RATE_TTL-exchanges","page":"Exchanges","title":"Fetch.FUNDING_RATE_TTL","text":"Defines the time-to-live (TTL) for a funding rate as 5 seconds.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.MAX_ORDERS-exchanges","page":"Exchanges","title":"Fetch.MAX_ORDERS","text":"Defines an array representing possible numbers of orders to fetch.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.OB_CACHE-exchanges","page":"Exchanges","title":"Fetch.OB_CACHE","text":"Initializes a safe TTL cache for storing order book data with the default eviction TTL.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.OB_EVICTION_TTL-exchanges","page":"Exchanges","title":"Fetch.OB_EVICTION_TTL","text":"Defines the eviction time-to-live (TTL) for an order book as 5 minutes.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.OB_FUNCTIONS-exchanges","page":"Exchanges","title":"Fetch.OB_FUNCTIONS","text":"Initializes a LittleDict for storing order book functions keyed by order book level and exchange ID.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.OB_TTL-exchanges","page":"Exchanges","title":"Fetch.OB_TTL","text":"Defines the time-to-live (TTL) for an order book as 5 seconds (after which it is stale).\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.OHLCVTupleTypes-exchanges","page":"Exchanges","title":"Fetch.OHLCVTupleTypes","text":"Defines the tuple type for OHLCV data, where each element represents a specific metric (Open, High, Low, Close, Volume).\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.SINCE_MIN_PERIOD-exchanges","page":"Exchanges","title":"Fetch.SINCE_MIN_PERIOD","text":"Used to slide the since param forward when retrying fetching (in case the requested timestamp is too old).\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.futures_limits-exchanges","page":"Exchanges","title":"Fetch.futures_limits","text":"Defines limit values for fetching futures data from exchanges.\n\n\n\n\n\n","category":"constant"},{"location":"exchanges/#Fetch.OrderBookTuple-exchanges","page":"Exchanges","title":"Fetch.OrderBookTuple","text":"Defines a NamedTuple structure for order book data.\n\n\n\n\n\n","category":"type"},{"location":"exchanges/#Base.convert-Tuple{Type{Tuple{Vector{Dates.DateTime}, Vararg{Vector{Float64}, 5}}}, Py}-exchanges","page":"Exchanges","title":"Base.convert","text":"This is the fastest (afaik) way to convert ccxt lists to dataframe friendly format.\n\nconvert(\n    _::Type{Tuple{Vector{Dates.DateTime}, Vararg{Vector{Float64}, 5}}},\n    py::Py\n) -> Tuple{Vector{Dates.DateTime}, Vararg{Vector{Float64}}}\n\n\nThis function converts the provided Python object to a tuple format suitable for dataframes, specifically tailored for OHLCV data.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.propagate_ohlcv!-Tuple{SortedDict, AbstractString, Exchange}-exchanges","page":"Exchanges","title":"Data.propagate_ohlcv!","text":"Propagates OHLCV data to all timeframes in a data structure.\n\npropagate_ohlcv!(\n    data::SortedDict,\n    pair::AbstractString,\n    exc::Exchange\n) -> Union{Nothing, SortedDict{TimeFrames.TimeFrame, DataFrames.DataFrame}}\n\n\nThe propagate_ohlcv! function propagates OHLCV data for a given pair from an exchange exc to all timeframes in the data SortedDict data structure.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Data.to_ohlcv-Tuple{Py}-exchanges","page":"Exchanges","title":"Data.to_ohlcv","text":"Converts a Python object to a DataFrame with OHLCV columns\n\nto_ohlcv(py::Py)\n\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.__ensure_dates-NTuple{4, Any}-exchanges","page":"Exchanges","title":"Fetch.__ensure_dates","text":"Ensures dates are within valid range for the exchange and timeframe.\n\n__ensure_dates(exc, tf, from, to) -> Tuple{Any, Any}\n\n\nThe __ensure_dates function checks if the dates from and to are within the valid range for the given exchange exc and timeframe tf. If the dates are not within the valid range, the function adjusts them accordingly.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.__from_date_func-NTuple{7, Any}-exchanges","page":"Exchanges","title":"Fetch.__from_date_func","text":"Determines the starting date for fetching data.\n\n__from_date_func(\n    update,\n    timeframe,\n    from,\n    to,\n    zi,\n    exc_name,\n    reset\n) -> Any\n\n\nThe __from_date_func function determines the starting date from for fetching data based on various parameters. If update is true, it will fetch data from the latest date available. If reset is true, it will fetch data from the earliest date possible. The function also considers the timeframe, to date, timezone zi, and exchange name exc_name in its calculations.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.__get_ohlcv-NTuple{5, Any}-exchanges","page":"Exchanges","title":"Fetch.__get_ohlcv","text":"Fetches OHLCV data for a specified exchange within a date range.\n\n__get_ohlcv(\n    exc,\n    name,\n    timeframe,\n    from_date,\n    to;\n    out,\n    cleanup,\n    ohlcv_kind\n) -> Tuple{Any, Any}\n\n\nThis function fetches OHLCV data for a given exchange exc, with the specified name and timeframe, within the date range specified by from_date and to. The fetched data is appended to the out data structure. The cleanup parameter determines if any post-processing should be done on the data before returning. The ohlcv_kind parameter determines the type of OHLCV data to fetch.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.__get_since-NTuple{8, Any}-exchanges","page":"Exchanges","title":"Fetch.__get_since","text":"Determines the 'since' parameter for fetching data from an exchange.\n\n__get_since(\n    exc,\n    fetch_func,\n    pair,\n    limit,\n    from,\n    out,\n    is_df,\n    converter\n) -> Any\n\n\nThis function calculates the 'since' parameter based on the specified 'from' timestamp, or finds the appropriate 'since' value if 'from' is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.__handle_error-NTuple{9, Any}-exchanges","page":"Exchanges","title":"Fetch.__handle_error","text":"Handles errors during fetch operations.\n\n__handle_error(\n    e,\n    fetch_func,\n    pair,\n    since,\n    df,\n    sleep_t,\n    limit,\n    converter,\n    retry\n) -> Any\n\n\nThis function takes an error e occurred during data fetching, and decides whether to retry the fetch_func based on the retry flag. If retry is true, it calls the fetch_func again with the same parameters.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.__handle_fetch-NTuple{9, Any}-exchanges","page":"Exchanges","title":"Fetch.__handle_fetch","text":"Handles fetch operations for specified exchange and pair.\n\n__handle_fetch(\n    fetch_func,\n    pair,\n    since,\n    limit,\n    sleep_t,\n    df,\n    converter,\n    retry,\n    usetimeframe\n) -> Tuple{Bool, Any}\n\n\nThis function calls the fetch_func for a given pair, starting from the since timestamp with a maximum limit of limit data points. It employs a delay sleep_t between fetches. The function also applies a given converter to the fetched data. If the retry flag is true, the function will try to fetch data again in case of an empty response. The usetimeframe flag indicates whether to use timeframe for fetching.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.__ordered_timeframes-Tuple{Exchange}-exchanges","page":"Exchanges","title":"Fetch.__ordered_timeframes","text":"Returns an ordered list of timeframes for a given exchange\n\n__ordered_timeframes(exc::Exchange) -> Tuple{Any, Any}\n\n\nThis function collects the timeframes from the exchange, converts them into periods, and sorts them in descending order. It then returns these sorted timeframes and periods.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.__pairdata!-NTuple{8, Any}-exchanges","page":"Exchanges","title":"Fetch.__pairdata!","text":"Processes OHLCV data for a pair.\n\n__pairdata!(\n    zi,\n    data,\n    ohlcv,\n    name,\n    timeframe,\n    z,\n    exc_name,\n    reset\n) -> Data.PairData\n\n\nThe __pairdata! function processes the OHLCV data ohlcv for a pair name over a timeframe. It takes into account the timezone zi, data data, timezone offset z, exchange name exc_name, and a reset flag. If reset is true, it will reset the data for the pair before processing.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._cleanup_funding_history-NTuple{4, Any}-exchanges","page":"Exchanges","title":"Fetch._cleanup_funding_history","text":"Cleans up fetched funding history data.\n\n_cleanup_funding_history(df, name, half_tf, f_tf) -> Any\n\n\nThe _cleanup_funding_history function takes a DataFrame df of fetched funding history data for a name and performs cleanup operations on it. The half_tf and f_tf parameters are used in the cleanup process.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_loop-Union{Tuple{F}, Tuple{Function, Exchange, Any}} where F<:AbstractFloat-exchanges","page":"Exchanges","title":"Fetch._fetch_loop","text":"Iteratively fetches data over a specified date range.\n\n_fetch_loop(\n    fetch_func::Function,\n    exc::Exchange,\n    pair;\n    from,\n    to,\n    sleep_t,\n    out,\n    converter,\n    limit\n)\n\n\nThis function calls the fetch_func function repeatedly until it has fetched data for the entire date range specified by from and to. Note: The total data points fetched may not match the expected number based on the date range.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_ohlcv_from_to-Tuple{Exchange, Any, Any}-exchanges","page":"Exchanges","title":"Fetch._fetch_ohlcv_from_to","text":"Ensure a to date is set, before fetching.\n\n_fetch_ohlcv_from_to(\n    exc::Exchange,\n    pair,\n    timeframe;\n    from,\n    to,\n    params,\n    sleep_t,\n    cleanup,\n    out,\n    ohlcv_kind\n) -> Any\n\n\nThis function verifies that a 'to' date is set before attempting to fetch OHLCV data.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_ohlcv_with_delay-Tuple{Exchange, Vararg{Any}}-exchanges","page":"Exchanges","title":"Fetch._fetch_ohlcv_with_delay","text":"Fetches OHLCV data with delay for a given exchange and arguments.\n\n_fetch_ohlcv_with_delay(\n    exc::Exchange,\n    args...;\n    ohlcv_kind,\n    kwargs...\n) -> Any\n\n\nThis function fetches OHLCV data for a specified exchange exc and additional args. The type of OHLCV data to fetch is determined by ohlcv_kind. It applies a delay between fetches as specified in kwargs.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._fetch_with_delay-Tuple{Function, Any}-exchanges","page":"Exchanges","title":"Fetch._fetch_with_delay","text":"Wraps fetching function with error handling and backoff delay.\n\n_fetch_with_delay(\n    fetch_func::Function,\n    pair;\n    since,\n    df,\n    sleep_t,\n    limit,\n    converter,\n    retry,\n    usetimeframe\n) -> Any\n\n\nThis function wraps a fetching function fetch_func with error handling and a backoff delay sleep_t. The fetch_func takes three parameters: pair, since, and limit, and returns a PyList. The converter function is used to tabulate the data such that the first column is the timestamp. The function will retry fetching in case of an error if retry is set to true.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._levelname-Tuple{Any}-exchanges","page":"Exchanges","title":"Fetch._levelname","text":"Returns the name of an order book level.\n\n_levelname(level) -> String\n\n\nThe _levelname function takes an order book level and returns its name.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._orderbook-Tuple{Any}-exchanges","page":"Exchanges","title":"Fetch._orderbook","text":"Generates an order book of depth N.\n\n_orderbook(\n    N\n) -> @NamedTuple{busy::Ref{Bool}, timestamp::Ref{Dates.DateTime}, asks::Vector{Tuple{Float64, Float64}}, bids::Vector{Tuple{Float64, Float64}}}\n\n\nThe _orderbook function generates an order book of depth N. The order book contains N levels of bid and ask prices along with their corresponding quantities.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._since_timestamp-Tuple{Dates.DateTime, Dates.Period}-exchanges","page":"Exchanges","title":"Fetch._since_timestamp","text":"Determines the start time for fetching data\n\n_since_timestamp(\n    actual::Dates.DateTime,\n    p::Dates.Period\n) -> Int64\n\n\nThis function calculates the timestamp from which to start fetching data. It ensures that the start time is not more than 20 years in the past or less than the given period.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch._update_orderbook!-NTuple{5, Any}-exchanges","page":"Exchanges","title":"Fetch._update_orderbook!","text":"Updates an order book in place with new data.\n\n_update_orderbook!(exc, ob, sym, lvl, limit; init)\n\n\nThe _update_orderbook! function takes an exchange exc, an order book ob, a symbol sym, an order book level lvl, and a limit limit, and updates the order book in place with new data. If init is set, the function will initialize the order book before updating it.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.extract_futures_data-Tuple{Py}-exchanges","page":"Exchanges","title":"Fetch.extract_futures_data","text":"Extracts futures data from a Python object.\n\nextract_futures_data(data::Py) -> DataFrames.DataFrame\n\n\nThe extract_futures_data function takes futures data data from a Python object and extracts it into a format suitable for further processing or analysis.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_candles-Tuple{Exchange, AbstractString, Union{AbstractString, AbstractSet, AbstractVector, Tuple{Vararg{T}} where T}}-exchanges","page":"Exchanges","title":"Fetch.fetch_candles","text":"Fetches candlestick data for a list of pairs from an exchange.\n\nfetch_candles(\n    exc::Exchange,\n    timeframe::AbstractString,\n    pairs::Union{AbstractString, AbstractSet, AbstractVector, Tuple{Vararg{T}} where T};\n    from,\n    to,\n    ohlcv_kind\n) -> Any\n\n\nThe fetch_candles function fetches candlestick data from a given exchange exc for a list of pairs over a specified timeframe. The from and to parameters define the date range for the fetched data. If from is not provided, it defaults to an empty string, which implies fetching data from the earliest available date. The type of candlestick data to fetch is determined by the ohlcv_kind parameter.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_limit-Tuple{Exchange, Union{Nothing, Int64}}-exchanges","page":"Exchanges","title":"Fetch.fetch_limit","text":"Defines the fetch limit for an exchange.\n\nfetch_limit(\n    exc::Exchange,\n    limit::Union{Nothing, Int64}\n) -> Union{Nothing, Int64}\n\n\nThis function fetches the limit for an exchange. If no limit is specified, it retrieves the default limit for the exchange.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_ohlcv-Tuple{Exchange, String, Union{AbstractSet{T}, AbstractVector{T}, Tuple{Vararg{T}}} where T}-exchanges","page":"Exchanges","title":"Fetch.fetch_ohlcv","text":"Fetches OHLCV data from an exchange for a list of pairs.\n\nfetch_ohlcv(\n    exc::Exchange,\n    timeframe::String,\n    pairs::Union{AbstractSet{T}, AbstractVector{T}, Tuple{Vararg{T}}} where T;\n    zi,\n    from,\n    to,\n    update,\n    reset,\n    progress,\n    ohlcv_kind\n) -> Dict{String, Data.PairData}\n\n\nThis function fetches OHLCV data from a given exchange exc for a list of pairs over a specified timeframe. The from and to parameters can represent dates or, if from is a negative number, the function fetches the last N=from candles. If update is true, the function checks for cached data and only fetches missing candles. If reset is true, the function removes cached data before fetching. The progress parameter determines whether a progress bar is shown. The type of OHLCV data to fetch is defined by the ohlcv_kind parameter.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_ohlcv-Tuple{Val{:ask}, Vararg{Any}}-exchanges","page":"Exchanges","title":"Fetch.fetch_ohlcv","text":"Prompts user for confirmation before fetching OHLCV data.\n\nfetch_ohlcv(::Val{:ask}, args...; kwargs...) -> Any\n\n\nThis function prompts the user for confirmation before fetching OHLCV data for the specified arguments args and keyword arguments kwargs. If the user inputs 'Y', 'y', or simply presses Enter, it proceeds with the fetch_ohlcv function. If any other input is given, the function returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.fetch_ohlcv-Tuple{Vector{Exchange}, Any}-exchanges","page":"Exchanges","title":"Fetch.fetch_ohlcv","text":"Fetches OHLCV data for multiple exchanges on the same timeframe.\n\nfetch_ohlcv(\n    excs::Vector{Exchange},\n    timeframe;\n    sandbox,\n    parallel,\n    wait_task,\n    kwargs...\n) -> Union{Nothing, Task}\n\n\nThis function fetches OHLCV data for multiple exchanges over the same timeframe. It accepts:\n\nA vector of exchange instances excs.\nThe desired timeframe timeframe.\n\nThe function can run in parallel if parallel is set to true. If wait_task is set to true, the function will wait for all tasks to complete before returning.\n\nYou can provide additional parameters using kwargs.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.find_since-Tuple{Exchange, Any}-exchanges","page":"Exchanges","title":"Fetch.find_since","text":"Returns the oldest possible timestamp for a pair.\n\nfind_since(exc::Exchange, pair) -> Any\n\n\nThis function iterates over the timeframes and periods of the exchange to find the oldest available timestamp for a given pair. If no data is found in any timeframe, it defaults to 1 day in the past.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.funding_data-Tuple{Exchange, AbstractString}-exchanges","page":"Exchanges","title":"Fetch.funding_data","text":"Retrieves all or a subset of funding data for a symbol from an exchange.\n\nfunding_data(exc::Exchange, sym::AbstractString) -> Any\n\n\nThe funding_data function retrieves all funding data returned by an exchange exc for a symbol sym.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.funding_history-Tuple{Exchange, Vector}-exchanges","page":"Exchanges","title":"Fetch.funding_history","text":"Fetches funding rate history from an exchange for a list of Derivative pairs.\n\nfunding_history(\n    exc::Exchange,\n    assets::Vector;\n    from,\n    to,\n    params,\n    sleep_t,\n    limit,\n    cleanup\n) -> Dict\n\n\nThe funding_history function fetches funding rate history from a given exchange exc for a list of assets. The from and to parameters define the date range for which to fetch the funding rate history. Additional parameters can be specified through the params dictionary. The function will wait for sleep_t seconds between each request to the exchange. The limit parameter can be used to limit the amount of data fetched. If cleanup is set to true, the function will perform a cleanup on the fetched data before returning it.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.funding_rate-Tuple{Exchange, AbstractString}-exchanges","page":"Exchanges","title":"Fetch.funding_rate","text":"Retrieves the funding rate for a symbol from an exchange.\n\nfunding_rate(exc::Exchange, s::AbstractString) -> Any\n\n\nThe funding_rate function retrieves the funding rate for a symbol s from an exchange exc.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.ohlcv_func_bykind-Tuple{Any, Any}-exchanges","page":"Exchanges","title":"Fetch.ohlcv_func_bykind","text":"Returns the appropriate OHLCV fetching function based on the specified kind.\n\nohlcv_func_bykind(exc, kind) -> Any\n\n\nThe ohlcv_func_bykind function determines and returns the appropriate OHLCV fetching function for the given exchange exc and kind.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.orderbook-Tuple{Any, Any}-exchanges","page":"Exchanges","title":"Fetch.orderbook","text":"Fetches an order book from an exchange for a symbol.\n\norderbook(exc, sym; limit, level) -> Any\n\n\nThe orderbook function fetches an order book from an exchange exc for a symbol sym. The limit parameter can be used to limit the depth of the order book. The level parameter specifies the level of the order book to fetch.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.parse_funding_row-Tuple{Py}-exchanges","page":"Exchanges","title":"Fetch.parse_funding_row","text":"Parses a row of funding data from a Python object.\n\nparse_funding_row(r::Py) -> Tuple{Int64, String, Float64}\n\n\nThe parse_funding_row function takes a row of funding data r from a Python object and parses it into a format suitable for further processing or analysis.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/#Fetch.update_ohlcv!-Tuple{DataFrames.DataFrame, Any, Any, Any}-exchanges","page":"Exchanges","title":"Fetch.update_ohlcv!","text":"Updates the tail of an OHLCV DataFrame with the most recent candles.\n\nupdate_ohlcv!(\n    df::DataFrames.DataFrame,\n    pair,\n    exc,\n    tf;\n    ohlcv_kind,\n    from\n) -> DataFrames.DataFrame\n\n\nThe update_ohlcv! function updates the tail of an OHLCV DataFrame df with the most recent candles for a given pair from an exchange exc over a timeframe tf. The type of OHLCV data to update is determined by the ohlcv_kind parameter.\n\n\n\n\n\n","category":"method"},{"location":"exchanges/","page":"Exchanges","title":"Exchanges","text":"[1]: It is possible that in the future the bot will work with the hummingbot gateway for DEX support, and at least another exchange type natively implemented (from panifie).","category":"page"},{"location":"data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"The Data module is responsible for the persistent storage and representation of OHLCV (Open, High, Low, Close, Volume) data.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"The primary backend is Zarr, which is similar to Feather or Parquet in that it optimizes for columnar data, or more generally, arrays. Zarr is simpler and allows for different encoding schemes. It supports compression by default and can be backed by various storage layers, including network-based ones. Compared to NoSQL databases, columnar storage has the drawback of having to read chunks for queries. However, we are almost always interested in time-series data, not scalar values, so the latency loss is negligible.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"We wrap a Zarr subtype of AbstractStore in a PingPong.Data.ZarrInstance. The module holds a global ZarrInstance at Data.zi[]. The default store used relies on LMDB. OHLCV data is organized according to exchanges, pairs, and timeframes (PingPong.Data.key_path).","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"There are several ways to collect data:","category":"page"},{"location":"data/#Using-the-Scrapers-module","page":"Data","title":"Using the Scrapers module","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Currently, there is support for Binance and Bybit archives.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using Scrapers: Scrapers as scr, BinanceData as bn\n## Download klines for ETH\nbn.binancedownload(\"eth\", market=:data, freq=:monthly, kind=:klines)\n## load them\nbn.binanceload(\"eth\", market=:data, freq=:monthly, kind=:klines)\n## Default market parameter is `:um` (usdm futures)\n\n# show all symbols that can be downloaded\nbn.binancesyms(market=:data)\n# load/download also accept `quote_currency` to filter by (default `usdt`)\nscr.selectsyms([\"eth\"], bn.binancesyms(market=:data), quote_currency=\"usdc\")","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"warning: Downloads are cached\nDownloading the same pair path again will only download newer archives. If data gets corrupted, pass reset=true to redownload it again. ","category":"page"},{"location":"data/#Using-the-Fetch-module","page":"Data","title":"Using the Fetch module","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"The Fetch module downloads data directly from the exchange using ccxt.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using TimeTicks\nusing Exchanges\nusing Fetch: Fetch as fe\n\nexc = getexchange!(:kucoin)\ntimeframe = tf\"1m\"\npairs = (\"BTC/USDT\", \"ETH/USDT\")\n# Will fetch the last 1000 candles, `to` can also be passed to download a specific range\nfe.fetch_ohlcv(exc, timeframe, pairs; from=-1000) # or `fetch_candles` for unchecked data","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Fetching directly from exchanges is not recommended for smaller timeframes since they are heavily rate-limited. Archives are a better option.","category":"page"},{"location":"data/#Using-Watchers","page":"Data","title":"Using Watchers","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"With the Watchers module, you can track live data from exchanges or other data sources and store it locally.  Implemented are watchers that track OHLCV:","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using Exchanges\nusing PingPong.Watchers: Watchers as wc, WatchersImpls as wi\nexc = getexchange!(:kucoin)\n\nw = wi.ccxt_ohlcv_tickers_watcher(exc;)\nwc.start!(w)","category":"page"},{"location":"data/","page":"Data","title":"Data","text":">>> w\n17-element Watchers.Watcher20{Dict{String, NamedTup...Nothing, Float64}, Vararg{Float64, 7}}}}}\nName: ccxt_ohlcv_ticker\nIntervals: 5 seconds(TO), 5 seconds(FE), 6 minutes(FL)\nFetched: 2023-03-07T12:06:18.690 busy: true\nFlushed: 2023-03-07T12:04:31.472\nActive: true\nAttemps: 0","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"As a convention, the view property of a watcher shows the processed data. In this case, the candles processed by the ohlcv_ticker_watcher will be stored in a dict.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":">>> w.view\nDict{String, DataFrames.DataFrame} with 220 entries:\n  \"HOOK/USDT\"          => 5×6 DataFrame…\n  \"ETH/USD:USDC\"       => 5×6 DataFrame…\n  \"PEOPLE/USDT:USDT\"   => 5×6 DataFrame…","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"There is another OHLCV watcher based on trades, that tracks only one pair at a time.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"w = wi.ccxt_ohlcv_watcher(exc, \"BTC/USDT:USDT\"; timeframe=tf\"1m\")\nw.view\n956×6 DataFrame\n Row │ timestamp            open     high     low      close    volume  \n     │ DateTime             Float64  Float64  Float64  Float64  Float64 \n─────┼──────────────────────────────────────────────────────────────────\n...","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Other implemented watchers are the orderbook watcher, and watchers that parse data feeds from 3rd party APIs.","category":"page"},{"location":"data/#Other-sources","page":"Data","title":"Other sources","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Assuming you have your own pipeline to fetch candles, you can use the functions PingPong.Data.save_ohlcv and PingPong.Data.load_ohlcv to manage the data. To save the data, it is easier if you pass a standard OHLCV dataframe, otherwise you need to provide a saved_col argument that indicates the correct column index to use as the timestamp column (or use lower-level functions).","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"using PingPong\n@environment!\n@assert da === Data\nsource_name = \"mysource\"\npair = \"BTC123/USD\"\ntimeframe = \"1m\"\nzi = Data.zi # the global zarr instance, or use your own\nmydata = my_custom_data_loader()\nda.save_ohlcv(zi, source_name, pair, timeframe, mydata)","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"To load the data back:","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"da.load_ohlcv(zi, source_name, pair, timeframe)","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Data is returned as a DataFrame with open,high,low,close,volume,timestamp columns. Since these save/load functions require a timestamp column, they check that the provided index is contiguous, it should not have missing timestamps, according to the subject timeframe. It is possible to disable those checks by passing check=:none.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"If you want to save other kinds of data, there are the PingPong.Data.save_data and PingPong.Data.load_data functions. Unlike the ohlcv functions, these functions don't check for contiguity, so it is possible to store sparse data. The data, however, still requires a timestamp column, because data when saved can either be prepend or appended, therefore an index must still be available to maintain order. While OHLCV data requires a concrete type for storage (default Float64) generic data can either be saved with a shared type, or instead serialized. To serialize the data while saving pass the serialize=true argument to save_data, while to load serialized data pass serialized=true to load_data.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"When loading data from storage, you can directly use the ZArray by passing raw=true to load_ohlcv or as_z=true or with_z=true to load_data. By managing the array directly you can avoid materializing the entire dataset, which is required when dealing with large amounts of data.","category":"page"},{"location":"data/#Indexing","page":"Data","title":"Indexing","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"The Data module implements dataframe indexing by dates such that you can conveniently access rows by:","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"df[dt\"2020-01-01\", :high] # get the high of the date 2020-01-01\ndf[dtr\"2020-..2021-\", [:high, :low]] # get all high and low for the year 2020\nafter(df, dt\"2020-01-01\") # get all candles after the date 2020-01-01\nbefore(df, dt\"2020-01-01\") # get all candles up until the date 2020-01-01","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"With ohlcv data, we can access the timeframe of the series directly from the dataframe by calling timeframe!(df). This will either return the previously set timeframe or infer it from the timestamp column. You can set the timeframe by calling e.g. timeframe!(df, tf\"1m\") or timeframe!! to overwrite it.","category":"page"},{"location":"data/#Caching","page":"Data","title":"Caching","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Data.Cache.save_cache and Data.Cache.load_cache can be used to store generic metadata like JSON payloads. The data is saved in the PingPong data directory which is either under the XDG_CACHE_DIR[1] if set or under $HOME/.cache by default.","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"[1]: Default path might be a scratchspace (from Scratch.jl) in the future","category":"page"},{"location":"API/optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"API/optimization/","page":"Optimization","title":"Optimization","text":"Modules = [Optimization]","category":"page"},{"location":"API/optimization/#Optimization.RUNNING","page":"Optimization","title":"Optimization.RUNNING","text":"A constant instance of OptRunning initialized with false.\n\n\n\n\n\n","category":"constant"},{"location":"API/optimization/#Optimization.disabled_methods","page":"Optimization","title":"Optimization.disabled_methods","text":"A set of optimization methods that are disabled and not used with the BlackBoxOptim package.\n\n\n\n\n\n","category":"constant"},{"location":"API/optimization/#Optimization.BestColumn","page":"Optimization","title":"Optimization.BestColumn","text":"A column in the progress bar representing the best optimization result.\n\njob\nsegments\nmeasure\nbest\n\nThis struct represents a column in the progress bar that displays the best result of the optimization job. It contains a ProgressJob, a vector of Segment objects, a Measure object, and a reference to the best result. The constructor creates a Segment with a string representation of the best result and sets the width of the measure to 15.\n\n\n\n\n\n","category":"type"},{"location":"API/optimization/#Optimization.ContextSpace","page":"Optimization","title":"Optimization.ContextSpace","text":"A named tuple representing the context and space in the optimization process.\n\n\n\n\n\n","category":"type"},{"location":"API/optimization/#Optimization.OptRunning","page":"Optimization","title":"Optimization.OptRunning","text":"A mutable structure representing the running state of an optimization process.\n\nvalue\n\nThis structure contains a single field value which is an atomic boolean. It is used to indicate whether the optimization process is currently running or not.\n\n\n\n\n\n","category":"type"},{"location":"API/optimization/#Optimization.OptSession","page":"Optimization","title":"Optimization.OptSession","text":"A structure representing an optimization session.\n\ns\nctx\nparams\nattrs\nresults\nbest\nlock\ns_clones\nctx_clones\n\nThis structure stores all the evaluated parameters combinations during an optimization session. It contains fields for the strategy, context, parameters, attributes, results, best result, lock, and clones of the strategy and context for each thread. The constructor for OptSession also takes an offset and number of threads as optional parameters, with default values of 0 and the number of available threads, respectively.\n\n\n\n\n\n","category":"type"},{"location":"API/optimization/#Optimization.ParamsColumn","page":"Optimization","title":"Optimization.ParamsColumn","text":"A column in the progress bar representing parameters.\n\njob\nsegments\nmeasure\nparams\n\nThis struct represents a column in the progress bar that displays the parameters of the optimization job. It contains a ProgressJob, a vector of Segment objects, a Measure object, and a reference to the parameters. The constructor creates a Segment with a string representation of the parameters and sets the width of the measure to 15.\n\n\n\n\n\n","category":"type"},{"location":"API/optimization/#BlackBoxOptim.bboptimize-Tuple{Strategies.SimStrategy}","page":"Optimization","title":"BlackBoxOptim.bboptimize","text":"Optimize parameters using the BlackBoxOptim package.\n\nbboptimize(\n    s::Strategies.SimStrategy;\n    seed,\n    splits,\n    resume,\n    save_freq,\n    zi,\n    kwargs...\n)\n\n\nsplits: how many times to run the backtest for each step\nseed: random seed\nkwargs: The arguments to pass to the underlying BBO function. See the docs for the BlackBoxOptim package. Here are some most common parameters:\nMaxTime: max evaluation time for the optimization\nMaxFuncEvals: max number of function (backtest) evaluations\nTraceMode: (:silent, :compact, :verbose) controls the logging\nMaxSteps, MaxStepsWithoutProgress\n\nFrom within your strategy, define four ping! functions:\n\nping!(::Strategy, ::OptSetup): for the period of time to evaluate and the parameters space for the optimization.\nping!(::Strategy, params, ::OptRun): called before running the backtest, should apply the parameters to the strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Misc.ping!-Tuple{Strategies.Strategy, Any, Executors.OptRun}","page":"Optimization","title":"Misc.ping!","text":"Applies parameters to strategy before backtest\n\nping!(_::Strategies.Strategy, params, _::Executors.OptRun)\n\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Misc.ping!-Tuple{Strategies.Strategy, Executors.OptSetup}","page":"Optimization","title":"Misc.ping!","text":"Returns Optimizations.ContextSpace for backtesting\n\nping!(_::Strategies.Strategy, _::Executors.OptSetup)\n\n\nThe ctx field (Executors.Context) specifies the backtest time period, while space is either an already built BlackBoxOptim.SearchSpace subtype or a tuple (Symbol, args...) for a pre-defined BBO package search space.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization._multi_opt_func-NTuple{4, Any}","page":"Optimization","title":"Optimization._multi_opt_func","text":"Multi-threaded optimization function.\n\n_multi_opt_func(\n    splits,\n    backtest_func,\n    median_func,\n    obj_type\n) -> Optimization.var\"#36#38\"\n\n\nThe function takes four arguments: splits, backtest_func, median_func, and obj_type. splits is the number of splits for the optimization process, backtest_func is the backtest function, median_func is the function to calculate the median, and obj_type is the type of the objective. The function returns a function that performs a multi-threaded optimization for a given set of parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization._single_opt_func-Tuple{Any, Any, Any, Vararg{Any}}","page":"Optimization","title":"Optimization._single_opt_func","text":"Single-threaded optimization function.\n\n_single_opt_func(\n    splits,\n    backtest_func,\n    median_func,\n    args...\n) -> Optimization.var\"#42#44\"\n\n\nThe function takes four arguments: splits, backtest_func, median_func, and obj_type. splits is the number of splits for the optimization process, backtest_func is the backtest function, median_func is the function to calculate the median, and obj_type is the type of the objective. The function returns a function that performs a single-threaded optimization for a given set of parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization._spacedims-Tuple{Any}","page":"Optimization","title":"Optimization._spacedims","text":"Returns the dimension of the search space.\n\n_spacedims(params) -> Any\n\n\nThis function takes the parameters as input, which should include lower and upper bounds arrays as the second and third elements. It asserts that the lengths of these arrays are equal and returns their common length, which represents the dimension of the search space.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization._tostring-Tuple{Any, Any}","page":"Optimization","title":"Optimization._tostring","text":"Converts the provided parameters into a string representation.\n\n_tostring(prefix, params) -> String\n\n\nThe function takes a prefix and a set of parameters as input. It joins the prefix and the parameters into a single string, with each parameter converted to a compact number representation. The resulting string is then truncated to fit the display size.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.agg-Tuple{OptSession}","page":"Optimization","title":"Optimization.agg","text":"Aggregates the results of an optimization session.\n\nagg(sess::OptSession; reduce_func, agg_func) -> Any\n\n\nThe function takes an optimization session sess and optional functions reduce_func and agg_func. It groups the results by the session parameters, applies the reduce_func to each group, and then applies the agg_func to the reduced results.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.bbomethods","page":"Optimization","title":"Optimization.bbomethods","text":"Returns a set of optimization methods supported by BlackBoxOptim.\n\nbbomethods() -> Set{Symbol}\nbbomethods(multi) -> Set\n\n\nThis function filters the methods based on the multi parameter and excludes the methods listed in disabled_methods. If multi is true, it returns multi-objective methods, otherwise it returns single-objective methods.\n\n\n\n\n\n","category":"function"},{"location":"API/optimization/#Optimization.ctxfromstrat-Tuple{Any}","page":"Optimization","title":"Optimization.ctxfromstrat","text":"Extracts the context, parameters, and search space from a given strategy.\n\nctxfromstrat(s)\n\n\nThis function takes a strategy as input and returns the context, parameters, and search space associated with that strategy. The search space can be a SearchSpace instance, a function, or a tuple where the first element is the BBO space type and the rest are arguments for the space constructor.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.ctxsteps-Tuple{Any, Any}","page":"Optimization","title":"Optimization.ctxsteps","text":"Calculates the small and big steps for the optimization context.\n\nctxsteps(\n    ctx,\n    splits\n) -> NamedTuple{(:small_step, :big_step), <:Tuple{Any, Any}}\n\n\nThe function takes two arguments: ctx and splits. ctx is the optimization context and splits is the number of splits for the optimization process. The function returns a named tuple with small_step and big_step which represent the step size for the optimization process.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.define_backtest_func-Tuple{Any, Any, Any}","page":"Optimization","title":"Optimization.define_backtest_func","text":"Defines the backtest function for an optimization session.\n\ndefine_backtest_func(\n    sess,\n    small_step,\n    big_step\n) -> Optimization.var\"#opt_backtest_func#33\"\n\n\nThe function takes three arguments: sess, small_step, and big_step. sess is the optimization session, small_step is the small step size for the optimization process, and big_step is the big step size for the optimization process. The function returns a function that performs a backtest for a given set of parameters and a given iteration number.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.define_median_func-Tuple{Any}","page":"Optimization","title":"Optimization.define_median_func","text":"Defines the median function for multi-objective mode.\n\ndefine_median_func(\n    ismulti\n) -> Union{Optimization.var\"#46#48\", Optimization.var\"#47#49\"}\n\n\nThe function takes a boolean argument ismulti which indicates if the optimization is multi-objective. If ismulti is true, the function returns a function that calculates the median over all the repeated iterations. Otherwise, it returns a function that calculates the median of a given array.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.define_opt_func-Tuple{Strategies.Strategy}","page":"Optimization","title":"Optimization.define_opt_func","text":"Defines the optimization function for a given strategy.\n\ndefine_opt_func(\n    s::Strategies.Strategy;\n    backtest_func,\n    ismulti,\n    splits,\n    obj_type,\n    isthreaded\n)\n\n\nThe function takes several arguments: s, backtest_func, ismulti, splits, obj_type, and isthreaded. s is the strategy, backtest_func is the backtest function, ismulti indicates if the optimization is multi-objective, splits is the number of splits for the optimization process, obj_type is the type of the objective, and isthreaded indicates if the optimization is threaded. The function returns the appropriate optimization function based on these parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.delete_sessions!-Tuple{String}","page":"Optimization","title":"Optimization.delete_sessions!","text":"Clears optimization sessions of a strategy.\n\ndelete_sessions!(s_name::String; keep_by, zi)\n\n\nThe function accepts a strategy name s_name and an optional keep_by dictionary. If keep_by is provided, sessions matching these attributes (ctx, params, or attrs) are not deleted. It checks each session, and deletes it if it doesn't match keep_by or if keep_by is empty.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.extbayes!-Tuple{}","page":"Optimization","title":"Optimization.extbayes!","text":"Loads the BayesianOptimization extension.\n\nThe function checks if the BayesianOptimization package is installed in the current environment. If not, it prompts the user to add it to the main environment.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.filter_results-Tuple{Strategies.Strategy, Any}","page":"Optimization","title":"Optimization.filter_results","text":"Filters the optimization results based on certain criteria.\n\nfilter_results(\n    ::Strategies.Strategy,\n    sess;\n    cut,\n    min_results\n) -> Any\n\n\nThe function takes a strategy and a session as input, along with optional parameters for cut and minimum results. It filters the results based on the cut value and the minimum number of results.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.fitness_scheme-Tuple{Strategies.Strategy, Any}","page":"Optimization","title":"Optimization.fitness_scheme","text":"Determines the fitness scheme for a given strategy and number of objectives.\n\nfitness_scheme(\n    s::Strategies.Strategy,\n    n_obj\n) -> BlackBoxOptim.ParetoFitnessScheme{_A, Float64} where _A\n\n\nThis function takes a strategy and a number of objectives as input. It checks if the strategy has a custom weights function defined in its attributes. If it does, this function is used as the aggregator in the ParetoFitnessScheme. If not, a default ParetoFitnessScheme is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.gridfromparams-Tuple{Any}","page":"Optimization","title":"Optimization.gridfromparams","text":"Generates a grid from the provided parameters.\n\ngridfromparams(params) -> Any\n\n\nThe function takes a set of parameters as input. It generates a grid by taking the product of the parameters and reshaping it to the length of the parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.gridfromresults-Tuple{OptSession, Any}","page":"Optimization","title":"Optimization.gridfromresults","text":"Generates a grid from the optimization results.\n\ngridfromresults(sess::OptSession, results; kwargs...) -> Any\n\n\nThe function takes an optimization session and results as input. It generates a grid by extracting the parameters from each row of the results.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.gridpbar!-Tuple{Any, Any}","page":"Optimization","title":"Optimization.gridpbar!","text":"Initializes a progress bar for grid optimization.\n\ngridpbar!(sess, first_params) -> Base.RefValue\n\n\nThis function sets up a progress bar for the grid optimization process. It creates a ParamsColumn and a BestColumn and adds them to the default columns. The function returns a reference to the current parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.gridsearch-Tuple{Strategies.SimStrategy}","page":"Optimization","title":"Optimization.gridsearch","text":"Backtests the strategy across combination of parameters.\n\ngridsearch(\n    s::Strategies.SimStrategy;\n    seed,\n    splits,\n    save_freq,\n    resume,\n    logging,\n    random_search,\n    zi,\n    grid_itr,\n    offset\n)\n\n\nseed: random seed set before each backtest run.\nsplits: the number segments into which the context is split.\nsave_freq: how frequently (Period) to save results, when nothing (default) saving is skipped.\nlogging: enabled logging\nrandom_search: shuffle parameters combinations before iterations\n\nOne parameter combination runs splits times, where each run uses a period that is a segment of the full period of the given Context given. (The Context comes from the strategy ping!(s, params, OptRun())\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.isrunning-Tuple{}","page":"Optimization","title":"Optimization.isrunning","text":"Checks if the optimization process is currently running.\n\nisrunning() -> Bool\n\n\nThis function returns the value field of the RUNNING instance, indicating whether the optimization process is currently running.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.isthreadsafe-Tuple{Strategies.Strategy}","page":"Optimization","title":"Optimization.isthreadsafe","text":"Tests if if the strategy is thread safe by looking up the THREADSAFE global. \n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.load_session","page":"Optimization","title":"Optimization.load_session","text":"Loads an optimization session from storage.\n\nload_session(name; ...) -> Any\nload_session(name, startstop; ...) -> Any\nload_session(name, startstop, params_k; ...) -> Any\nload_session(\n    name,\n    startstop,\n    params_k,\n    code;\n    zi,\n    as_z,\n    results_only,\n    s\n) -> Any\n\n\nThis function loads an optimization session from the provided zarr instance zi based on the given parameters. The parameters include the strategy name, start and stop date of the backtesting context, the first letter of every parameter, and a hash of the parameters and attributes truncated to 4 characters. The function returns the loaded session, either as a zarr array if as_z is true, or as an OptSession object otherwise. If results_only is true, only the results DataFrame of the session is returned.\n\n\n\n\n\n","category":"function"},{"location":"API/optimization/#Optimization.log_path","page":"Optimization","title":"Optimization.log_path","text":"Generates the path for the log file of a given strategy.\n\nlog_path(s) -> Tuple{Any, Any}\nlog_path(s, name) -> Tuple{Any, Any}\n\n\nThe function takes a strategy s and an optional name (defaulting to the current timestamp). It constructs a directory path based on the strategy's path, and ensures this directory exists. Then, it returns the full path to the log file within this directory, along with the directory path itself.\n\n\n\n\n\n","category":"function"},{"location":"API/optimization/#Optimization.logs-Tuple{Any}","page":"Optimization","title":"Optimization.logs","text":"Returns the paths to all log files for a given strategy.\n\nlogs(s) -> Any\n\n\nThe function takes a strategy s as an argument. It retrieves the directory path for the strategy's log files and returns the full paths to all log files within this directory.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.logs_clear-Tuple{Any}","page":"Optimization","title":"Optimization.logs_clear","text":"Clears all log files for a given strategy.\n\nlogs_clear(s)\n\n\nThe function takes a strategy s as an argument. It retrieves the directory path for the strategy's log files and removes all files within this directory.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.lowerupper-Tuple{Any}","page":"Optimization","title":"Optimization.lowerupper","text":"Extracts the lower and upper bounds from a parameters dictionary.\n\nlowerupper(params) -> Tuple{Vector{Any}, Vector{Any}}\n\n\nThe function takes a parameters dictionary params as an argument. It returns two arrays, lower and upper, containing the first and last values of each parameter range in the dictionary, respectively.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.metrics_func-Tuple{Any}","page":"Optimization","title":"Optimization.metrics_func","text":"Calculates the metrics for a given strategy.\n\nmetrics_func(s; initial_cash)\n\n\nThe function takes a strategy s and an initial cash amount as arguments. It calculates the objective score, the current total cash, the profit and loss ratio, and the number of trades. The function returns these metrics as a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.objectives-Tuple{Any}","page":"Optimization","title":"Optimization.objectives","text":"Returns the number of objectives and their type.\n\nobjectives(s)\n\n\nThe function takes a strategy s as an argument. It returns a tuple containing the type of the objective and the number of objectives.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.optsession-Tuple{Strategies.Strategy}","page":"Optimization","title":"Optimization.optsession","text":"Removes results that don't have all the repeated evaluation.\n\noptsession(s::Strategies.Strategy; seed, splits, offset)\n\n\nThe function groups the results by session parameters and removes those groups that don't have a complete set of evaluations, as defined by the splits attribute of the session.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.optsessions-Tuple{String}","page":"Optimization","title":"Optimization.optsessions","text":"Returns the zarrays storing all the optimization session over the specified zarrinstance.\n\noptsessions(s_name::String; zi) -> Any\n\n\nThe function takes a strategy s as an argument. It retrieves the directory path for the strategy's log files and returns the full paths to all log files within this directory.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.print_log","page":"Optimization","title":"Optimization.print_log","text":"Prints the content of a specific log file for a given strategy.\n\nprint_log(s)\nprint_log(s, idx)\n\n\nThe function takes a strategy s and an optional index idx (defaulting to the last log file). It retrieves the directory path for the strategy's log files, selects the log file at the specified index, and prints its content.\n\n\n\n\n\n","category":"function"},{"location":"API/optimization/#Optimization.progsearch-Tuple{Any}","page":"Optimization","title":"Optimization.progsearch","text":"A progressive search performs multiple grid searches with only 1 repetition per parameters combination.\n\nprogsearch(s; sess, rounds, cut, kwargs...)\n\n\nAfter each search is completed, the results are filtered according to custom rules. The parameters from the results that match the filtering will be backtested again with a different offset which modifies the backtesting period. rounds: how many iterations (of grid searches) to perform sess: If a Ref{<:OptSession} is provided, search will resume from the session previous results halve: At each iteration\n\nAdditional kwargs are forwarded to the grid search.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.remove_incomplete!-Tuple{OptSession}","page":"Optimization","title":"Optimization.remove_incomplete!","text":"Remove results that don't have all the repeated evalutaion.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.result_params","page":"Optimization","title":"Optimization.result_params","text":"Fetches the named tuple of a single parameters combination.\n\nresult_params(\n    sess::OptSession\n) -> Union{Nothing, NamedTuple}\nresult_params(\n    sess::OptSession,\n    idx\n) -> Union{Nothing, NamedTuple}\n\n\nThe function takes an optimization session sess and an optional index idx (defaulting to the last row of the results). It returns the parameters of the optimization session at the specified index as a named tuple.\n\n\n\n\n\n","category":"function"},{"location":"API/optimization/#Optimization.resume!-Tuple{Any}","page":"Optimization","title":"Optimization.resume!","text":"Resumes the optimization session from saved state.\n\nresume!(sess; zi) -> Bool\n\n\nThe function attempts to load a saved session and resumes it. If the saved session does not match the current session in terms of strategy, context, parameters, or attributes, an error is thrown. If the session is successfully resumed, the results from the saved session are appended to the current session's results.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.rgx_key-Tuple{Any, Any, Any}","page":"Optimization","title":"Optimization.rgx_key","text":"Generates a regular expression for matching optimization session keys.\n\nrgx_key(startstop, params_k, code) -> Regex\n\n\nThe function takes three arguments: startstop, params_k, and code. These represent the start and stop date of the backtesting context, the first letter of every parameter, and a hash of the parameters and attributes truncated to 4 characters, respectively. The function returns a Regex object that matches the string representation of an optimization session key.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.running!-Tuple{}","page":"Optimization","title":"Optimization.running!","text":"Sets the running state of the optimization process to true.\n\nrunning!() -> Bool\n\n\nThis function changes the value field of the RUNNING instance to true, indicating that the optimization process is currently running.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.save_session-Tuple{OptSession}","page":"Optimization","title":"Optimization.save_session","text":"Save the optimization session over the provided zarr instance\n\nsave_session(\n    sess::OptSession;\n    from,\n    to,\n    zi\n) -> Union{Nothing, Dict}\n\n\nsess is the OptSession to be saved. The from parameter specifies the starting index for saving optimization results progressively, while to specifies the ending index. The function uses the provided zarr instance zi for storage. The function first ensures that the zgroup for the strategy exists. Then, it writes various session attributes to zarr if we're starting from the beginning (from == 0). Finally, it saves the result data for the specified range (from to to).\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.session_key-Tuple{OptSession}","page":"Optimization","title":"Optimization.session_key","text":"Generates a unique key for an optimization session.\n\nsession_key(\n    sess::OptSession\n) -> Tuple{String, NamedTuple{(:s_part, :ctx_part, :params_part, :config_part), <:Tuple{Any, String, String, String}}}\n\n\nThis function generates a unique key for an optimization session by combining various parts of the session's properties. The key is a combination of the session's strategy name, context range, parameters, and a hash of the parameters and attributes.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.setparams!-Tuple{Any, Any, Any}","page":"Optimization","title":"Optimization.setparams!","text":"Override attributes in a strategy with values from a given parameters dictionary.\n\noverrides!(s::AbstractStrategy, params::Dict, pidx::Dict) -> AbstractStrategy\n\nOverride attributes in s with values from the params dictionary using the parameter index pidx. This is useful for updating strategy attributes during an optimization run.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.slidesearch-Tuple{Strategies.Strategy}","page":"Optimization","title":"Optimization.slidesearch","text":"Backtests by sliding over the backtesting period, by the smallest timeframe (the strategy timeframe).\n\nslidesearch(s::Strategies.Strategy; multiplier)\n\n\nUntil a full range of timeframes is reached between the strategy timeframe and backtesting context timeframe.\n\nmultiplier: the steps count (total stepps will be multiplier * context_timeframe / s.timeframe )\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.stopping!-Tuple{}","page":"Optimization","title":"Optimization.stopping!","text":"Sets the running state of the optimization process to false.\n\nstopping!() -> Bool\n\n\nThis function changes the value field of the RUNNING instance to false, indicating that the optimization process is not currently running.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.zgroup_opt-Tuple{Any}","page":"Optimization","title":"Optimization.zgroup_opt","text":"Get the Opt group from the provided zarr instance.\n\n\n\n\n\n","category":"method"},{"location":"API/optimization/#Optimization.zgroup_strategy-Tuple{Any, String}","page":"Optimization","title":"Optimization.zgroup_strategy","text":"Returns the zarr group for a given strategy.\n\nzgroup_strategy(\n    zi,\n    s_name::String\n) -> NamedTuple{(:s_group, :opt_group), <:Tuple{Any, Any}}\n\n\nThis function checks if a zarr group exists for the given strategy name in the optimization group of the zarr instance. If it exists, the function returns the group; otherwise, it creates a new zarr group for the strategy.\n\n\n\n\n\n","category":"method"},{"location":"engine/engine/#Engine","page":"Executors","title":"Engine","text":"","category":"section"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Within the PingPong \"model\", we use the ping! and pong! functions to communicate between strategies and executors. The executor \"pings\" the strategy, implying that the strategy should do or return something. On the other hand, the strategy \"pongs\" the executor, expecting it to do or return something.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"In the PingPong framework, the user generally only writes ping! functions within their strategies. However, if the user requires custom behavior that is not implemented by the framework, they may need to write pong! functions.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Unlike other trading bots that offer a set of methods for tuning purposes, usually tied to the super class of the strategy, PingPong conventionally deals only with ping! and pong! functions. This allows you to know that whenever a pong! call is made from the strategy, it is a point where simulation and live execution may diverge.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"The ping and pong functions are implemented in a way that they dispatch differently according to the execution mode of the strategy. There are 3 execution modes:","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"Sim: This mode is used by the backtester to run simulations.\nPaper: This is the dry run mode, which runs the bot as if it were live, working with live data feeds and simulating order execution with live prices.\nLive: Similar to Paper, but with order execution actually forwarded to a live exchange (e.g., through CCXT).","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"If the strategy is instantiated in Sim mode, calling pong!(s, ...), where s is the strategy object of type Strategy{Sim, N, E, M, C}, the pong! function will dispatch to the Sim execution method. The other two parameters, N and E, are required for concretizing the strategy type:","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"N<:Symbol: The symbol that matches the module name of the strategy, such as :Example.\nE<:ExchangeID: The symbol that has already been checked to match a valid CCXT exchange, which will be the exchange that the strategy will operate on.\nM<:MarginMode: The margin mode of the strategy, which can be NoMargin, IsolatedMargin, or CrossMargin. Note that the margin mode also has a type parameter to specify if hedged positions (having long and short on the same asset at the same time) are allowed. Isolated and Cross are shorthand for IsolatedMargin{NotHedged} and CrossMargin{NotHedged}.\nC: The symbol of the CurrencyCash that represents the balance of the strategy, e.g., :USDT.","category":"page"},{"location":"engine/engine/","page":"Executors","title":"Executors","text":"To follow the pong! dispatch convention, you can expect the first argument of every pong function to be the strategy object itself, while ping functions might have either the strategy object or the type of the strategy as the first argument (Type{Strategy{...}}).","category":"page"},{"location":"engine/features/#Strategy-Combination","page":"Features","title":"Strategy Combination","text":"","category":"section"},{"location":"engine/features/","page":"Features","title":"Features","text":"The types considered for possible combinations are:","category":"page"},{"location":"engine/features/","page":"Features","title":"Features","text":"NoMargin,Isolated,Cross: These types are considered if the strategy trades on derivatives markets.\nHedged,NotHedged: These types are considered for positions management, determining whether it is one-way or both.","category":"page"},{"location":"engine/features/","page":"Features","title":"Features","text":" Hedged NotHedged\nNoMargin  X\nIsolated - X\nCross - -","category":"page"},{"location":"engine/features/","page":"Features","title":"Features","text":"Currently, the bot supports trading on spot markets, or derivatives markets with isolated margin. There should be errors (or at least warnings) already implemented to check that the strategy universe respects the strategy combination. ","category":"page"},{"location":"engine/features/","page":"Features","title":"Features","text":"There isn't any restriction as to why a strategy should only be allowed to have only one type of market, since most of the logic is handled per asset instance. However, supporting Cross margin might require further constraints. Moreover, since it is possible to create and run as many strategies as you want in parallel, having the strategy type to retain simplicity enables more composability.","category":"page"},{"location":"engine/features/#Minor-Limitations","page":"Features","title":"Minor Limitations","text":"","category":"section"},{"location":"engine/features/","page":"Features","title":"Features","text":"These limitations mostly mean not implemented features:","category":"page"},{"location":"engine/features/","page":"Features","title":"Features","text":"Inverse contracts: The logic doesn't take into account if an asset is a contract margined and settled in the quote currency. Strategies will throw an error if the assets universe contain inverse contracts.\nFixed fees: All fees are considered to be a percentage of trades. Markets that do trades with fixed fees have not been found, they are usually used only for withdrawals and the bot doesn't do that.\nFunding fees: Despite all the pieces being implemented to emulate funding fees, the backtester doesn't pay funding fees when time comes, and for liquidations it simply uses a 2x trading fee.\nLeverage can only be updated when a position is closed and without any open orders.","category":"page"},{"location":"API/prices/#Prices","page":"Prices","title":"Prices","text":"","category":"section"},{"location":"API/prices/","page":"Prices","title":"Prices","text":"Modules = [Prices]","category":"page"},{"location":"customizations/exchanges/","page":"Exchanges","title":"Exchanges","text":"The bot is primarily designed for cryptocurrency trading; however, it can be adapted for stock trading by interfacing with various brokers' APIs. To do this, you will need to create a custom implementation of the Exchange abstract type.","category":"page"},{"location":"customizations/exchanges/","page":"Exchanges","title":"Exchanges","text":"Here is a basic structure of how you can define your broker-specific exchange:","category":"page"},{"location":"customizations/exchanges/","page":"Exchanges","title":"Exchanges","text":"struct MyBroker <: Exchange\n    # Implementation details here\nend","category":"page"},{"location":"customizations/exchanges/","page":"Exchanges","title":"Exchanges","text":"To understand the requirements for substituting the default exchange implementation, review the check function located in the Exchanges module. It is worth noting that creating a fully compatible Exchange type may be more complex and less efficient than extending the CCXT library with broker support to avoid the overhead of calling Python code.","category":"page"},{"location":"customizations/exchanges/","page":"Exchanges","title":"Exchanges","text":"In future updates, the bot may include direct support for decentralized exchanges (DEX). This could be achieved by integrating middleware from hummingbot connectors, developing custom API communications between the bot and DEX nodes, or potentially through enhancements to the CCXT library, should it expand to accommodate DEX functionalities.","category":"page"},{"location":"remote/#Control-the-bot-remotely","page":"Control the bot remotely","title":"Control the bot remotely","text":"","category":"section"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"A pingpong strategy can be controlled with telegram. ","category":"page"},{"location":"remote/#Requirements","page":"Control the bot remotely","title":"Requirements","text":"","category":"section"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"Create a new telegram bot:","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"Initiate a chat with BotFather\nsend the /start command\nfollow the prompts","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"Get a chat_id:","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"Initiate a chat with userinfobot\nsend the name of the bot you created, e.g. @mynewbot\nuse the Id in the response as your chat_id","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"Once you have the token and the id, save them either:","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"in the strategy config file as keys tgtoken and tgchat_id\nafter loading the strategy object in the strategy attributes (same keys (Symbol) as config)\nas env vars TELEGRAM_BOT_TOKEN and TELEGRAM_BOT_CHAT_ID.","category":"page"},{"location":"remote/#The-telegram-client","page":"Control the bot remotely","title":"The telegram client","text":"","category":"section"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"Start listening for commands:","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"using PingPong\nPingPoing.Remote.tgstart!(s) # where s is your strategy object","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"Now you can start a chat with your telegram bot. The supported commands are:","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"start: start the strategy\nstop: stop the strategy\nstatus: show summary\ndaily: rolling 1d history\nweekly: rolling 7d history\nmonthly: rolling 30d history\nbalance: show current balance\nassets: trades history by asset\nconfig: show toml config\nlogs: upload most recent logs\nset: set a strategy attribute\nget: get a strategy attribute","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"To manually stop the telegram bot:","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"PingPoing.Remote.tgstop!(s) # where s is your strategy object","category":"page"},{"location":"remote/","page":"Control the bot remotely","title":"Control the bot remotely","text":"To prevent the bot from talking with strangers you can set a specific username that the bot is allowed to talk to by setting the tgusername(Symbol) key to your desired telegram username.","category":"page"},{"location":"API/instances/#Instances","page":"Instances","title":"Instances","text":"","category":"section"},{"location":"API/instances/","page":"Instances","title":"Instances","text":"Modules = [PingPong.Engine.Instances]","category":"page"},{"location":"API/instances/#Instances.LEVERAGE_PRECISION","page":"Instances","title":"Instances.LEVERAGE_PRECISION","text":"The number of digits allowed for leverage values.\n\n\n\n\n\n","category":"constant"},{"location":"API/instances/#Instances.POSITION_PRECISION","page":"Instances","title":"Instances.POSITION_PRECISION","text":"The number of digits to keep for margin calculations.\n\n\n\n\n\n","category":"constant"},{"location":"API/instances/#Instances.POSITION_ROUNDING_MODE","page":"Instances","title":"Instances.POSITION_ROUNDING_MODE","text":"A constant defining the rounding mode for positions as RoundToZero.\n\n\n\n\n\n","category":"constant"},{"location":"API/instances/#Instances.PositionChange","page":"Instances","title":"Instances.PositionChange","text":"Position change is one of PositionOpen, PositionUpdate, PositionClose.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.PositionStatus","page":"Instances","title":"Instances.PositionStatus","text":"Position status is one of PositionOpen, PositionClose.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.AbstractInstance","page":"Instances","title":"Instances.AbstractInstance","text":"Defines the abstract type for an instance.\n\nThe AbstractInstance type is a generic abstract type for an instance. It is parameterized by two types: A, which must be a subtype of AbstractAsset, and E, which must be a subtype of ExchangeID.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.AssetInstance","page":"Instances","title":"Instances.AssetInstance","text":"Defines a structure for an asset instance.\n\nasset: The identifier of the asset.\ndata: The OHLCV (Open, High, Low, Close, Volume) series for the asset.\nhistory: The trade history of the pair.\nlock: A lock for synchronizing access to the asset instance.\ncash: The amount of the asset currently held. This can be positive or negative (short).\ncash_committed: The amount of the asset currently committed for orders.\nexchange: The exchange instance that this asset instance belongs to.\nlongpos: The long position of the asset.\nshortpos: The short position of the asset.\nlastpos: The last position of the asset.\nlimits: The minimum order size (from the exchange).\nprecision: The number of decimal points (from the exchange).\nfees: The fees associated with the asset (from the exchange).\n\nAn AssetInstance holds all known state about an exchange asset like BTC/USDT.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.AssetInstance-Tuple{Any}","page":"Instances","title":"Instances.AssetInstance","text":"Creates an AssetInstance.\n\nAssetInstance(a; data, exc, margin, min_amount)\n\n\nThis function creates an AssetInstance with the specified asset (a), data, exchange (exc), margin, and an optional minimum amount (min_amount). If no minimum amount is provided, it defaults to 1e-15.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.AssetInstance-Union{Tuple{M}, Tuple{E}, Tuple{A}, Tuple{A, Any, Exchange{E}, M}} where {A<:AbstractAsset, E<:ExchangeID, M<:Misc.MarginMode}","page":"Instances","title":"Instances.AssetInstance","text":"Create an AssetInstance object.\n\nAssetInstance(\n    a::AbstractAsset,\n    data,\n    e::Exchange{E<:ExchangeID},\n    margin::Misc.MarginMode;\n    limits,\n    precision,\n    fees\n)\n\n\nThis function constructs an AssetInstance with defined asset, data, exchange, margin, and optional parameters for limits, precision, and fees. It initializes long and short positions based on the provided margin and ensures that the margin is not hedged.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.AssetInstance-Union{Tuple{S}, NTuple{4, S}} where S<:AbstractString","page":"Instances","title":"Instances.AssetInstance","text":"Creates an AssetInstance from strings.\n\nAssetInstance(\n    s::AbstractString,\n    t::AbstractString,\n    e::AbstractString,\n    m::AbstractString;\n    sandbox\n)\n\n\nThis function creates an AssetInstance using the provided strings for the asset (s), data type (t), exchange (e), and margin type (m).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.CCash","page":"Instances","title":"Instances.CCash","text":"Defines a type for currency cash, which is parameterized by an exchange E and a symbol S.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.CrossInstance","page":"Instances","title":"Instances.CrossInstance","text":"A type alias representing an asset instance with cross margin.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.Fees","page":"Instances","title":"Instances.Fees","text":"Defines a NamedTuple structure for fees, including taker, maker, minimum, and maximum fees, each of which is a subtype of Real.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.HedgedInstance","page":"Instances","title":"Instances.HedgedInstance","text":"A type alias for an asset instance with either isolated or cross hedged margin.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.Limits","page":"Instances","title":"Instances.Limits","text":"Defines a NamedTuple structure for limits, including leverage, amount, price, and cost, each of which is a subtype of Real.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.LongPosition","page":"Instances","title":"Instances.LongPosition","text":"A constant representing a long position with margin in a specific exchange.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.MarginInstance","page":"Instances","title":"Instances.MarginInstance","text":"A type alias for an asset instance with either isolated or cross margin.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.NoMarginInstance","page":"Instances","title":"Instances.NoMarginInstance","text":"A type alias representing an asset instance with no margin.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.OneVec","page":"Instances","title":"Instances.OneVec","text":"A constant representing a vector of DFT type.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.Position","page":"Instances","title":"Instances.Position","text":"A position tracks the margin state of an asset instance.\n\nstatus: Current status of the position\nasset: Asset being tracked\ntimestamp: Timestamp of the last update\nliquidation_price: Asset liquidation price\nentryprice: Price at which the position was entered\nmaintenance_margin: Maintenance margin required for the position\ninitial_margin: Initial margin required for the position\nadditional_margin: Additional margin required for the position\nnotional: Notional value of the position\ncash: Cash value of the position\ncash_committed: Cash committed to the position\nleverage: Leverage applied to the position\nmin_size: Minimum size of the position\nhedged: Whether the position is hedged or not\ntiers: Leverage tiers applicable to the position\nthis_tier: Current tier applicable to the position\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.PositionClose","page":"Instances","title":"Instances.PositionClose","text":"A position has been closed.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.PositionOpen","page":"Instances","title":"Instances.PositionOpen","text":"A position has been opened.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.PositionUpdate","page":"Instances","title":"Instances.PositionUpdate","text":"A position has been updated.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.Precision","page":"Instances","title":"Instances.Precision","text":"Defines a NamedTuple structure for precision, including amount and price, each of which is a subtype of Real.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Instances.ShortPosition","page":"Instances","title":"Instances.ShortPosition","text":"A constant representing a short position with margin in a specific exchange.\n\n\n\n\n\n","category":"type"},{"location":"API/instances/#Base.float-Tuple{Instances.AssetInstance}","page":"Instances","title":"Base.float","text":"Get the cash value of a AssetInstance. \n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.isapprox-Tuple{Instances.AssetInstance, Any, Any, Val{:amount}}","page":"Instances","title":"Base.isapprox","text":"Check if two amounts are approximately equal for an AssetInstance.\n\nisapprox(\n    ai::Instances.AssetInstance,\n    v1,\n    v2,\n    ::Val{:amount};\n    atol\n) -> Any\n\n\nThis function checks if two specified amounts v1 and v2 are approximately equal for an AssetInstance. It's used to validate whether two amounts are similar considering small variations.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.isapprox-Tuple{Instances.AssetInstance, Any, Any, Val{:price}}","page":"Instances","title":"Base.isapprox","text":"Check if two prices are approximately equal for an AssetInstance.\n\nisapprox(\n    ai::Instances.AssetInstance,\n    v1,\n    v2,\n    ::Val{:price};\n    atol\n) -> Any\n\n\nThis function checks if two specified prices v1 and v2 are approximately equal for an AssetInstance. It's used to validate whether two prices are similar considering small variations.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.isopen-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}}","page":"Instances","title":"Base.isopen","text":"Check if the AssetInstance is open.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.isopen-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{S}, Instances.Position{S}, S}}} where S<:Misc.PositionSide","page":"Instances","title":"Base.isopen","text":"Check if an asset position is open.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.iszero-Tuple{Instances.AssetInstance, Any}","page":"Instances","title":"Base.iszero","text":"Check if the amount is below the asset instance's minimum limit.\n\niszero(ai::Instances.AssetInstance, v; atol) -> Any\n\n\nThis function checks if a specified amount in base currency is considered zero with respect to an AssetInstance's minimum limit. The amount is considered zero if it is less than the minimum limit minus a small epsilon value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.iszero-Tuple{Instances.AssetInstance, Misc.PositionSide}","page":"Instances","title":"Base.iszero","text":"Check if the asset cash for a position side is zero.\n\niszero(\n    ai::Instances.AssetInstance,\n    p::Misc.PositionSide\n) -> Any\n\n\nThis function checks if the cash value of an AssetInstance for a specific PositionSide is zero. This is used to determine if there are no funds in a certain position side (long or short).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.iszero-Tuple{Instances.AssetInstance}","page":"Instances","title":"Base.iszero","text":"Check if the asset cash is zero.\n\niszero(ai::Instances.AssetInstance) -> Any\n\n\nThis function checks if the cash value of an AssetInstance is zero. This is used to determine if there are no funds in the asset.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.position-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{Misc.Long}}","page":"Instances","title":"Base.position","text":"Asset instance long position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.position-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{Misc.Short}}","page":"Instances","title":"Base.position","text":"Asset instance short position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.position-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin}","page":"Instances","title":"Base.position","text":"Returns the last open asset position or nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.position-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Base.position","text":"Asset position by order.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Base.similar-Tuple{Instances.AssetInstance}","page":"Instances","title":"Base.similar","text":"Create a similar AssetInstance with cash and orders reset.\n\nsimilar(\n    ai::Instances.AssetInstance;\n    exc,\n    limits,\n    precision,\n    fees\n) -> Instances.AssetInstance\n\n\nThis function returns a similar AssetInstance to the one provided, but resets the cash and orders. The limits, precision, and fees can be specified, and will default to those of the original instance.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Data.candlelast-Tuple{Instances.AssetInstance, TimeFrames.TimeFrame, Dates.DateTime}","page":"Instances","title":"Data.candlelast","text":"Get the last available candle strictly lower than apply(tf, date).\n\ncandlelast(\n    ai::Instances.AssetInstance,\n    tf::TimeFrames.TimeFrame,\n    date::Dates.DateTime\n)\n\n\nThis function retrieves the last available candle (Open, High, Low, Close, Volume data for a specific time period) from the AssetInstance that is strictly lower than the date adjusted by the TimeFrame tf.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Data.stub!-Tuple{Instances.AssetInstance, DataFrames.DataFrame}","page":"Instances","title":"Data.stub!","text":"Stub data for an AssetInstance with a DataFrame.\n\nstub!(\n    ai::Instances.AssetInstance,\n    df::DataFrames.DataFrame\n) -> DataFrames.DataFrame\n\n\nThis function stabs data of an AssetInstance with a given DataFrame. It's used for testing or simulating scenarios with pre-defined data.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#ExchangeTypes.exchange-Tuple{Instances.AssetInstance}","page":"Instances","title":"ExchangeTypes.exchange","text":"The exchange of the asset instance.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#ExchangeTypes.exchangeid-Union{Tuple{Instances.AssetInstance{<:AbstractAsset, E}}, Tuple{E}} where E<:ExchangeID","page":"Instances","title":"ExchangeTypes.exchangeid","text":"ExchangeID for the asset instance.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Exchanges.lastprice-Tuple{Instances.AssetInstance, Val{:history}}","page":"Instances","title":"Exchanges.lastprice","text":"Get the last price from the history for an AssetInstance.\n\nlastprice(\n    ai::Instances.AssetInstance,\n    _::Val{:history}\n) -> Any\n\n\nThis function returns the last known price from the historical data for an AssetInstance. It's useful when you need to reference the most recent historical price for calculations or comparisons.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Exchanges.lastprice-Tuple{Instances.AssetInstance, Vararg{Any}}","page":"Instances","title":"Exchanges.lastprice","text":"Get the last price for an AssetInstance.\n\nlastprice(\n    ai::Instances.AssetInstance,\n    args...;\n    hist,\n    kwargs...\n) -> Any\n\n\nThis function returns the last known price for an AssetInstance. Additional arguments and keyword arguments can be provided to adjust the way the last price is calculated, if necessary.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Exchanges.leverage!-Tuple{Any, Any, Misc.PositionSide}","page":"Instances","title":"Exchanges.leverage!","text":"Update the leverage for an asset position.\n\nleverage!(ai, v, p::Misc.PositionSide)\n\n\nThis function updates the leverage for a position in an asset instance. Leverage is the use of various financial instruments or borrowed capital to increase the potential return of an investment. The function takes a leverage value v and a position side (Long or Short) as inputs.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Exchanges.leverage!-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.CrossMargin, Misc.PositionSide, Val{:max}}","page":"Instances","title":"Exchanges.leverage!","text":"Set the leverage to maximum for a CrossInstance.\n\nleverage!(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.CrossMargin,\n    p::Misc.PositionSide,\n    _::Val{:max}\n) -> Float64\n\n\nThis function sets the leverage for a CrossInstance to the maximum value for the current tier. Some exchanges interpret a leverage value of 0 as max leverage in cross margin mode. This means that the maximum amount of borrowed capital will be used to increase the potential return of the investment.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Exchanges.leverage!-Tuple{Instances.Position, Any}","page":"Instances","title":"Exchanges.leverage!","text":"Updates position leverage.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Exchanges.maxleverage-Tuple{Instances.Position, Real}","page":"Instances","title":"Exchanges.maxleverage","text":"Returns the maximum leverage for a given position and size.\n\nmaxleverage(po::Instances.Position, size::Real) -> Real\n\n\nThe function retrieves the leverage tier applicable to the provided position and size, and returns the maximum leverage allowed within that tier.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Exchanges.tier-Tuple{Instances.Position, Any}","page":"Instances","title":"Exchanges.tier","text":"Retrieves the leverage tier for a given position and size.\n\ntier(\n    po::Instances.Position,\n    size\n) -> Tuple{Union{Nothing, Int64}, Exchanges.LeverageTier}\n\n\nThis function returns the tier that applies to a position of the provided size.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Exchanges.tier-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Exchanges.tier","text":"Get the position tier for a MarginInstance.\n\ntier(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    size,\n    _::Union{Type{S<:Misc.PositionSide}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}, S<:Misc.PositionSide}\n) -> Tuple{Union{Nothing, Int64}, Exchanges.LeverageTier}\n\n\nThis function returns the tier of the position for a MarginInstance for a given size and position side (Long or Short). The tier indicates the level of risk or capital requirement for the position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances._roundpos","page":"Instances","title":"Instances._roundpos","text":"Round function for values of position fields.\n\n_roundpos(v) -> Any\n_roundpos(v, digits) -> Any\n\n\nThis function rounds the values of position fields to a specified precision. The default precision is POSITION_PRECISION.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.additional!","page":"Instances","title":"Instances.additional!","text":"Sets additional margin (should always be positive).\n\nadditional!(po::Instances.Position) -> Float64\nadditional!(po::Instances.Position, v) -> Any\n\n\nThis function sets the additional margin of a given position (po) to the provided value (v). If no value is provided, it defaults to 0.0.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.additional-Tuple{Instances.Position}","page":"Instances","title":"Instances.additional","text":"Position additional margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.additional-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.additional","text":"Asset position additional margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.addmargin!-Tuple{Instances.Position, Any}","page":"Instances","title":"Instances.addmargin!","text":"Adds margin to a position.\n\naddmargin!(po::Instances.Position, v) -> Any\n\n\nThis function adds a specified amount (v) to the margin of a given position (po).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.amount_with_fees-Tuple{Any, Any}","page":"Instances","title":"Instances.amount_with_fees","text":"The amount of a trade include fees (either positive or negative).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.asset-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instances.asset","text":"Get the parsed AbstractAsset of an AssetInstance. \n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.bankruptcy-Tuple{Real, Real}","page":"Instances","title":"Instances.bankruptcy","text":"The price where the position is fully liquidated.\n\nbankruptcy(price::Real, lev::Real) -> Any\n\n\nThis function calculates and returns the price at which a position, given its leverage (lev), would be fully liquidated.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.bankruptcy-Union{Tuple{P}, Tuple{Any, Any, Type{P}}} where P<:Misc.PositionSide","page":"Instances","title":"Instances.bankruptcy","text":"Get the bankruptcy price for an asset position.\n\nbankruptcy(ai, price, ps::Type{P<:Misc.PositionSide}) -> Any\n\n\nThis function calculates the bankruptcy price, which is the price at which the asset position would be fully liquidated. It takes into account the current price of the asset and the position side (Long or Short).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.collateral-Tuple{Instances.Position}","page":"Instances","title":"Instances.collateral","text":"Maximum value that can be lost by the position\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.committed-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}}","page":"Instances","title":"Instances.committed","text":"Get the asset instance committed cash.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.committed-Tuple{Instances.Position}","page":"Instances","title":"Instances.committed","text":"Position locked in pending orders.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.entryprice!","page":"Instances","title":"Instances.entryprice!","text":"Update the entry price.\n\nentryprice!(po::Instances.Position) -> Any\nentryprice!(po::Instances.Position, v) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.entryprice-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, OrderTypes.ByPos}","page":"Instances","title":"Instances.entryprice","text":"Asset entry price.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.initial!","page":"Instances","title":"Instances.initial!","text":"Sets initial margin (should always be positive).\n\ninitial!(po::Instances.Position) -> Float64\ninitial!(po::Instances.Position, v) -> Any\n\n\nThis function sets the initial margin of a given position (po) to the provided value (v). If no value is provided, it defaults to 0.0.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.instance","page":"Instances","title":"Instances.instance","text":"Create an AssetInstance from a zarr instance.\n\ninstance(\n    exc::Exchange,\n    a::AbstractAsset;\n    ...\n) -> Instances.AssetInstance{A, E, NoMargin} where {A<:AbstractAsset, E<:ExchangeID}\ninstance(\n    exc::Exchange,\n    a::AbstractAsset,\n    m::Misc.MarginMode;\n    zi\n) -> Instances.AssetInstance\n\n\nThis function constructs an AssetInstance by loading data from a zarr instance and requires an external constructor defined in Engine. The MarginMode can be specified, with NoMargin being the default.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.isdust-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Number, Misc.PositionSide}","page":"Instances","title":"Instances.isdust","text":"Check if the position value of the asset is below minimum quantity.\n\nisdust(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    price::Number,\n    p::Misc.PositionSide\n) -> Any\n\n\nThis function checks if the position value of a given AssetInstance at a specific price is below the minimum limit for that asset. The position side p determines if it's a long or short position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.ishedged-Tuple","page":"Instances","title":"Instances.ishedged","text":"Check if the margin mode is hedged.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.ishedged-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instances.ishedged","text":"Check if the AssetInstance is hedged.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.leverage-Tuple{Instances.Position}","page":"Instances","title":"Instances.leverage","text":"Position leverage.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.leverage-Union{Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin}, Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.leverage","text":"Asset position leverage.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice!-Tuple{Instances.Position{Misc.Long}, Any}","page":"Instances","title":"Instances.liqprice!","text":"Sets the liquidation price for a long position.\n\nliqprice!(po::Instances.Position{Misc.Long}, v) -> Any\n\n\nThis function sets the liquidation price of a given long position (po) to the provided value (v).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice!-Tuple{Instances.Position{Misc.Short}, Any}","page":"Instances","title":"Instances.liqprice!","text":"Sets the liquidation price for a short position.\n\nliqprice!(po::Instances.Position{Misc.Short}, v) -> Any\n\n\nThis function sets the liquidation price of a given short position (po) to the provided value (v).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice!-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.liqprice!","text":"Sets asset position liquidation price.\n\nliqprice!(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    v,\n    _::Union{Type{S<:Misc.PositionSide}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}, S<:Misc.PositionSide}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice-Tuple{Instances.Position}","page":"Instances","title":"Instances.liqprice","text":"Position liquidation price.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.liqprice-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.liqprice","text":"Asset position liquidation price.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.maintenance!-Tuple{Instances.Position, Any}","page":"Instances","title":"Instances.maintenance!","text":"Sets maintenance margin.\n\nmaintenance!(po::Instances.Position, v) -> Any\n\n\nThis function sets the maintenance margin of a given position (po) to the provided value (v).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.maintenance-Tuple{Instances.Position}","page":"Instances","title":"Instances.maintenance","text":"Position maintenance margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.maintenance-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.maintenance","text":"Asset position maintenance margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.makerfees-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instances.makerfees","text":"Maker fees for the asset instance (usually lower than taker fees.)\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.margin!-Tuple{Instances.Position}","page":"Instances","title":"Instances.margin!","text":"Sets initial margin given notional and leverage values.\n\nmargin!(po::Instances.Position; ntl, lev) -> Float64\n\n\nThis function sets the initial margin of a given position (po) based on the provided notional value (ntl) and leverage (lev). If no values are provided, the current notional value and leverage of the position are used.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.margin-Tuple{Instances.Position}","page":"Instances","title":"Instances.margin","text":"Position initial margin (includes additional).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.margin-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.margin","text":"Asset position initial margin.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.maxfees-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instances.maxfees","text":"The maximum fees for trading in the asset market (usually the lowest vip level.)\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.minfees-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instances.minfees","text":"The minimum fees for trading in the asset market (usually the highest vip level.)\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.mmr-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, OrderTypes.ByPos}","page":"Instances","title":"Instances.mmr","text":"Get the maintenance margin rate for a MarginInstance.\n\nmmr(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    size,\n    s::OrderTypes.ByPos\n)\n\n\nThis function returns the maintenance margin rate for a MarginInstance for a given size and position side (Long or Short). The maintenance margin rate is the minimum amount of equity that must be maintained in a margin account.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.mmr-Tuple{Instances.Position}","page":"Instances","title":"Instances.mmr","text":"Position maintenance margin rate.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.nondust","page":"Instances","title":"Instances.nondust","text":"Get the asset cash rounded to precision.\n\nnondust(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    price::Number\n) -> Any\nnondust(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    price::Number,\n    p\n) -> Any\n\n\nThis function returns the asset cash of a MarginInstance rounded according to the asset's precision. The position side p is determined by the posside function.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.notional!-Tuple{Instances.Position, Any}","page":"Instances","title":"Instances.notional!","text":"Update the notional value.\n\nnotional!(po::Instances.Position, v) -> Any\n\n\nThis function updates the notional value of a given position (po) to the provided value (v).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.notional-Tuple{Instances.Position}","page":"Instances","title":"Instances.notional","text":"Position notional value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.notional-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.notional","text":"Asset position notional value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.ohlcv-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instances.ohlcv","text":"Get the asset instance ohlcv data for the smallest time frame.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.ohlcv_dict-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instances.ohlcv_dict","text":"Get the asset instance ohlcv data dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.pnl","page":"Instances","title":"Instances.pnl","text":"Calc PNL for long position given current_price as input.\n\npnl(po::Instances.Position{Misc.Long}, current_price) -> Any\npnl(\n    po::Instances.Position{Misc.Long},\n    current_price,\n    amount\n) -> Any\n\n\nThis function calculates the Profit and Loss (PNL) for a long position (po), given the current price (current_price) and an optional amount (amount). If no amount is provided, the cash value of the position is used.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.pnl-2","page":"Instances","title":"Instances.pnl","text":"Calc PNL for short position given current_price as input.\n\npnl(\n    po::Instances.Position{Misc.Short},\n    current_price\n) -> Any\npnl(\n    po::Instances.Position{Misc.Short},\n    current_price,\n    amount\n) -> Any\n\n\nThis function calculates the Profit and Loss (PNL) for a short position (po), given the current price (current_price) and an optional amount (amount). If no amount is provided, the cash value of the position is used.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.pnl-Union{Tuple{P}, Tuple{Any, Union{Type{P}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, P}, Any}} where P","page":"Instances","title":"Instances.pnl","text":"Calculate the profit and loss (PnL) of an asset position.\n\npnl(\n    ai,\n    _::Union{Type{P}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, P},\n    price\n) -> Any\n\n\nThis function calculates the profit and loss (PnL) for an asset position. It takes into account the current price and the position. The PnL represents the gain or loss made on the position, based on the current price compared to the price at which the position was opened.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.pnl-Union{Tuple{T}, Tuple{T, T, Any, OrderTypes.ByPos{Misc.Long}}} where T","page":"Instances","title":"Instances.pnl","text":"Calculate PNL for a long position.\n\npnl(\n    entryprice,\n    current_price,\n    amount,\n    _::OrderTypes.ByPos{Misc.Long}\n) -> Any\n\n\nThis function calculates the Profit and Loss (PNL) for a long position, given the entry price (entryprice), the current price (current_price), and the amount.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.pnl-Union{Tuple{T}, Tuple{T, T, Any, OrderTypes.ByPos{Misc.Short}}} where T","page":"Instances","title":"Instances.pnl","text":"Calculate PNL for a short position.\n\npnl(\n    entryprice,\n    current_price,\n    amount,\n    _::OrderTypes.ByPos{Misc.Short}\n) -> Any\n\n\nThis function calculates the Profit and Loss (PNL) for a short position, given the entry price (entryprice), the current price (current_price), and the amount.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.pnlpct-Tuple{Instances.Position, Any}","page":"Instances","title":"Instances.pnlpct","text":"Calc PNL percentage.\n\npnlpct(po::Instances.Position, v) -> Float64\n\n\nThis function calculates the Profit and Loss (PNL) percentage for a given position (po) and value (v).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.pnlpct-Union{Tuple{P}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{P}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, P}, Any}} where P","page":"Instances","title":"Instances.pnlpct","text":"Calculate the profit and loss percentage (PnL%) of an asset position.\n\npnlpct(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    ::Union{Type{P}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, P},\n    price;\n    pos\n) -> Float64\n\n\nThis function calculates the profit and loss percentage (PnL%) for an asset position in a MarginInstance. It takes into account the current price and the position. The PnL% represents the gain or loss made on the position, as a percentage of the investment, based on the current price compared to the price at which the position was opened.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.positions-Tuple{Type{<:Misc.MarginMode}, AbstractAsset, NamedTuple{(:leverage, :amount, :price, :cost), <:NTuple{4, @NamedTuple{min::var\"#s254\", max::var\"#s254\"} where var\"#s254\"<:T}} where T<:Real, Exchange}","page":"Instances","title":"Instances.positions","text":"Generate positions for a specific margin mode.\n\npositions(\n    M::Type{<:Misc.MarginMode},\n    a::AbstractAsset,\n    limits::NamedTuple{(:leverage, :amount, :price, :cost), <:NTuple{4, @NamedTuple{min::var\"#s254\", max::var\"#s254\"} where var\"#s254\"<:T}} where T<:Real,\n    e::Exchange\n) -> Union{Tuple{Nothing, Nothing}, Tuple{Instances.Position{Misc.Long}, Instances.Position{Misc.Short}}}\n\n\nThis function generates long and short positions for a given asset on a specific exchange. The number and size of the positions are determined by the limits argument and the margin mode M.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.posside-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin}","page":"Instances","title":"Instances.posside","text":"Get the position side of an AssetInstance. \n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.price-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, Any, Vararg{Any}}","page":"Instances","title":"Instances.price","text":"Asset entry price.\n\nprice(\n    _::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin},\n    fromprice,\n    args...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.price-Tuple{Instances.Position}","page":"Instances","title":"Instances.price","text":"Position entryprice.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.price-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.price","text":"Asset entry price.\n\nprice(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    fromprice,\n    _::Union{Type{S<:Misc.PositionSide}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, S<:Misc.PositionSide}, S<:Misc.PositionSide}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.status!-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Misc.PositionSide, Instances.PositionStatus}","page":"Instances","title":"Instances.status!","text":"Update the status of a non-hedged position in a MarginInstance.\n\nstatus!(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    p::Misc.PositionSide,\n    pstat::Instances.PositionStatus\n) -> Any\n\n\nThis function opens or closes the status of a non-hedged position in a MarginInstance. A non-hedged position is a position that is not offset by a corresponding position in a related commodity or security. The PositionSide and PositionStatus are provided as inputs.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.status!-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Union{Misc.CrossMargin{Misc.Hedged}, Misc.IsolatedMargin{Misc.Hedged}}, Misc.PositionSide, Instances.PositionStatus}","page":"Instances","title":"Instances.status!","text":"Update the status of a hedged position in a HedgedInstance.\n\nstatus!(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Union{Misc.CrossMargin{Misc.Hedged}, Misc.IsolatedMargin{Misc.Hedged}},\n    p::Misc.PositionSide,\n    pstat::Instances.PositionStatus\n) -> Any\n\n\nThis function opens or closes the status of a hedged position in a HedgedInstance. A hedged position is a position that is offset by a corresponding position in a related commodity or security. The PositionSide and PositionStatus are provided as inputs.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.status-Tuple{Instances.Position}","page":"Instances","title":"Instances.status","text":"Position status (open or closed).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.status-Union{Tuple{S}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{S}}} where S<:Misc.PositionSide","page":"Instances","title":"Instances.status","text":"Asset position status (open or closed).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.takerfees-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instances.takerfees","text":"Taker fees for the asset instance (usually higher than maker fees.)\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.tier!","page":"Instances","title":"Instances.tier!","text":"Updates position leverage tier according to size.\n\ntier!(po::Instances.Position) -> Exchanges.LeverageTier\ntier!(\n    po::Instances.Position,\n    size\n) -> Exchanges.LeverageTier\n\n\nThis function adjusts the leverage tier of a given position (po) based on the provided size. If no size is provided, the notional value of the position is used.\n\n\n\n\n\n","category":"function"},{"location":"API/instances/#Instances.timestamp!-Tuple{Instances.Position, Dates.DateTime}","page":"Instances","title":"Instances.timestamp!","text":"Updates the timestamp of a position.\n\ntimestamp!(\n    po::Instances.Position,\n    d::Dates.DateTime\n) -> Dates.DateTime\n\n\nThis function sets the timestamp of a given position (po) to the provided DateTime value (d).\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.timestamp-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}}","page":"Instances","title":"Instances.timestamp","text":"Get the timestamp of the last trade.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.timestamp-Tuple{Instances.Position}","page":"Instances","title":"Instances.timestamp","text":"Last position update time\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.bc-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instruments.bc","text":"Get the base currency of an AssetInstance. \n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.cash!-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.IncreaseTrade}","page":"Instances","title":"Instruments.cash!","text":"Update the cash value for a MarginInstance after an IncreaseTrade.\n\ncash!(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    t::OrderTypes.IncreaseTrade\n) -> Any\n\n\nThis function updates the cash value of a MarginInstance after an IncreaseTrade. The cash value would typically decrease after an increase trade, as assets are bought using cash.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.cash!-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ReduceTrade}","page":"Instances","title":"Instruments.cash!","text":"Update the cash value for a MarginInstance after a ReduceTrade.\n\ncash!(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    t::OrderTypes.ReduceTrade\n) -> Any\n\n\nThis function updates the cash value of a MarginInstance after a ReduceTrade. The cash value would typically increase after a reduce trade, as assets are sold in exchange for cash.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.cash!-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, OrderTypes.SellTrade}","page":"Instances","title":"Instruments.cash!","text":"Update the cash value for a NoMarginInstance after a SellTrade.\n\ncash!(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin},\n    t::OrderTypes.SellTrade\n) -> Any\n\n\nThis function updates the cash value of a NoMarginInstance after a SellTrade. The cash value would typically increase after a sell trade, as assets are sold in exchange for cash.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.cash!-Tuple{Instances.Position, Any}","page":"Instances","title":"Instruments.cash!","text":"Set position cash value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.cash-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, OrderTypes.ByPos{Misc.Long}}","page":"Instances","title":"Instruments.cash","text":"Get the asset instance cash for the long position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.cash-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, OrderTypes.ByPos{Misc.Short}}","page":"Instances","title":"Instruments.cash","text":"Get the asset instance cash for the short position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.cash-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}}","page":"Instances","title":"Instruments.cash","text":"Get the asset instance cash.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.cash-Tuple{Instances.Position}","page":"Instances","title":"Instruments.cash","text":"Held position.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.freecash-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{Misc.Long}}","page":"Instances","title":"Instruments.freecash","text":"Calculate the free cash for a MarginInstance with long position.\n\nfreecash(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    p::OrderTypes.ByPos{Misc.Long}\n) -> Any\n\n\nThis function calculates the free cash (cash that is not tied up in trades) of a MarginInstance that has a long position. It takes into account the current cash, open long positions, and the margin requirements for those positions.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.freecash-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.ByPos{Misc.Short}}","page":"Instances","title":"Instruments.freecash","text":"Calculate the free cash for a MarginInstance with short position.\n\nfreecash(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    p::OrderTypes.ByPos{Misc.Short}\n) -> Any\n\n\nThis function calculates the free cash (cash that is not tied up in trades) of a MarginInstance that has a short position. It takes into account the current cash, open short positions, and the margin requirements for those positions.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.freecash-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, Vararg{Any}}","page":"Instances","title":"Instruments.freecash","text":"Calculate the free cash for a NoMarginInstance.\n\nfreecash(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin},\n    args...\n) -> Any\n\n\nThis function calculates the free cash (cash that is not tied up in trades) of a NoMarginInstance. It takes into account the current cash, open orders, and any additional factors specified in args.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.qc-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instruments.qc","text":"Get the quote currency of an AssetInstance. \n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.raw-Tuple{Instances.AssetInstance}","page":"Instances","title":"Instruments.raw","text":"Get the raw string id of an AssetInstance. \n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.value-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}}","page":"Instances","title":"Instruments.value","text":"Calculate the value of a NoMarginInstance.\n\nvalue(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin};\n    current_price,\n    fees\n) -> Any\n\n\nThis function calculates the value of a NoMarginInstance. It uses the current price (defaulting to the last historical price), the cash in the instance and the maximum fees. The value represents the amount of cash that could be obtained by liquidating the instance at the current price, taking into account the fees.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instruments.value-Union{Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin}, Tuple{P}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{P}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, P}}} where P","page":"Instances","title":"Instruments.value","text":"Calculate the value of a MarginInstance.\n\nvalue(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin;\n    ...\n) -> Any\nvalue(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    ::Union{Type{P}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, P};\n    current_price,\n    fees\n) -> Any\n\n\nThis function calculates the value of a MarginInstance. It takes into account the current price (defaulting to the price of the position), the cash in the position and the maximum fees. The value represents the amount of cash that could be obtained by liquidating the position at the current price, taking into account the fees.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.gtxzero-Tuple{Instances.AssetInstance, Any, Val{:amount}}","page":"Instances","title":"Misc.gtxzero","text":"Check if an amount is greater than zero for an AssetInstance.\n\ngtxzero(\n    ai::Instances.AssetInstance,\n    v,\n    _::Val{:amount}\n) -> Any\n\n\nThis function checks if a specified amount v is greater than zero for an AssetInstance. It's used to validate the amount before performing operations on the asset.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.gtxzero-Tuple{Instances.AssetInstance, Any, Val{:cost}}","page":"Instances","title":"Misc.gtxzero","text":"Check if a cost is greater than zero for an AssetInstance.\n\ngtxzero(\n    ai::Instances.AssetInstance,\n    v,\n    _::Val{:cost}\n) -> Any\n\n\nThis function checks if a specified cost v is greater than zero for an AssetInstance. The cost is considered greater than zero if it is above the minimum limit minus a small epsilon value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.gtxzero-Tuple{Instances.AssetInstance, Any, Val{:price}}","page":"Instances","title":"Misc.gtxzero","text":"Check if a price is greater than zero for an AssetInstance.\n\ngtxzero(\n    ai::Instances.AssetInstance,\n    v,\n    _::Val{:price}\n) -> Any\n\n\nThis function checks if a specified price v is greater than zero for an AssetInstance. The price is considered greater than zero if it is above the minimum limit minus a small epsilon value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.load!-Tuple{Instances.AssetInstance}","page":"Instances","title":"Misc.load!","text":"Load OHLCV data for an AssetInstance.\n\nload!(a::Instances.AssetInstance; reset, zi)\n\n\nThis function loads OHLCV (Open, High, Low, Close, Volume) data for a given AssetInstance. If reset is set to true, it will re-fetch the data even if it's already been loaded.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.ltxzero-Tuple{Instances.AssetInstance, Any, Val{:amount}}","page":"Instances","title":"Misc.ltxzero","text":"Check if an amount is less than zero for an AssetInstance.\n\nltxzero(\n    ai::Instances.AssetInstance,\n    v,\n    _::Val{:amount}\n) -> Any\n\n\nThis function checks if a specified amount v is less than zero for an AssetInstance. It's used to validate the amount before performing operations on the asset.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.ltxzero-Tuple{Instances.AssetInstance, Any, Val{:cost}}","page":"Instances","title":"Misc.ltxzero","text":"Check if a cost is less than zero for an AssetInstance.\n\nltxzero(\n    ai::Instances.AssetInstance,\n    v,\n    _::Val{:cost}\n) -> Any\n\n\nThis function checks if a specified cost v is less than zero for an AssetInstance. The cost is considered less than zero if it is below the minimum limit minus a small epsilon value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.ltxzero-Tuple{Instances.AssetInstance, Any, Val{:price}}","page":"Instances","title":"Misc.ltxzero","text":"Check if a price is less than zero for an AssetInstance.\n\nltxzero(\n    ai::Instances.AssetInstance,\n    v,\n    _::Val{:price}\n) -> Any\n\n\nThis function checks if a specified price v is less than zero for an AssetInstance. The price is considered less than zero if it is below the minimum limit minus a small epsilon value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.marginmode-Union{Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M}}, Tuple{M}} where M<:Misc.WithMargin","page":"Instances","title":"Misc.marginmode","text":"Retrieve the margin mode of an AssetInstance. \n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.opposite-Union{Tuple{P}, Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Instances.Position{P}, P}}} where P","page":"Instances","title":"Misc.opposite","text":"The opposite position w.r.t. the asset instance and another Position or PositionSide.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.reset!-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Vararg{Any}}","page":"Instances","title":"Misc.reset!","text":"Resets asset positions for a MarginInstance.\n\nreset!(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    args...\n) -> Any\n\n\nThis function resets the positions (open trades) of a MarginInstance to initial values. Any additional arguments in args are used to adjust the reset process, if necessary.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.reset!-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, Vararg{Any}}","page":"Instances","title":"Misc.reset!","text":"Resets asset cash and commitments for a NoMarginInstance.\n\nreset!(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin},\n    args...\n)\n\n\nThis function resets the cash and commitments (open trades) of a NoMarginInstance to initial values. Any additional arguments in args are used to adjust the reset process, if necessary.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.reset!-Tuple{Instances.Position, Val{:full}}","page":"Instances","title":"Misc.reset!","text":"Resets position to initial state.\n\nwarning: Also resets leverage\n\n\nWhen reopening a position, leverage should be set again.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Misc.reset!-Tuple{Instances.Position}","page":"Instances","title":"Misc.reset!","text":"Resets the bare fields to close a position.\n\nreset!(po::Instances.Position) -> Cash{S1, Float64} where S1\n\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#OrderTypes.commit!-Tuple{Instances.Position, Any}","page":"Instances","title":"OrderTypes.commit!","text":"Set position committed cash value.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#OrderTypes.islong-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}}","page":"Instances","title":"OrderTypes.islong","text":"Check if the AssetInstance is long.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#OrderTypes.isshort-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}}","page":"Instances","title":"OrderTypes.isshort","text":"Check if the AssetInstance is short.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#OrderTypes.trades-Tuple{Instances.AssetInstance}","page":"Instances","title":"OrderTypes.trades","text":"Get the trade history of an AssetInstance.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#TimeTicks.timeframe-Tuple{Instances.AssetInstance}","page":"Instances","title":"TimeTicks.timeframe","text":"Get the timeframe for an AssetInstance.\n\ntimeframe(\n    ai::Instances.AssetInstance\n) -> TimeFrames.TimeFrame\n\n\nThis function returns the timeframe for an AssetInstance. The timeframe represents the interval at which the asset's price data is sampled or updated.\n\n\n\n\n\n","category":"method"},{"location":"API/instances/#Instances.@_round","page":"Instances","title":"Instances.@_round","text":"Round a value based on the precision field of the ai asset instance.\n\nThis macro rounds a value v based on the precision field of an AssetInstance. By default, it rounds the amount, but it can also round other fields like price or cost if specified.\n\n\n\n\n\n","category":"macro"},{"location":"API/instances/#Instances.@ramount-Tuple{Any}","page":"Instances","title":"Instances.@ramount","text":"Round a value based on the precision (amount) field of the ai asset instance.\n\nThis macro rounds an amount value v based on the precision field of an AssetInstance.\n\n\n\n\n\n","category":"macro"},{"location":"API/instances/#Instances.@rprice-Tuple{Any}","page":"Instances","title":"Instances.@rprice","text":"Round a value based on the precision (price) field of the ai asset instance.\n\nThis macro rounds a price value v based on the precision field of an AssetInstance.\n\n\n\n\n\n","category":"macro"},{"location":"devdocs/#PingPongDev-Documentation","page":"Devdocs","title":"PingPongDev Documentation","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"The PingPongDev package assists developers by providing helper functions for working with PingPong and for conducting tests.","category":"page"},{"location":"devdocs/#Precompilation-Control","page":"Devdocs","title":"Precompilation Control","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"To skip precompilation for selected modules, set the JULIA_NOPRECOMP environment variable:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"ENV[\"JULIA_NOPRECOMP\"] = (:PingPong, :Scrapers, :Engine, :Watchers, :Plotting, :Stats)","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Alternatively, you can manage environment variables with direnv (refer to the .envrc in the repository). To disable precompilation entirely for certain packages, use JULIA_NOPRECOMP=all. This is recommended only when altering low-level components of the module stack. Remember to clear the compilation cache when changing precompilation settings:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"include(\"resolve.jl\")\npurge_compilecache() # Pass a package name as an argument to clear its specific cache.","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"The Exchanges and Fetch packages contain a compile.jl file to generate precompile statements using CompileBot.jl. This is particularly useful for precompilation tasks that involve numerous web requests. However, this method is not currently used as it does not compile as many methods as PrecompileTools.","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"warning: Custom Precompilation\nFor custom method precompilation, enclose your code with py_start_loop and py_stop_loop from the Python package to prevent Pkg from stalling due to lingering threads.using PrecompileTools\nPython.py_stop_loop() # Stop the Python loop if it's running\nPython.py_start_loop()\n@precompile_workload $(myworkload...)\nPython.py_stop_loop()","category":"page"},{"location":"devdocs/#Method-Invalidation-Strategy","page":"Devdocs","title":"Method Invalidation Strategy","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"The order of using ... statements when loading modules can influence method invalidation. To minimize invalidation, arrange the module imports starting with the ones most likely to cause invalidations to the ones least likely. For instance, placing using Python at the beginning can expedite loading times:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"# Load modules that heavily trigger invalidations first\nusing Python\nusing Ccxt\n# Load less impactful modules later\nusing Timeticks\nusing Lang","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Modules known for heavy invalidations:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Python\nCcxt (initiates the Python async loop)\nData (relies on Zarr and DataFrames)\nPlots (depends on Makie)","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"To reduce invalidations, include external modules in only one local package and then use that package as a dependency in other local packages. For instance, if DataFrames is a dependency of the local package Data, and you want to use DataFrames in the Stats package, do not add DataFrames to Stats dependencies. Instead, use Data and import DataFrames from there:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"module Stats\n\nusing Data.DataFrames\n\n# ...\nend","category":"page"},{"location":"devdocs/#Handling-Segfaults","page":"Devdocs","title":"Handling Segfaults","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"In rare cases involving complex multi-threaded scenarios, disable and re-enable the garbage collector (GC) around the loading of PingPong to avoid segmentation faults:","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"GC.enable(false)\nusing PingPong\ns = st.strategy()\nGC.enable(true)\nGC.gc()","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"Refer to https://github.com/cjdoris/PythonCall.jl/issues/201 for more details.","category":"page"},{"location":"devdocs/#Dependency-Management","page":"Devdocs","title":"Dependency Management","text":"","category":"section"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"When adding dependencies, ensure that a dependency is only included in one subpackage. If you need the same dependency in another subpackage, add the first subpackage as the dependency, not the external module.","category":"page"},{"location":"devdocs/","page":"Devdocs","title":"Devdocs","text":"The order of using or import statements within packages is crucial. Always import ```","category":"page"},{"location":"API/ccxt/#Ccxt","page":"Ccxt","title":"Ccxt","text":"","category":"section"},{"location":"API/ccxt/","page":"Ccxt","title":"Ccxt","text":"The Ccxt module handles the (python) ccxt library. Wraps the ccxt api.","category":"page"},{"location":"API/ccxt/","page":"Ccxt","title":"Ccxt","text":"Modules = [Ccxt]","category":"page"},{"location":"API/ccxt/#Ccxt.MARKETS_PATH","page":"Ccxt","title":"Ccxt.MARKETS_PATH","text":"The path to the markets data directory.\n\n\n\n\n\n","category":"constant"},{"location":"API/ccxt/#Ccxt.ccxt","page":"Ccxt","title":"Ccxt.ccxt","text":"The ccxt python module reference\n\n\n\n\n\n","category":"constant"},{"location":"API/ccxt/#Ccxt.ccxt_errors","page":"Ccxt","title":"Ccxt.ccxt_errors","text":"Ccxt exception names\n\n\n\n\n\n","category":"constant"},{"location":"API/ccxt/#Ccxt.ccxt_ws","page":"Ccxt","title":"Ccxt.ccxt_ws","text":"The ccxt.pro (websockets) python module reference\n\n\n\n\n\n","category":"constant"},{"location":"API/ccxt/#Ccxt._ccxt_errors!-Tuple{}","page":"Ccxt","title":"Ccxt._ccxt_errors!","text":"Populates the ccxt_errors array with error names from the ccxt library.\n\n_ccxt_errors!()\n\n\nThis function checks if the ccxt_errors array is empty. If it is, it imports the ccxt.base.errors module from the ccxt library, retrieves the directory of the module, and iterates over each error. It then checks if the first character of the error name is uppercase. If it is, the error name is added to the ccxt_errors array.\n\n\n\n\n\n","category":"method"},{"location":"API/ccxt/#Ccxt._init-Tuple{}","page":"Ccxt","title":"Ccxt._init","text":"Initializes the Python environment and creates the markets data directory.\n\n_init() -> Union{Nothing, Bool}\n\n\n\n\n\n\n","category":"method"},{"location":"API/ccxt/#Ccxt._issupported-Tuple{Py, Any}","page":"Ccxt","title":"Ccxt._issupported","text":"Check if the key k is in the dictionary has and return its boolean value.\n\n\n\n\n\n","category":"method"},{"location":"API/ccxt/#Ccxt._multifunc","page":"Ccxt","title":"Ccxt._multifunc","text":"Choose correct ccxt function according to what the exchange supports.\n\n\n\n\n\n","category":"function"},{"location":"API/ccxt/#Ccxt._out_as_input-Tuple{Any, Any}","page":"Ccxt","title":"Ccxt._out_as_input","text":"A dictionary for storing function wrappers with their unique identifiers.\n\n\n\n\n\n","category":"method"},{"location":"API/ccxt/#Ccxt.ccxt_exchange","page":"Ccxt","title":"Ccxt.ccxt_exchange","text":"Instantiate a CCXT exchange.\n\nccxt_exchange(name::Symbol; ...) -> Py\nccxt_exchange(name::Symbol, params; kwargs...) -> Py\n\n\nThis function creates an instance of a CCXT exchange. It checks if the exchange is available in the WebSocket (ws) module, otherwise it looks in the asynchronous (async) module. If optional parameters are provided, they are passed to the exchange constructor.\n\n\n\n\n\n","category":"function"},{"location":"API/ccxt/#Ccxt.choosefunc-Tuple{Any, Any, AbstractVector}","page":"Ccxt","title":"Ccxt.choosefunc","text":"Chooses a function based on the provided parameters and executes it.\n\nchoosefunc(\n    exc,\n    suffix,\n    inputs::AbstractVector;\n    elkey,\n    kwargs...\n) -> Any\n\n\nThis function selects a function based on the provided exception, suffix, and inputs. It then executes the chosen function with the provided inputs and keyword arguments. The function can handle multiple types of inputs and can execute multiple functions concurrently if necessary.\n\n\n\n\n\n","category":"method"},{"location":"API/ccxt/#Ccxt.isccxterror-Tuple{PyException}","page":"Ccxt","title":"Ccxt.isccxterror","text":"Determines if a Python exception is a ccxt error.\n\nisccxterror(err::PyException) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/ccxt/#Ccxt.isinitialized-Tuple{}","page":"Ccxt","title":"Ccxt.isinitialized","text":"Checks if the ccxt object is initialized.\n\nisinitialized() -> Bool\n\n\nThis function checks if the global variable ccxt is initialized by checking if it's not nothing and not null in the Python context.\n\n\n\n\n\n","category":"method"},{"location":"API/ccxt/#Ccxt.issupported-Tuple{Any, Any}","page":"Ccxt","title":"Ccxt.issupported","text":"Check if the key k is supported in the exc.py.has dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/ccxt/#Ccxt.upgrade-Tuple{}","page":"Ccxt","title":"Ccxt.upgrade","text":"Upgrades the ccxt library to the latest version.\n\nupgrade() -> Py\n\n\nThis function upgrades the ccxt library to the latest version available. It checks the current version of the ccxt library, and if a newer version is available, it upgrades the library using pip.\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#DataFrame-utils","page":"DataFrame utils","title":"DataFrame utils","text":"","category":"section"},{"location":"API/dfutils/","page":"DataFrame utils","title":"DataFrame utils","text":"Modules = [PingPong.Data.DFUtils]","category":"page"},{"location":"API/dfutils/#Data.DFUtils","page":"DataFrame utils","title":"Data.DFUtils","text":"Utilities for DataFrames.jl, prominently timeframe based indexing.\n\n\n\n\n\n","category":"module"},{"location":"API/dfutils/#Data.DFUtils._mutatemax!-NTuple{5, Any}","page":"DataFrame utils","title":"Data.DFUtils._mutatemax!","text":"Mutates v to df ensuring the dataframe never grows larger than maxlen.\n\n_mutatemax!(df, v, maxlen, n, mut; cols)\n\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.addcols!-Tuple{Any, Any}","page":"DataFrame utils","title":"Data.DFUtils.addcols!","text":"Inserts rows in src to dst, zeroing columns not present in dst.\n\naddcols!(dst, src)\n\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.appendmax!-Tuple{Any, Any, Any}","page":"DataFrame utils","title":"Data.DFUtils.appendmax!","text":"See _mutatemax!\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.colnames-Tuple{DataFrames.AbstractDataFrame}","page":"DataFrame utils","title":"Data.DFUtils.colnames","text":"Get the column names for dataframe as symbols.\n\ncolnames(df::DataFrames.AbstractDataFrame) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.copysubs!-Union{Tuple{D}, Tuple{D, Any}, Tuple{D, Any, Any}} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"Data.DFUtils.copysubs!","text":"Replaces subarrays with arrays.\n\ncopysubs!(df::DataFrames.AbstractDataFrame) -> Any\ncopysubs!(df::DataFrames.AbstractDataFrame, copyfunc) -> Any\ncopysubs!(\n    df::DataFrames.AbstractDataFrame,\n    copyfunc,\n    elsefunc\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.dateindex-Tuple{DataFrames.AbstractDataFrame, Dates.DateTime, Val{:nonzero}}","page":"DataFrame utils","title":"Data.DFUtils.dateindex","text":"Same dateindex(::AbstractDataFrame, ::DateTime) but always returns the first index if the index is not found in the vector.\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.dateindex-Union{Tuple{D}, Tuple{D, Dates.DateTime, Val{:timeframe}}} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"Data.DFUtils.dateindex","text":"Get the position of date in the :timestamp column of the dataframe based on timeframe arithmentics.\n\ndateindex(\n    df::DataFrames.AbstractDataFrame,\n    date::Dates.DateTime,\n    _::Val{:timeframe}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.dateindex-Union{Tuple{D}, Tuple{D, Dates.DateTime}} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"Data.DFUtils.dateindex","text":"Get the position of date in the :timestamp column of the dataframe.\n\ndateindex(\n    df::DataFrames.AbstractDataFrame,\n    date::Dates.DateTime\n) -> Union{Int64, DataStructures.Tokens.IntSemiToken}\n\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.dateindex-Union{Tuple{V}, Tuple{V, Dates.DateTime, Val{:nonzero}}} where V<:(AbstractVector)","page":"DataFrame utils","title":"Data.DFUtils.dateindex","text":"Same dateindex(::AbstractVector, ::DateTime) but always returns the first index if the index is not found in the vector.\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.dateindex-Union{Tuple{V}, Tuple{V, Dates.DateTime}} where V<:(AbstractVector)","page":"DataFrame utils","title":"Data.DFUtils.dateindex","text":"Same as dateindex\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.daterange-Union{Tuple{D}, Tuple{D, Any}, Tuple{D, Any, Any}} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"Data.DFUtils.daterange","text":"Get the date range of a DataFrame.\n\ndaterange(\n    df::DataFrames.AbstractDataFrame\n) -> TimeTicks.DateRange\ndaterange(\n    df::DataFrames.AbstractDataFrame,\n    tf\n) -> TimeTicks.DateRange\ndaterange(\n    df::DataFrames.AbstractDataFrame,\n    tf,\n    rightofs\n) -> TimeTicks.DateRange\n\n\nUsed to get the date range of a DataFrame df. It takes in the DataFrame df, an optional timeframe tf (default is the current timeframe of the DataFrame), and an optional rightofs parameter. The rightofs parameter specifies the number of steps to shift the date range to the right. For example, if rightofs is set to 1, the date range will be shifted one step to the right. This can be useful for calculating future date ranges based on the current date range. Returns the date range of the DataFrame df based on the specified timeframe tf and rightofs parameter.\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.firstdate-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"Data.DFUtils.firstdate","text":"Get the first timestamp in the dataframe (:timestamp column).\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.getdate-Union{Tuple{D}, Tuple{D, Union{TimeTicks.DateRange, StepRange{Dates.DateTime, <:Dates.Period}}, Any}, Tuple{D, Union{TimeTicks.DateRange, StepRange{Dates.DateTime, <:Dates.Period}}, Any, Any}} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"Data.DFUtils.getdate","text":"Get the date-based subset of a DataFrame.\n\ngetdate(\n    df::DataFrames.AbstractDataFrame,\n    dr::Union{TimeTicks.DateRange, StepRange{Dates.DateTime, <:Dates.Period}},\n    cols\n) -> Any\ngetdate(\n    df::DataFrames.AbstractDataFrame,\n    dr::Union{TimeTicks.DateRange, StepRange{Dates.DateTime, <:Dates.Period}},\n    cols,\n    tf\n) -> Any\n\n\nIndexing by date ranges allows to query ohlcv using the timestamp column as index, assuming that the data has no missing values and is already sorted.\n\nExamples: df[dtr\"1999-..\"] # Starting from 1999 up to the end df[dtr\"..1999-\"] # From the beginning up to 1999 df[dtr\"1999-..2000-\"] # The Year 1999\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.getdate-Union{Tuple{T}, Tuple{D}, Tuple{D, Dates.DateTime, Any}, Tuple{D, Dates.DateTime, Any, T}} where {D<:DataFrames.AbstractDataFrame, T<:TimeFrames.TimeFrame}","page":"DataFrame utils","title":"Data.DFUtils.getdate","text":"Get the specified columns based on given date (used as index).\n\ngetdate(\n    df::DataFrames.AbstractDataFrame,\n    idx::Dates.DateTime,\n    cols\n) -> Any\ngetdate(\n    df::DataFrames.AbstractDataFrame,\n    idx::Dates.DateTime,\n    cols,\n    tf::TimeFrames.TimeFrame\n) -> Any\n\n\nWhile indexing ohlcv data we have to consider the time of arrival of a candle. In general candles collect the price up to its timestamp. E.g. the candle at time 2000-01-01 would have tracked time from 1999-12-31T00:00:00 to 2000-01-01T00:00:00. Therefore what we return is always the left adjacent timestamp of the queried one.\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.lastdate-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"Data.DFUtils.lastdate","text":"Get the last timestamp in the dataframe (:timestamp column).\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.prependmax!-Tuple{Any, Any, Any}","page":"DataFrame utils","title":"Data.DFUtils.prependmax!","text":"See _mutatemax!\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.pushmax!-Tuple{Any, Any, Any}","page":"DataFrame utils","title":"Data.DFUtils.pushmax!","text":"See _mutatemax!\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.setcols!","page":"DataFrame utils","title":"Data.DFUtils.setcols!","text":"Set the values of specific columns in one DataFrame from another DataFrame.\n\nsetcols!(dst, src, cols)\nsetcols!(dst, src, cols, idx)\n\n\nUsed to set the values of specific columns in one DataFrame dst from another DataFrame src. It takes in the destination DataFrame dst, the source DataFrame src, the columns to set cols, and optional indices idx to specify the rows to set. The cols parameter specifies the columns in the destination DataFrame dst that will be set with the corresponding values from the source DataFrame src. The idx parameter specifies the indices of the rows in the destination DataFrame dst that will be set. By default, it sets all rows. It mutates the destination DataFrame dst by setting the values of the specified columns cols with the corresponding values from the source DataFrame src.\n\n\n\n\n\n","category":"function"},{"location":"API/dfutils/#Data.DFUtils.timeframe!!-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"Data.DFUtils.timeframe!!","text":"Forcefully infers the dataframe timeframe. See timeframe!(::DataFrame)\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.viewfrom-Tuple{Any, Integer}","page":"DataFrame utils","title":"Data.DFUtils.viewfrom","text":"Create a view of an OHLCV DataFrame starting from a specific index.\n\nviewfrom(ohlcv, from::Integer; offset, cols) -> Any\n\n\nUsed to create a view of an OHLCV DataFrame ohlcv starting from a specific index from. It takes in the OHLCV DataFrame ohlcv, the starting index from as an integer, and optional parameters offset and cols. The offset parameter specifies the number of rows to offset the view from the starting index. The default value is 0, indicating no offset. The cols parameter specifies the columns to include in the view. By default, all columns are included. Returns a view of the original OHLCV DataFrame ohlcv starting from the specified index from, with an optional offset and specified columns.\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Data.DFUtils.zerorow-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"Data.DFUtils.zerorow","text":"The zeroed row of a dataframe (zero(el) from every column).\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#Misc.after","page":"DataFrame utils","title":"Misc.after","text":"Get the subset of a DataFrame containing rows after a specific date.\n\nafter(\n    df::DataFrames.DataFrame,\n    dt::Dates.DateTime\n) -> DataFrames.SubDataFrame{DataFrames.DataFrame, DataFrames.Index, UnitRange{Int64}}\nafter(\n    df::DataFrames.DataFrame,\n    dt::Dates.DateTime,\n    cols\n) -> Any\n\n\nThis function is used to get the subset of a DataFrame df that contains rows after a specific date dt. It takes in the DataFrame df, the specific date dt as a DateTime object, and optional columns cols to include in the subset. If cols is not specified, the function includes all columns in the subset. If cols is specified, only the columns listed in cols will be included in the subset. This function returns a DataFrameView that contains only the rows of df that occur after the specified date dt and the specified columns cols.\n\n\n\n\n\n","category":"function"},{"location":"API/dfutils/#Misc.before","page":"DataFrame utils","title":"Misc.before","text":"Complement of after\n\n\n\n\n\n","category":"function"},{"location":"API/dfutils/#TimeTicks.timeframe!-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"TimeTicks.timeframe!","text":"Infer the dataframe's timeframe from the timestamp column of the dataframe and sets it.\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#TimeTicks.timeframe!-Union{Tuple{T}, Tuple{D}, Tuple{D, T}} where {D<:DataFrames.AbstractDataFrame, T<:TimeFrames.TimeFrame}","page":"DataFrame utils","title":"TimeTicks.timeframe!","text":"Sets the dataframe's timeframe metadata to the given TimeFrame.\n\nShouldn't be called directly, see timeframe!(::DataFrame)\n\n\n\n\n\n","category":"method"},{"location":"API/dfutils/#TimeTicks.timeframe-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"DataFrame utils","title":"TimeTicks.timeframe","text":"Returns the timeframe of a dataframe according to its metadata.\n\ntimeframe(\n    df::DataFrames.AbstractDataFrame\n) -> TimeFrames.TimeFrame\n\n\nIf the value is not found in the metadata, infer it by timestamp column of the dataframe. If the timeframe can't be inferred, a TimeFrame(0) is returned. NOTE: slow func, for speed use timeframe!(::DataFrame)\n\n\n\n\n\n","category":"method"},{"location":"optimization/#Optimization","page":"Optimization","title":"Optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"PingPong provides tools to optimize strategy parameters. Optimzations are managed through the Optimization.OptSession type. Which is a structure that holds informations about the optimization parameters, configuration and previous runs. Optimization sessions can be periodically saved, and therefore can be reloaded at a later time to explore previous results or continue the optimization from where it left off.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"There are currently 3 different optimization methods: Optimization.gridsearch, Optimization.bboptimize, boptimize!(when using BayesianOptimization). Configuration is done by defining three ping! functions.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"ping!(::S, ::OptSetup): returns a named tuples with:\nctx: a Executors.Context which is the period of time used for backtesting\nparams: a named tuple of all the parameters to be optimizied. Values should be in the form of iterables.\nspace: only required for bboptimize, a named tuple where\nkind: is the type of space (from BlackBoxOptim package)\nprecision: If the space is :MixedPrecisionRectSearchSpace it is a vector where each element is the number of decimals to consider in parameters of type float.\nping!(::S, ::OptRun): called before a single backtest is run. Receives one combination of the parameters. Should apply the parameters to the strategy. No return values expected.\nping!(::S, ::OptScore)::Vector: for bboptimize and boptimize! it is the objective score that advances the optimization. In grid search it can be used to store additional metrics in the results dataframe. Within the Stats package there are metrics like sharpeorsortino` commonly used as optimization objectives.","category":"page"},{"location":"optimization/#Grid-search","page":"Optimization","title":"Grid search","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"This is the recommended approach, useful if the strategy has a small set of parameters (<5).","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"using Optimization\ngridsearch(s, splits=1, save_freq=Minute(1), resume=false)","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Will perform an search from scratch, saving every minute. splits controls the number of times a backtest is run using the same combination of parameters. When splits > 1 we split the optimization Context into shorter ranges and restart the backtest on each one of these sub contexes. This allows to fuzz out scenarios of overfitting by averaging the results of different backtest \"restarts\".","category":"page"},{"location":"optimization/#Black-box-optimization","page":"Optimization","title":"Black box optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"The BlackBoxOptim offers multiple methods for searching, also also offers multi objective optimization. You can pass any arg supported by the upstream bboptimze function.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Optimization.bboptimize(s, splits=3, MaxTime=240.0, Method=:borg_moea)","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"We exclude some optimization methods because they are slow or for some other quirks. Get the list of methods by calling bbomethods.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Optimization.bbomethods()\nOptimization.bbomethods(true) # multi obj methods","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"@doc bboptimize shows some common argument you might want to pass to the optimization function like MaxTime or MaxSteps. For the full list refer to the BlackBoxOptimi package.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"The BayesianOptimization package instead focus on gausiann processes and is provided as an extension of the Optimization package, (you need to install the packgage yourself). If you want to customize the optimization parameters you can define methods for your strategy over the functions gpmodel, modelopt and acquisition. Like bboptimize you can pass any upstream kwargs to boptimize!.","category":"page"},{"location":"optimization/#Multi-threading","page":"Optimization","title":"Multi-threading","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Parallel execution is supported for optimizations, though the extent and approach vary depending on the optimization method used.","category":"page"},{"location":"optimization/#Grid-Search","page":"Optimization","title":"Grid Search","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"In grid search optimizations, parallel execution is permitted across different parameter combinations, enhancing efficiency. However, repetitions of the optimization process are executed sequentially to maintain result consistency.","category":"page"},{"location":"optimization/#Black-Box-Optimization","page":"Optimization","title":"Black Box Optimization","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"For black box optimization, the scenario is reversed: repetitions are performed in parallel to expedite the overall process, while the individual optimization runs are sequential. This approach is due to the limited benefits of parallelizing these runs and the current limitations in the BlackBoxOptim library's multi-threading support.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"To enable multi-threading, your strategy must declare a global thread-safe flag as follows:","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"julia\nconst THREADSAFE = Ref(true)","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"warning: Thread Safety Caution\nMulti-threading can introduce safety issues, particularly with Python objects. To prevent crashes, avoid using Python objects within your strategy and utilize synchronization mechanisms like locks or ConcurrentCollections. Ensuring thread safety is your responsibility.","category":"page"},{"location":"optimization/#Plotting-Results","page":"Optimization","title":"Plotting Results","text":"","category":"section"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"Visualizing the outcomes of an optimization can be accomplished with the Plotting.plot_results function. This function is versatile, offering customization options for axes selection (supports up to three axes), color gradients (e.g., depicting cash flow from red to green in a scatter plot), and grouping of result elements. The default visualization is a scatter plot, but surface and contour plots are also supported.","category":"page"},{"location":"optimization/","page":"Optimization","title":"Optimization","text":"info: Package Loading Order\nThe plot_results function is part of the Plotting package, which acts as an extension. To use it, perform the following steps:julia\n# Restart the REPL if PingPong was previously imported.\nusing Pkg: Pkg\nPkg.activate(\"PingPongInteractive\")\nusing PingPongInteractive\n# Now you can call Plotting.plot_results(...)Alternatively, activate and load the Plotting package first, followed by the Optimization package. The PingPong framework provides convenience functions to streamline this process:julia\nusing PingPong\nplots!() # This loads the Plotting package.\nusing Optimization","category":"page"},{"location":"API/fetch/#Fetch-module","page":"Fetch module","title":"Fetch module","text":"","category":"section"},{"location":"API/fetch/","page":"Fetch module","title":"Fetch module","text":"Modules = [Fetch]","category":"page"},{"location":"API/fetch/#Fetch.FUNDING_RATES_CACHE","page":"Fetch module","title":"Fetch.FUNDING_RATES_CACHE","text":"Initializes a safe TTL cache for storing multiple funding rates with a specified TTL.\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.FUNDING_RATE_CACHE","page":"Fetch module","title":"Fetch.FUNDING_RATE_CACHE","text":"Initializes a safe TTL cache for storing funding rates with a specified TTL.\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.FUNDING_RATE_TTL","page":"Fetch module","title":"Fetch.FUNDING_RATE_TTL","text":"Defines the time-to-live (TTL) for a funding rate as 5 seconds.\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.MAX_ORDERS","page":"Fetch module","title":"Fetch.MAX_ORDERS","text":"Defines an array representing possible numbers of orders to fetch.\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.OB_CACHE","page":"Fetch module","title":"Fetch.OB_CACHE","text":"Initializes a safe TTL cache for storing order book data with the default eviction TTL.\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.OB_EVICTION_TTL","page":"Fetch module","title":"Fetch.OB_EVICTION_TTL","text":"Defines the eviction time-to-live (TTL) for an order book as 5 minutes.\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.OB_FUNCTIONS","page":"Fetch module","title":"Fetch.OB_FUNCTIONS","text":"Initializes a LittleDict for storing order book functions keyed by order book level and exchange ID.\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.OB_TTL","page":"Fetch module","title":"Fetch.OB_TTL","text":"Defines the time-to-live (TTL) for an order book as 5 seconds (after which it is stale).\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.OHLCVTupleTypes","page":"Fetch module","title":"Fetch.OHLCVTupleTypes","text":"Defines the tuple type for OHLCV data, where each element represents a specific metric (Open, High, Low, Close, Volume).\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.SINCE_MIN_PERIOD","page":"Fetch module","title":"Fetch.SINCE_MIN_PERIOD","text":"Used to slide the since param forward when retrying fetching (in case the requested timestamp is too old).\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.futures_limits","page":"Fetch module","title":"Fetch.futures_limits","text":"Defines limit values for fetching futures data from exchanges.\n\n\n\n\n\n","category":"constant"},{"location":"API/fetch/#Fetch.OrderBookTuple","page":"Fetch module","title":"Fetch.OrderBookTuple","text":"Defines a NamedTuple structure for order book data.\n\n\n\n\n\n","category":"type"},{"location":"API/fetch/#Base.convert-Tuple{Type{Tuple{Vector{Dates.DateTime}, Vararg{Vector{Float64}, 5}}}, Py}","page":"Fetch module","title":"Base.convert","text":"This is the fastest (afaik) way to convert ccxt lists to dataframe friendly format.\n\nconvert(\n    _::Type{Tuple{Vector{Dates.DateTime}, Vararg{Vector{Float64}, 5}}},\n    py::Py\n) -> Tuple{Vector{Dates.DateTime}, Vararg{Vector{Float64}}}\n\n\nThis function converts the provided Python object to a tuple format suitable for dataframes, specifically tailored for OHLCV data.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Data.propagate_ohlcv!-Tuple{SortedDict, AbstractString, Exchange}","page":"Fetch module","title":"Data.propagate_ohlcv!","text":"Propagates OHLCV data to all timeframes in a data structure.\n\npropagate_ohlcv!(\n    data::SortedDict,\n    pair::AbstractString,\n    exc::Exchange\n) -> Union{Nothing, SortedDict{TimeFrames.TimeFrame, DataFrames.DataFrame}}\n\n\nThe propagate_ohlcv! function propagates OHLCV data for a given pair from an exchange exc to all timeframes in the data SortedDict data structure.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Data.to_ohlcv-Tuple{Py}","page":"Fetch module","title":"Data.to_ohlcv","text":"Converts a Python object to a DataFrame with OHLCV columns\n\nto_ohlcv(py::Py)\n\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.__ensure_dates-NTuple{4, Any}","page":"Fetch module","title":"Fetch.__ensure_dates","text":"Ensures dates are within valid range for the exchange and timeframe.\n\n__ensure_dates(exc, tf, from, to) -> Tuple{Any, Any}\n\n\nThe __ensure_dates function checks if the dates from and to are within the valid range for the given exchange exc and timeframe tf. If the dates are not within the valid range, the function adjusts them accordingly.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.__from_date_func-NTuple{7, Any}","page":"Fetch module","title":"Fetch.__from_date_func","text":"Determines the starting date for fetching data.\n\n__from_date_func(\n    update,\n    timeframe,\n    from,\n    to,\n    zi,\n    exc_name,\n    reset\n) -> Any\n\n\nThe __from_date_func function determines the starting date from for fetching data based on various parameters. If update is true, it will fetch data from the latest date available. If reset is true, it will fetch data from the earliest date possible. The function also considers the timeframe, to date, timezone zi, and exchange name exc_name in its calculations.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.__get_ohlcv-NTuple{5, Any}","page":"Fetch module","title":"Fetch.__get_ohlcv","text":"Fetches OHLCV data for a specified exchange within a date range.\n\n__get_ohlcv(\n    exc,\n    name,\n    timeframe,\n    from_date,\n    to;\n    out,\n    cleanup,\n    ohlcv_kind\n) -> Tuple{Any, Any}\n\n\nThis function fetches OHLCV data for a given exchange exc, with the specified name and timeframe, within the date range specified by from_date and to. The fetched data is appended to the out data structure. The cleanup parameter determines if any post-processing should be done on the data before returning. The ohlcv_kind parameter determines the type of OHLCV data to fetch.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.__get_since-NTuple{8, Any}","page":"Fetch module","title":"Fetch.__get_since","text":"Determines the 'since' parameter for fetching data from an exchange.\n\n__get_since(\n    exc,\n    fetch_func,\n    pair,\n    limit,\n    from,\n    out,\n    is_df,\n    converter\n) -> Any\n\n\nThis function calculates the 'since' parameter based on the specified 'from' timestamp, or finds the appropriate 'since' value if 'from' is 0.0.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.__handle_error-NTuple{9, Any}","page":"Fetch module","title":"Fetch.__handle_error","text":"Handles errors during fetch operations.\n\n__handle_error(\n    e,\n    fetch_func,\n    pair,\n    since,\n    df,\n    sleep_t,\n    limit,\n    converter,\n    retry\n) -> Any\n\n\nThis function takes an error e occurred during data fetching, and decides whether to retry the fetch_func based on the retry flag. If retry is true, it calls the fetch_func again with the same parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.__handle_fetch-NTuple{9, Any}","page":"Fetch module","title":"Fetch.__handle_fetch","text":"Handles fetch operations for specified exchange and pair.\n\n__handle_fetch(\n    fetch_func,\n    pair,\n    since,\n    limit,\n    sleep_t,\n    df,\n    converter,\n    retry,\n    usetimeframe\n) -> Tuple{Bool, Any}\n\n\nThis function calls the fetch_func for a given pair, starting from the since timestamp with a maximum limit of limit data points. It employs a delay sleep_t between fetches. The function also applies a given converter to the fetched data. If the retry flag is true, the function will try to fetch data again in case of an empty response. The usetimeframe flag indicates whether to use timeframe for fetching.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.__ordered_timeframes-Tuple{Exchange}","page":"Fetch module","title":"Fetch.__ordered_timeframes","text":"Returns an ordered list of timeframes for a given exchange\n\n__ordered_timeframes(exc::Exchange) -> Tuple{Any, Any}\n\n\nThis function collects the timeframes from the exchange, converts them into periods, and sorts them in descending order. It then returns these sorted timeframes and periods.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.__pairdata!-NTuple{8, Any}","page":"Fetch module","title":"Fetch.__pairdata!","text":"Processes OHLCV data for a pair.\n\n__pairdata!(\n    zi,\n    data,\n    ohlcv,\n    name,\n    timeframe,\n    z,\n    exc_name,\n    reset\n) -> Data.PairData\n\n\nThe __pairdata! function processes the OHLCV data ohlcv for a pair name over a timeframe. It takes into account the timezone zi, data data, timezone offset z, exchange name exc_name, and a reset flag. If reset is true, it will reset the data for the pair before processing.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch._cleanup_funding_history-NTuple{4, Any}","page":"Fetch module","title":"Fetch._cleanup_funding_history","text":"Cleans up fetched funding history data.\n\n_cleanup_funding_history(df, name, half_tf, f_tf) -> Any\n\n\nThe _cleanup_funding_history function takes a DataFrame df of fetched funding history data for a name and performs cleanup operations on it. The half_tf and f_tf parameters are used in the cleanup process.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch._fetch_loop-Union{Tuple{F}, Tuple{Function, Exchange, Any}} where F<:AbstractFloat","page":"Fetch module","title":"Fetch._fetch_loop","text":"Iteratively fetches data over a specified date range.\n\n_fetch_loop(\n    fetch_func::Function,\n    exc::Exchange,\n    pair;\n    from,\n    to,\n    sleep_t,\n    out,\n    converter,\n    limit\n)\n\n\nThis function calls the fetch_func function repeatedly until it has fetched data for the entire date range specified by from and to. Note: The total data points fetched may not match the expected number based on the date range.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch._fetch_ohlcv_from_to-Tuple{Exchange, Any, Any}","page":"Fetch module","title":"Fetch._fetch_ohlcv_from_to","text":"Ensure a to date is set, before fetching.\n\n_fetch_ohlcv_from_to(\n    exc::Exchange,\n    pair,\n    timeframe;\n    from,\n    to,\n    params,\n    sleep_t,\n    cleanup,\n    out,\n    ohlcv_kind\n) -> Any\n\n\nThis function verifies that a 'to' date is set before attempting to fetch OHLCV data.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch._fetch_ohlcv_with_delay-Tuple{Exchange, Vararg{Any}}","page":"Fetch module","title":"Fetch._fetch_ohlcv_with_delay","text":"Fetches OHLCV data with delay for a given exchange and arguments.\n\n_fetch_ohlcv_with_delay(\n    exc::Exchange,\n    args...;\n    ohlcv_kind,\n    kwargs...\n) -> Any\n\n\nThis function fetches OHLCV data for a specified exchange exc and additional args. The type of OHLCV data to fetch is determined by ohlcv_kind. It applies a delay between fetches as specified in kwargs.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch._fetch_with_delay-Tuple{Function, Any}","page":"Fetch module","title":"Fetch._fetch_with_delay","text":"Wraps fetching function with error handling and backoff delay.\n\n_fetch_with_delay(\n    fetch_func::Function,\n    pair;\n    since,\n    df,\n    sleep_t,\n    limit,\n    converter,\n    retry,\n    usetimeframe\n) -> Any\n\n\nThis function wraps a fetching function fetch_func with error handling and a backoff delay sleep_t. The fetch_func takes three parameters: pair, since, and limit, and returns a PyList. The converter function is used to tabulate the data such that the first column is the timestamp. The function will retry fetching in case of an error if retry is set to true.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch._levelname-Tuple{Any}","page":"Fetch module","title":"Fetch._levelname","text":"Returns the name of an order book level.\n\n_levelname(level) -> String\n\n\nThe _levelname function takes an order book level and returns its name.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch._orderbook-Tuple{Any}","page":"Fetch module","title":"Fetch._orderbook","text":"Generates an order book of depth N.\n\n_orderbook(\n    N\n) -> @NamedTuple{busy::Ref{Bool}, timestamp::Ref{Dates.DateTime}, asks::Vector{Tuple{Float64, Float64}}, bids::Vector{Tuple{Float64, Float64}}}\n\n\nThe _orderbook function generates an order book of depth N. The order book contains N levels of bid and ask prices along with their corresponding quantities.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch._since_timestamp-Tuple{Dates.DateTime, Dates.Period}","page":"Fetch module","title":"Fetch._since_timestamp","text":"Determines the start time for fetching data\n\n_since_timestamp(\n    actual::Dates.DateTime,\n    p::Dates.Period\n) -> Int64\n\n\nThis function calculates the timestamp from which to start fetching data. It ensures that the start time is not more than 20 years in the past or less than the given period.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch._update_orderbook!-NTuple{5, Any}","page":"Fetch module","title":"Fetch._update_orderbook!","text":"Updates an order book in place with new data.\n\n_update_orderbook!(exc, ob, sym, lvl, limit; init)\n\n\nThe _update_orderbook! function takes an exchange exc, an order book ob, a symbol sym, an order book level lvl, and a limit limit, and updates the order book in place with new data. If init is set, the function will initialize the order book before updating it.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.extract_futures_data-Tuple{Py}","page":"Fetch module","title":"Fetch.extract_futures_data","text":"Extracts futures data from a Python object.\n\nextract_futures_data(data::Py) -> DataFrames.DataFrame\n\n\nThe extract_futures_data function takes futures data data from a Python object and extracts it into a format suitable for further processing or analysis.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.fetch_candles-Tuple{Exchange, AbstractString, Union{AbstractString, AbstractSet, AbstractVector, Tuple{Vararg{T}} where T}}","page":"Fetch module","title":"Fetch.fetch_candles","text":"Fetches candlestick data for a list of pairs from an exchange.\n\nfetch_candles(\n    exc::Exchange,\n    timeframe::AbstractString,\n    pairs::Union{AbstractString, AbstractSet, AbstractVector, Tuple{Vararg{T}} where T};\n    from,\n    to,\n    ohlcv_kind\n) -> Any\n\n\nThe fetch_candles function fetches candlestick data from a given exchange exc for a list of pairs over a specified timeframe. The from and to parameters define the date range for the fetched data. If from is not provided, it defaults to an empty string, which implies fetching data from the earliest available date. The type of candlestick data to fetch is determined by the ohlcv_kind parameter.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.fetch_limit-Tuple{Exchange, Union{Nothing, Int64}}","page":"Fetch module","title":"Fetch.fetch_limit","text":"Defines the fetch limit for an exchange.\n\nfetch_limit(\n    exc::Exchange,\n    limit::Union{Nothing, Int64}\n) -> Union{Nothing, Int64}\n\n\nThis function fetches the limit for an exchange. If no limit is specified, it retrieves the default limit for the exchange.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.fetch_ohlcv-Tuple{Exchange, String, Union{AbstractSet{T}, AbstractVector{T}, Tuple{Vararg{T}}} where T}","page":"Fetch module","title":"Fetch.fetch_ohlcv","text":"Fetches OHLCV data from an exchange for a list of pairs.\n\nfetch_ohlcv(\n    exc::Exchange,\n    timeframe::String,\n    pairs::Union{AbstractSet{T}, AbstractVector{T}, Tuple{Vararg{T}}} where T;\n    zi,\n    from,\n    to,\n    update,\n    reset,\n    progress,\n    ohlcv_kind\n) -> Dict{String, Data.PairData}\n\n\nThis function fetches OHLCV data from a given exchange exc for a list of pairs over a specified timeframe. The from and to parameters can represent dates or, if from is a negative number, the function fetches the last N=from candles. If update is true, the function checks for cached data and only fetches missing candles. If reset is true, the function removes cached data before fetching. The progress parameter determines whether a progress bar is shown. The type of OHLCV data to fetch is defined by the ohlcv_kind parameter.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.fetch_ohlcv-Tuple{Val{:ask}, Vararg{Any}}","page":"Fetch module","title":"Fetch.fetch_ohlcv","text":"Prompts user for confirmation before fetching OHLCV data.\n\nfetch_ohlcv(::Val{:ask}, args...; kwargs...) -> Any\n\n\nThis function prompts the user for confirmation before fetching OHLCV data for the specified arguments args and keyword arguments kwargs. If the user inputs 'Y', 'y', or simply presses Enter, it proceeds with the fetch_ohlcv function. If any other input is given, the function returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.fetch_ohlcv-Tuple{Vector{Exchange}, Any}","page":"Fetch module","title":"Fetch.fetch_ohlcv","text":"Fetches OHLCV data for multiple exchanges on the same timeframe.\n\nfetch_ohlcv(\n    excs::Vector{Exchange},\n    timeframe;\n    sandbox,\n    parallel,\n    wait_task,\n    kwargs...\n) -> Union{Nothing, Task}\n\n\nThis function fetches OHLCV data for multiple exchanges over the same timeframe. It accepts:\n\nA vector of exchange instances excs.\nThe desired timeframe timeframe.\n\nThe function can run in parallel if parallel is set to true. If wait_task is set to true, the function will wait for all tasks to complete before returning.\n\nYou can provide additional parameters using kwargs.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.find_since-Tuple{Exchange, Any}","page":"Fetch module","title":"Fetch.find_since","text":"Returns the oldest possible timestamp for a pair.\n\nfind_since(exc::Exchange, pair) -> Any\n\n\nThis function iterates over the timeframes and periods of the exchange to find the oldest available timestamp for a given pair. If no data is found in any timeframe, it defaults to 1 day in the past.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.funding_data-Tuple{Exchange, AbstractString}","page":"Fetch module","title":"Fetch.funding_data","text":"Retrieves all or a subset of funding data for a symbol from an exchange.\n\nfunding_data(exc::Exchange, sym::AbstractString) -> Any\n\n\nThe funding_data function retrieves all funding data returned by an exchange exc for a symbol sym.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.funding_history-Tuple{Exchange, Vector}","page":"Fetch module","title":"Fetch.funding_history","text":"Fetches funding rate history from an exchange for a list of Derivative pairs.\n\nfunding_history(\n    exc::Exchange,\n    assets::Vector;\n    from,\n    to,\n    params,\n    sleep_t,\n    limit,\n    cleanup\n) -> Dict\n\n\nThe funding_history function fetches funding rate history from a given exchange exc for a list of assets. The from and to parameters define the date range for which to fetch the funding rate history. Additional parameters can be specified through the params dictionary. The function will wait for sleep_t seconds between each request to the exchange. The limit parameter can be used to limit the amount of data fetched. If cleanup is set to true, the function will perform a cleanup on the fetched data before returning it.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.funding_rate-Tuple{Exchange, AbstractString}","page":"Fetch module","title":"Fetch.funding_rate","text":"Retrieves the funding rate for a symbol from an exchange.\n\nfunding_rate(exc::Exchange, s::AbstractString) -> Any\n\n\nThe funding_rate function retrieves the funding rate for a symbol s from an exchange exc.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.ohlcv_func_bykind-Tuple{Any, Any}","page":"Fetch module","title":"Fetch.ohlcv_func_bykind","text":"Returns the appropriate OHLCV fetching function based on the specified kind.\n\nohlcv_func_bykind(exc, kind) -> Any\n\n\nThe ohlcv_func_bykind function determines and returns the appropriate OHLCV fetching function for the given exchange exc and kind.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.orderbook-Tuple{Any, Any}","page":"Fetch module","title":"Fetch.orderbook","text":"Fetches an order book from an exchange for a symbol.\n\norderbook(exc, sym; limit, level) -> Any\n\n\nThe orderbook function fetches an order book from an exchange exc for a symbol sym. The limit parameter can be used to limit the depth of the order book. The level parameter specifies the level of the order book to fetch.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.parse_funding_row-Tuple{Py}","page":"Fetch module","title":"Fetch.parse_funding_row","text":"Parses a row of funding data from a Python object.\n\nparse_funding_row(r::Py) -> Tuple{Int64, String, Float64}\n\n\nThe parse_funding_row function takes a row of funding data r from a Python object and parses it into a format suitable for further processing or analysis.\n\n\n\n\n\n","category":"method"},{"location":"API/fetch/#Fetch.update_ohlcv!-Tuple{DataFrames.DataFrame, Any, Any, Any}","page":"Fetch module","title":"Fetch.update_ohlcv!","text":"Updates the tail of an OHLCV DataFrame with the most recent candles.\n\nupdate_ohlcv!(\n    df::DataFrames.DataFrame,\n    pair,\n    exc,\n    tf;\n    ohlcv_kind,\n    from\n) -> DataFrames.DataFrame\n\n\nThe update_ohlcv! function updates the tail of an OHLCV DataFrame df with the most recent candles for a given pair from an exchange exc over a timeframe tf. The type of OHLCV data to update is determined by the ohlcv_kind parameter.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#CoinGecko","page":"CoinGecko","title":"CoinGecko","text":"","category":"section"},{"location":"watchers/apis/coingecko/#API","page":"CoinGecko","title":"API","text":"","category":"section"},{"location":"watchers/apis/coingecko/","page":"CoinGecko","title":"CoinGecko","text":"Modules = [Watchers.CoinGecko]","category":"page"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinschart-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinschart","text":"Get close price and volume for symbol id for specified number of days.\n\ninfo: days=\"max\"\nreturns all available history.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinschart_range-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinschart_range","text":"Same as CoinGecko.coinschart but for specified timerange.\n\nfrom, to: date range boundaries.\n\nwarning: From coingecko:\nData granularity is automatic (cannot be adjusted)1 day from current time = 5 minute interval data\n1 - 90 days from current time = hourly data\nabove 90 days from current time = daily data (00:00 UTC)\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinschart_tf-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinschart_tf","text":"Pull market data range according to timeframe.\n\n5m: 1 day\n1h: 90 days\n>1h: 365 days\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinshistory","page":"CoinGecko","title":"Watchers.CoinGecko.coinshistory","text":"Get data for symbol id at specified date.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinsid-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinsid","text":"Get all current data for symbol id.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinsmarkets-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.coinsmarkets","text":"Get markets for a list of symbols, accepting params CoinGecko.Params.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinsohlc","page":"CoinGecko","title":"Watchers.CoinGecko.coinsohlc","text":"Pulls ohlc data (no volumes) according to timeframe.\n\n<=30m: 1 day\n<=4h: 30 days\n>4h: max\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.coinsticker-Tuple{AbstractString}","page":"CoinGecko","title":"Watchers.CoinGecko.coinsticker","text":"Get all tickers (from all coingecko exchanges) for symbol id.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.derivatives-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.derivatives","text":"Returns all unexpired derivative contracts.\n\nContracts are grouped by exchange, the id being the slugified exchange name.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.derivatives_from-Tuple{Any}","page":"CoinGecko","title":"Watchers.CoinGecko.derivatives_from","text":"Fetch derivatives from specified exchange.\n\nReturns a Dict{Derivative, Dict}.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.globaldata-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.globaldata","text":"Returns global data for:\n\nvolume: total_volume (Dict{String, Float64})\nmcap_change_24h: marketcapchangepercentage24h_usd\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.idbysym-Tuple{Any, Bool}","page":"CoinGecko","title":"Watchers.CoinGecko.idbysym","text":"Get all coingecko item id matching by its symbol.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.idbysym-Tuple{Any}","page":"CoinGecko","title":"Watchers.CoinGecko.idbysym","text":"Get the first coingecko item id by its symbol.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.loadcoins!-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.loadcoins!","text":"Load all coins symbols.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.loadderivatives!-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.loadderivatives!","text":"Returns the list of all exchange ids.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.ratelimit-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.ratelimit","text":"Allows only 1 query every 3000 milliseconds seconds.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.tickers_from-Tuple{Any}","page":"CoinGecko","title":"Watchers.CoinGecko.tickers_from","text":"Fetches top 100 tickers from exchange.\n\nReturns a Dict{Asset, Dict}\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coingecko/#Watchers.CoinGecko.trending-Tuple{}","page":"CoinGecko","title":"Watchers.CoinGecko.trending","text":"24h trending top 7 coins.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#CoinPaprika","page":"CoinPaprika","title":"CoinPaprika","text":"","category":"section"},{"location":"watchers/apis/coinpaprika/#API","page":"CoinPaprika","title":"API","text":"","category":"section"},{"location":"watchers/apis/coinpaprika/","page":"CoinPaprika","title":"CoinPaprika","text":"Modules = [Watchers.CoinPaprika]","category":"page"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.addcalls!","page":"CoinPaprika","title":"Watchers.CoinPaprika.addcalls!","text":"Manually add available api calls (mostly for debugging).\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.betas-Tuple{}","page":"CoinPaprika","title":"Watchers.CoinPaprika.betas","text":"Returns coins betas in a dataframe compatible type.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.coin_exchanges-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.coin_exchanges","text":"Get all exchanges for specified coin.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.coin_markets-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.coin_markets","text":"Returns all markets for give coin (interpreted as base currency).\n\nwarning: Expensive call\nDon't call too often.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.coin_ohlcv-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.coin_ohlcv","text":"Coin ohlcv (last day).\n\nincomplete: if true returns the (today) incomplete candle.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.hourly","page":"CoinPaprika","title":"Watchers.CoinPaprika.hourly","text":"Returns historical hourly tick values for the last day.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.idbysym-Tuple{Any, Bool}","page":"CoinPaprika","title":"Watchers.CoinPaprika.idbysym","text":"Get all coinpaprika item id matching by its symbol.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.idbysym-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.idbysym","text":"Get the first coinpaprika item id by its symbol.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.loadcoins!-Tuple{}","page":"CoinPaprika","title":"Watchers.CoinPaprika.loadcoins!","text":"Load all coin ids.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.loadexchanges!-Tuple{}","page":"CoinPaprika","title":"Watchers.CoinPaprika.loadexchanges!","text":"Load market ids.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.markets","page":"CoinPaprika","title":"Watchers.CoinPaprika.markets","text":"Fetch all markets for specified exchange.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.ratelimit-Tuple{}","page":"CoinPaprika","title":"Watchers.CoinPaprika.ratelimit","text":"CoinPaprika free plan is 25k queries per month, which is 1q/25s.\n\nOn every call we check when the last query was performed, and add available queries that weren't used on a counter, to allow for bursts.\n\nwarning: Not precise\nCoinpaprika does not expose credits consumed by each endpoint, so we assume all calls are equals (2/min).\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.ticker-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.ticker","text":"Fetch ticker for specified coin.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.tickers","page":"CoinPaprika","title":"Watchers.CoinPaprika.tickers","text":"Fetch quotes for all pairs, includes coinpaprika beta metric.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinpaprika/#Watchers.CoinPaprika.twitter-Tuple{Any}","page":"CoinPaprika","title":"Watchers.CoinPaprika.twitter","text":"Get last ~50 tweets for coin.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinmarketcap/#CoinMarketCap","page":"CoinMarketCap","title":"CoinMarketCap","text":"","category":"section"},{"location":"watchers/apis/coinmarketcap/#API","page":"CoinMarketCap","title":"API","text":"","category":"section"},{"location":"watchers/apis/coinmarketcap/","page":"CoinMarketCap","title":"CoinMarketCap","text":"Modules = [Watchers.CoinMarketCap]","category":"page"},{"location":"watchers/apis/coinmarketcap/#Watchers.CoinMarketCap.credits-Tuple{}","page":"CoinMarketCap","title":"Watchers.CoinMarketCap.credits","text":"Fetch remaining credits.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinmarketcap/#Watchers.CoinMarketCap.listings","page":"CoinMarketCap","title":"Watchers.CoinMarketCap.listings","text":"Fetch all coin listings.\n\n\n\n\n\n","category":"function"},{"location":"watchers/apis/coinmarketcap/#Watchers.CoinMarketCap.quotes-Tuple{AbstractArray{String}}","page":"CoinMarketCap","title":"Watchers.CoinMarketCap.quotes","text":"Call quotes to get data for a specific list of currencies.\n\nPassing values of type Symbol will use the symbol parameter, while String will use the slug parameter.\n\n\n\n\n\n","category":"method"},{"location":"watchers/apis/coinmarketcap/#Watchers.CoinMarketCap.setapikey!","page":"CoinMarketCap","title":"Watchers.CoinMarketCap.setapikey!","text":"Sets coinmarketcap api key.\n\nfrom env var PINGPONG_CMC_APIKEY\nor from config key coinmarketcap_apikey\n\n\n\n\n\n","category":"function"},{"location":"API/plotting/#Plotting","page":"Plotting","title":"Plotting","text":"","category":"section"},{"location":"API/plotting/","page":"Plotting","title":"Plotting","text":"Modules = [ Plotting ]\nPrivate = false\nPublic = true","category":"page"},{"location":"API/plotting/#Plotting.balloons-Tuple{Strategies.Strategy, Instances.AssetInstance}","page":"Plotting","title":"Plotting.balloons","text":"Plots all trades for a single asset instance.\n\nballoons(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance;\n    tf,\n    force\n) -> Makie.Figure\n\n\nThis function plots all trades for a single asset instance, aggregating data to the provided timeframe. It generates OHLCV data for trades, checks the size of the dataframe, prepares the figure for trade plotting, and creates triangles for IncreaseTrade and ReduceTrade. The function returns the figure.\n\n\n\n\n\n","category":"method"},{"location":"API/plotting/#Plotting.balloons-Tuple{Strategies.Strategy}","page":"Plotting","title":"Plotting.balloons","text":"Plots all trades for all strategy assets.\n\nballoons(\n    s::Strategies.Strategy;\n    benchmark,\n    tf,\n    force\n) -> Makie.Figure\n\n\nThis function plots all trades for all strategy assets, aggregating data to the provided timeframe. The benchmark parameter determines the data over which to plot trades. The function returns the figure.\n\n\n\n\n\n","category":"method"},{"location":"API/plotting/#Plotting.channel_indicator!-Tuple{Makie.Figure, Vararg{Any}}","page":"Plotting","title":"Plotting.channel_indicator!","text":"Adds channel indicators to a given figure.\n\nchannel_indicator!(fig::Makie.Figure, lines...; df, opacity)\n\n\nThe function channel_indicator! takes a Figure object and one or more line data arrays as arguments. It first checks if the size of each line matches the number of candles in the figure. Then, it creates a new axis in the figure and links it with the price axis. For each pair of lines, it generates a random color and adds a band plot to the axis with a tooltip showing the values of the upper and lower bounds at each point. The opacity of the band can be adjusted with the opacity keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"API/plotting/#Plotting.channel_indicator-Tuple{DataFrames.AbstractDataFrame, Vararg{Any}}","page":"Plotting","title":"Plotting.channel_indicator","text":"Adds channel indicators to a given figure.\n\nchannel_indicator(\n    df::DataFrames.AbstractDataFrame,\n    lines...;\n    opacity\n) -> Makie.Figure\n\n\nThe function channel_indicator! takes a Figure object and one or more line data arrays as arguments. It first checks if the size of each line matches the number of candles in the figure. Then, it creates a new axis in the figure and links it with the price axis. For each pair of lines, it generates a random color and adds a band plot to the axis with a tooltip showing the values of the upper and lower bounds at each point. The opacity of the band can be adjusted with the opacity keyword argument.\n\n\n\n\n\n","category":"method"},{"location":"API/plotting/#Plotting.line_indicator!-Tuple{Makie.Figure, Vararg{Any}}","page":"Plotting","title":"Plotting.line_indicator!","text":"Adds line indicators to a given figure.\n\nline_indicator!(fig::Makie.Figure, lines...; df)\n\n\nThe function line_indicator! takes a Figure object and one or more line data arrays as arguments. It first checks if the size of each line matches the number of candles in the figure. Then, it creates a new axis in the figure and links it with the price axis. For each line, it generates a random color and adds a line plot to the axis with a tooltip showing the value of the line at each point.\n\n\n\n\n\n","category":"method"},{"location":"API/plotting/#Plotting.line_indicator-Tuple{DataFrames.AbstractDataFrame, Vararg{Any}}","page":"Plotting","title":"Plotting.line_indicator","text":"Creates a figure with line indicators from a DataFrame.\n\nline_indicator(\n    df::DataFrames.AbstractDataFrame,\n    lines...\n) -> Makie.Figure\n\n\nThe function line_indicator takes an AbstractDataFrame and one or more line data arrays as arguments. It first creates a figure using the ohlcv function with the DataFrame. Then, it calls the line_indicator! function to add line indicators to the figure. The function returns the figure with the added line indicators.\n\n\n\n\n\n","category":"method"},{"location":"API/plotting/#Plotting.ohlcv","page":"Plotting","title":"Plotting.ohlcv","text":"Plots ohlcv data from dataframe df, resampling to tf\n\nohlcv(df::DataFrames.AbstractDataFrame; ...) -> Makie.Figure\nohlcv(\n    df::DataFrames.AbstractDataFrame,\n    tf;\n    kwargs...\n) -> Makie.Figure\n\n\nThe function takes a dataframe df and a time frame tf as parameters. If tf is not nothing, the dataframe is resampled according to the time frame.\n\n\n\n\n\n","category":"function"},{"location":"API/plotting/#Plotting.ohlcv!","page":"Plotting","title":"Plotting.ohlcv!","text":"Plots ohlcv data from dataframe df, resampling to tf on an existing figure\n\nohlcv!(\n    fig::Makie.Figure,\n    df::DataFrames.AbstractDataFrame\n) -> Makie.Figure\nohlcv!(\n    fig::Makie.Figure,\n    df::DataFrames.AbstractDataFrame,\n    tf\n) -> Makie.Figure\n\n\nThe function takes a figure fig, a dataframe df, and a time frame tf as parameters. If tf is not nothing, the dataframe is resampled according to the time frame. The function then plots the ohlcv data on the provided figure.\n\n\n\n\n\n","category":"function"},{"location":"API/plotting/#Plotting.tradesticks","page":"Plotting","title":"Plotting.tradesticks","text":"Plots a subset of trades history of an asset instance.\n\ntradesticks(s::Strategies.Strategy; ...) -> Makie.Figure\ntradesticks(\n    s::Strategies.Strategy,\n    fig::Makie.Figure,\n    args...;\n    kwargs...\n) -> Makie.Figure\n\n\nThis function plots a subset of trades history of an asset instance. It takes a Strategy and an AssetInstance as parameters and optionally a Figure and additional arguments. It returns the result of the base tradesticks! function.\n\n\n\n\n\n","category":"function"},{"location":"API/plotting/#Plotting.tradesticks!","page":"Plotting","title":"Plotting.tradesticks!","text":"Plots trades on a figure for a given asset instance.\n\ntradesticks!(\n    fig::Makie.Figure,\n    ai::Instances.AssetInstance;\n    ...\n) -> Makie.Figure\ntradesticks!(\n    fig::Makie.Figure,\n    ai::Instances.AssetInstance,\n    tf;\n    from,\n    to,\n    force\n) -> Makie.Figure\n\n\nThis function plots trades on a figure for a given asset instance. It generates OHLCV data for trades, checks the size of the dataframe, prepares the figure for trade plotting, and creates triangles for IncreaseTrade and ReduceTrade. The function returns the figure.\n\n\n\n\n\n","category":"function"},{"location":"engine/live/#Running-in-Live-Mode","page":"Live","title":"Running in Live Mode","text":"","category":"section"},{"location":"engine/live/","page":"Live","title":"Live","text":"A strategy in live mode operates against the exchange API defined by the strategy. To construct the strategy, use the same methods as in paper mode.","category":"page"},{"location":"engine/live/","page":"Live","title":"Live","text":"using Strategies\ns = strategy(:Example, mode=Live(), sandbox=false) # The 'sandbox' parameter is passed to the strategy `ping!(::Type, ::Any, ::LoadStrategy)` function\nstart!(s, foreground=true)","category":"page"},{"location":"engine/live/#How-Live-Mode-Works","page":"Live","title":"How Live Mode Works","text":"","category":"section"},{"location":"engine/live/","page":"Live","title":"Live","text":"When you start live mode, pong! functions are forwarded to the exchange API to fulfill the request. We set up background tasks to ensure events update the local state in a timely manner. Specifically, we run:","category":"page"},{"location":"engine/live/","page":"Live","title":"Live","text":"A Watcher to monitor the balance. This runs in both spot (NoMarginStrategy) and derivatives (MarginStrategy). In the case of spot, the balance updates both the cash of the strategy's main currency and all the currencies in the strategy universe. For derivatives, it is used only to update the main currency.\nA Watcher to monitor positions when margin is used (MarginStrategy). The number of contracts of the open position represents the cash of the long/short Position in the AssetInstance (MarginInstance). This means that non-zero balances of a currency other than the strategy's main currency won't be considered.\nA long-running task that monitors all the order events of an asset. The task starts when a new order is requested and stops if there haven't been orders open for a while for the subject asset.\nA long-running task that monitors all trade events of an asset. This task starts and stops along with the order background task.","category":"page"},{"location":"engine/live/","page":"Live","title":"Live","text":"Similar to other modes, the return value of a pong! function for creating an order will be:","category":"page"},{"location":"engine/live/","page":"Live","title":"Live","text":"A Trade if a trade event was observed shortly after the order creation.\nmissing if the order was successfully created but not immediately executed.\nnothing if the order failed to be created, either because of local checks (e.g., not enough cash) or some other exchange error (e.g., API timeout).","category":"page"},{"location":"engine/live/#Timeouts","page":"Live","title":"Timeouts","text":"","category":"section"},{"location":"engine/live/","page":"Live","title":"Live","text":"If you don't want to wait for the order processing, you can pass a custom waitfor parameter which limits the amount of time we wait for API responses.","category":"page"},{"location":"engine/live/","page":"Live","title":"Live","text":"pong!(s, ai, MarketOrder{Buy}; synced=false, waitfor=Second(0)) # don't wait","category":"page"},{"location":"engine/live/","page":"Live","title":"Live","text":"The synced=true flag is a last-ditch attempt that force fetches updates from the exchange if no new events have been observed by the background tasks after the waiting period expires (default is true).","category":"page"},{"location":"engine/live/","page":"Live","title":"Live","text":"The local trades history might diverge from the data sourced from the exchange because not all exchanges support endpoints for fetching trades history or events, therefore trades are emulated from diffing order updates.","category":"page"},{"location":"engine/live/","page":"Live","title":"Live","text":"The local state is not persisted. Nothing is saved or loaded from storage. Instead, we sync the most recent history of orders with their respective trades when the strategy starts running. (This behavior might change in the future if need arises.)","category":"page"},{"location":"strategy/#Strategy-interface","page":"Strategies","title":"Strategy interface","text":"","category":"section"},{"location":"strategy/#Setup-a-new-strategy","page":"Strategies","title":"Setup a new strategy","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The simplest way to create a strategy is to use the interactive generator which will prompt  for the required set of options to set.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"julia> using PingPong\njulia> PingPong.generate_strategy()\nStrategy name: : MyNewStrategy\n\nTimeframe:\n   1m\n > 5m\n   15m\n   1h\n   1d\n\nSelect exchange by:\n > volume\n   markets\n   nokyc\n\n > binance\n   bitforex\n   okx\n   xt\n   coinbase\n\nQuote currency:\n   USDT\n   USDC\n > BTC\n   ETH\n   DOGE\n\nMargin mode:\n > NoMargin\n   Isolated\n\nActivate strategy project at /run/media/fra/stateful-1/dev/PingPong.jl/user/strategies/MyNewStrategy? [y]/n: y\n\nAdd project dependencies (comma separated): Indicators\n   Resolving package versions...\n   [...]\n  Activating project at `/run/media/fra/stateful-1/dev/PingPong.jl/user/strategies/MyNewStrategy`\n\n┌ Info: New Strategy\n│   name = \"MyNewStrategy\"\n│   exchange = :binance\n└   timeframe = \"5m\"\n[ Info: Config file updated\n\nLoad strategy? [y]/n: \n\njulia> s = ans","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"Alternatively you can directly pass kwargs and skip interaction by passing ask=false.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"PingPong.generate_strat(\"MyNewStrategy\", ask=false, exchange=:myexc)","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"or just use a config:","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"cfg = PingPong.Config(exchange=:myexc)\nPingPong.generate_strat(\"MyNewStrategy\", cfg)","category":"page"},{"location":"strategy/#Load-a-strategy","page":"Strategies","title":"Load a strategy","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The strategy is instantiated by loading a julia module at runtime.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"using PingPong\ncfg = Config(exchange=:kucoin) # Constructs a configuration object, choosing kucoin as exchange\ns = strategy(:Example, cfg) # Load the Example strategy","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The key is the name of the module (in this case Example) which will be imported from the included file \"cfg/strategies/Example.jl\" or \"cfg/strategies/Example/src/Example.jl\".","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"After the strategy module is imported the strategy is instantiated by calling the ping!(::Type{S}, ::LoadStrategy, cfg) function.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"> typeof(s)\nEngine.Strategies.Strategy37{:Example, ExchangeTypes.ExchangeID{:kucoin}(), :USDT}","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"See here how the load method is defined.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"module Example\nusing PingPong\n\nconst DESCRIPTION = \"Example\"\nconst EXC = :phemex\nconst MARGIN = NoMargin\nconst TF = tf\"1m\"\n\n@strategyenv!\n\nfunction ping!(::Type{<:SC}, ::LoadStrategy, config)\n    assets = marketsid(S)\n    s = Strategy(Example, assets; config)\n    s\nend\n\nend","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"See that the load method dispatches on the strategy type with cfg as argument of type Misc.Config.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"As a rule of thumb if the method should be called before the strategy is constructed, then it dispatches to the strategy type (Type{<:S}), otherwise the strategy instance (S). For convention the module property S of your strategy module, declares the strategy type (const S = Strategy{name, exc, ...}) and SC defines the same strategy type where the exchange is still generic.","category":"page"},{"location":"strategy/#Manual-setup","page":"Strategies","title":"Manual setup","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"If you want to create a strategy manually you can either:","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"Copy the user/strategies/Template.jl to a new file in the same directory and customize it.\nGenerate a new project in user/strategies and customize Template.jl to be your project entry file. The strategy Project.toml is used to store strategy config options. See other strategies examples for what the keys that are required.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"For more advanced setups you can also use PingPong as a library, and construct the strategy object directly from your own module:","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"using PingPong\nusing MyDownStreamModule\ns = PingPong.Engine.Strategies.strategy(MyDownStreamModule)","category":"page"},{"location":"strategy/#Strategy-interface-2","page":"Strategies","title":"Strategy interface","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"Both ping! and pong! functions adhere to a convention for function signatures. The first argument is always  either an instance of the subject or its type, followed by the arguments of the function, with the last non kw argument being the verb which describes the purpose of the function. KW arguments are optional and don't have any requirements. We can see below that Type{S} is the subject, config is an argument, and ::LoadStrategy is the _verb.","category":"page"},{"location":"strategy/#List-of-strategy-ping!-functions","page":"Strategies","title":"List of strategy ping! functions","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"Engine.Strategies.ping!","category":"page"},{"location":"strategy/#Misc.ping!","page":"Strategies","title":"Misc.ping!","text":"Called on each timestep iteration, possible multiple times. Receives:\n\ncurrent_time: the current timestamp to evaluate (the current candle would be current_time - timeframe).\nctx: The context of the executor.\n\nping!(\n    _::Strategies.Strategy,\n    current_time::Dates.DateTime,\n    ctx\n)\n\n\n\n\n\n\nCalled to construct the strategy, should return the strategy instance.\n\nping!(\n    _::Type{<:Strategies.Strategy},\n    cfg,\n    _::Strategies.LoadStrategy\n)\n\n\n\n\n\n\nCalled at the end of the reset! function applied to a strategy.\n\nping!(_::Strategies.Strategy, _::Strategies.ResetStrategy)\n\n\n\n\n\n\nHow much lookback data the strategy needs. \n\nping!(\n    s::Strategies.Strategy,\n    _::Strategies.WarmupPeriod\n) -> Any\n\n\n\n\n\n\nWhen an order is canceled the strategy is pinged with an order error. \n\nping!(\n    s::Strategies.Strategy,\n    ::OrderTypes.Order,\n    err::OrderTypes.OrderError,\n    ::Instances.AssetInstance;\n    kwargs...\n) -> Any\n\n\n\n\n\n\nMarket symbols that populate the strategy universe\n\n\n\n\n\nCalled before the strategy is started. \n\nping!(_::Strategies.Strategy, _::Strategies.StartStrategy)\n\n\n\n\n\n\nCalled after the strategy is stopped. \n\nping!(_::Strategies.Strategy, _::Strategies.StopStrategy)\n\n\n\n\n\n\nAfter a position was updated from a trade.\n\nping!(\n    _::Strategies.Strategy{X, N, <:ExchangeID, <:Misc.WithMargin, C} where {X<:Misc.ExecMode, N, C},\n    ai,\n    trade::OrderTypes.Trade,\n    _::Instances.Position,\n    _::Instances.PositionChange\n)\n\n\nThis function is called after a position is updated due to a trade. It takes in a MarginStrategy, ai, trade, Position, and PositionChange as arguments. The function does not return any value.\n\n\n\n\n\nAfter a position update from a candle.\n\nping!(\n    _::Strategies.Strategy{X, N, <:ExchangeID, <:Misc.WithMargin, C} where {X<:Misc.ExecMode, N, C},\n    ai,\n    date::Dates.DateTime,\n    _::Instances.Position,\n    _::Instances.PositionUpdate\n)\n\n\nThis function is called after a position is updated from a candle. It provides the necessary functionality for handling position updates in response to candle data.\n\n\n\n\n\nReturns Optimizations.ContextSpace for backtesting\n\nping!(_::Strategies.Strategy, _::Executors.OptSetup)\n\n\nThe ctx field (Executors.Context) specifies the backtest time period, while space is either an already built BlackBoxOptim.SearchSpace subtype or a tuple (Symbol, args...) for a pre-defined BBO package search space.\n\n\n\n\n\nApplies parameters to strategy before backtest\n\nping!(_::Strategies.Strategy, params, _::Executors.OptRun)\n\n\n\n\n\n\n","category":"function"},{"location":"strategy/#Removing-a-strategy","page":"Strategies","title":"Removing a strategy","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The function remove_strategy allows to discard a strategy by its name. It will delete the julia file or the project directory and optionally the config entry.","category":"page"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"julia> PingPong.remove_strategy(\"MyNewStrategy\")\nReally delete strategy located at /run/media/fra/stateful-1/dev/PingPong.jl/user/strategies/MyNewStrategy? [n]/y: y\n[ Info: Strategy removed\nRemove user config entry MyNewStrategy? [n]/y: y","category":"page"},{"location":"strategy/#Strategy-examples","page":"Strategies","title":"Strategy examples","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"Strategy examples can be found in the user/strategies folder, some strategies are single files like Example.jl while strategies like BollingerBands or ExampleMargin are project based.","category":"page"},{"location":"strategy/#Resizeable-universe","page":"Strategies","title":"Resizeable universe","text":"","category":"section"},{"location":"strategy/","page":"Strategies","title":"Strategies","text":"The universe (s.universe) is backed by a DataFrame (s.universe.data). It is possible to add and remove assets from the universe during runtime, (although not extensively tested).","category":"page"},{"location":"customizations/pong/#Adding-pong!-Functions","page":"Adding pong! Functions","title":"Adding pong! Functions","text":"","category":"section"},{"location":"customizations/pong/","page":"Adding pong! Functions","title":"Adding pong! Functions","text":"To introduce new pong! functions, adhere to the following procedure:","category":"page"},{"location":"customizations/pong/","page":"Adding pong! Functions","title":"Adding pong! Functions","text":"Traits Addition: Go to the Executors module, specifically the Executors/src/executors.jl file, and add your new trait. Ensure that you export the trait.\nFunction Implementation: Define the necessary functions in the {SimMode,PaperMode,LiveMode}/src/pong.jl files. If the behavior for paper and live mode is identical, use RTStrategy as a dispatch type and place the shared function definition in PaperMode/src/pong.jl.\nMacro Modification: In the PingPong/src/pingpong.jl file, modify the @strategyeng! macro (or the @contractsenv! macro for functions dealing with derivatives). Import your new trait, for example, using .pp.Engine.Executors: MyNewTrait.","category":"page"},{"location":"customizations/pong/","page":"Adding pong! Functions","title":"Adding pong! Functions","text":"Conform to the established argument order convention for the strategy signature:","category":"page"},{"location":"customizations/pong/","page":"Adding pong! Functions","title":"Adding pong! Functions","text":"function pong!(s::Strategy, [args...], ::MyNewTrade; kwargs...)\n    # Implement the function body here\nend","category":"page"},{"location":"customizations/pong/","page":"Adding pong! Functions","title":"Adding pong! Functions","text":"Follow these steps carefully to ensure the seamless integration of new pong! functions into the system.","category":"page"},{"location":"API/strategies/#Strategies","page":"Strategies","title":"Strategies","text":"","category":"section"},{"location":"API/strategies/","page":"Strategies","title":"Strategies","text":"Modules = [Engine.Strategies]","category":"page"},{"location":"API/strategies/#Strategies.STRATEGY_LOAD_CALLBACKS","page":"Strategies","title":"Strategies.STRATEGY_LOAD_CALLBACKS","text":"Functions that are called (with the strategy as argument) right after strategy construction.\n\n\n\n\n\n","category":"constant"},{"location":"API/strategies/#Core.Symbol-Tuple{Strategies.Strategy}","page":"Strategies","title":"Core.Symbol","text":"Symbol representation of the strategy (name of the module).\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.AbstractStrategy","page":"Strategies","title":"Strategies.AbstractStrategy","text":"The base type for all strategies.\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.BuyOrdersDict","page":"Strategies","title":"Strategies.BuyOrdersDict","text":"SortedDict of holding buy orders\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.BuyPriceTimeOrdering","page":"Strategies","title":"Strategies.BuyPriceTimeOrdering","text":"Ordering for buy orders (highest price first)\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.CrossStrategy","page":"Strategies","title":"Strategies.CrossStrategy","text":"Cross margin strategy.\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.ExchangeAsset","page":"Strategies","title":"Strategies.ExchangeAsset","text":"AssetInstance by ExchangeID\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.ExchangeBuyOrder","page":"Strategies","title":"Strategies.ExchangeBuyOrder","text":"BuyOrder by ExchangeID\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.ExchangeOrder","page":"Strategies","title":"Strategies.ExchangeOrder","text":"Order by ExchangeID\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.ExchangeSellOrder","page":"Strategies","title":"Strategies.ExchangeSellOrder","text":"SellOrder by ExchangeID\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.IsolatedStrategy","page":"Strategies","title":"Strategies.IsolatedStrategy","text":"Isolated margin strategy.\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.LiveStrategy","page":"Strategies","title":"Strategies.LiveStrategy","text":"Live trading strategy.\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.LoadStrategy","page":"Strategies","title":"Strategies.LoadStrategy","text":"ping!(s::Strategy, ::LoadStrategy)\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.MarginStrategy","page":"Strategies","title":"Strategies.MarginStrategy","text":"Strategy with isolated or cross margin.\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.NoMarginStrategy","page":"Strategies","title":"Strategies.NoMarginStrategy","text":"Strategy with no margin at all.\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.PaperStrategy","page":"Strategies","title":"Strategies.PaperStrategy","text":"Paper trading strategy.\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.PriceTime","page":"Strategies","title":"Strategies.PriceTime","text":"PriceTime named tuple\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.RTStrategy","page":"Strategies","title":"Strategies.RTStrategy","text":"Real time strategy (Paper, Live).\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.ResetStrategy","page":"Strategies","title":"Strategies.ResetStrategy","text":"ping!(s::Strategy, ::ResetStrategy)\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.SellOrdersDict","page":"Strategies","title":"Strategies.SellOrdersDict","text":"SortedDict of holding sell orders\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.SellPriceTimeOrdering","page":"Strategies","title":"Strategies.SellPriceTimeOrdering","text":"Ordering for sell orders (lowest price first)\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.SimStrategy","page":"Strategies","title":"Strategies.SimStrategy","text":"Simulation strategy.\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.StartStrategy","page":"Strategies","title":"Strategies.StartStrategy","text":"ping!(s::Strategy, ::StartStrategy)\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.StopStrategy","page":"Strategies","title":"Strategies.StopStrategy","text":"ping!(s::Strategy, ::StopStrategy)\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.Strategy","page":"Strategies","title":"Strategies.Strategy","text":"The strategy is the core type of the framework.\n\nself: The strategy module\nconfig: The Config the strategy was instantiated with\ntimeframe: The smallest timeframe the strategy uses\ncash: The quote currency used for trades\ncash_committed: Cash kept busy by pending orders\nbuyorders: Active buy orders\nsellorders: Active sell orders\nholdings: Assets with non zero balance\nuniverse: All the assets that the strategy knows about\nlock: A lock for thread safety\n\nThe strategy type is concrete according to:\n\nName (Symbol)\nExchange (ExchangeID), read from config\nQuote cash (Symbol), read from config\nMargin mode (MarginMode), read from config\nExecution mode (ExecMode), read from config\n\nConventions for strategy defined attributes:\n\nS: the strategy type.\nSC: the strategy type (exchange generic).\nTF: the smallest timeframe that the strategy uses\nDESCRIPTION: Name or short description for the strategy could be different from module name\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.Strategy-Tuple{Module, Misc.ExecMode, Misc.MarginMode, TimeFrames.TimeFrame, Exchange, Collections.AssetCollection}","page":"Strategies","title":"Strategies.Strategy","text":"Initializes a new Strategy object\n\nStrategy(\n    self::Module,\n    mode::Misc.ExecMode,\n    margin::Misc.MarginMode,\n    timeframe::TimeFrames.TimeFrame,\n    exc::Exchange,\n    uni::Collections.AssetCollection;\n    config\n)\n\n\nThis function takes a module, execution mode, margin mode, timeframe, exchange, and asset collection to create a new Strategy object.  It also accepts a config object to set specific parameters.  The function validates the universe of assets and the strategy's cash, sets the exchange, and initializes orders and holdings. \n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.StrategyMarkets","page":"Strategies","title":"Strategies.StrategyMarkets","text":"ping!(s::Strategy, ::StrategyMarkets)\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Strategies.WarmupPeriod","page":"Strategies","title":"Strategies.WarmupPeriod","text":"ping!(s::Strategy, ::WarmupPeriod)\n\n\n\n\n\n","category":"type"},{"location":"API/strategies/#Base.count-Tuple{Strategies.Strategy, Type{<:OrderTypes.OrderSide}}","page":"Strategies","title":"Base.count","text":"Counts the number of orders for a given order side in a strategy.\n\ncount(\n    s::Strategies.Strategy,\n    side::Type{<:OrderTypes.OrderSide}\n) -> Any\n\n\nThis function iterates over the orders of a given side (Buy or Sell) in a strategy. It increments a counter by the length of the orders. The function returns the total count of orders.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Base.fill!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Base.fill!","text":"Fills the strategy with the specified timeframes.\n\nfill!(\n    s::Strategies.Strategy;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\nThis function fills the strategy with the specified timeframes. It first creates a set of timeframes and adds the strategy's timeframe, the timeframes from the strategy's configuration, and the timeframe attribute of the strategy. It then fills the universe of the strategy with these timeframes.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Base.getproperty-Tuple{Strategies.Strategy, String}","page":"Strategies","title":"Base.getproperty","text":"Retrieves a property of a strategy using a string key.\n\ngetproperty(s::Strategies.Strategy, sym::String) -> Any\n\n\nThis function first gets the universe of the strategy and then retrieves the property using the string key.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Base.getproperty-Tuple{Strategies.Strategy, Symbol}","page":"Strategies","title":"Base.getproperty","text":"Retrieves a property of a strategy.\n\ngetproperty(s::Strategies.Strategy, sym::Symbol) -> Any\n\n\nThis function checks if the property is directly on the strategy or the strategy's configuration. If the property is not found, it checks the configuration's attributes.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Base.nameof-Tuple{Strategies.Strategy}","page":"Strategies","title":"Base.nameof","text":"The name of the strategy module.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Base.nameof-Union{Tuple{Type{<:Strategies.Strategy{<:Misc.ExecMode, N}}}, Tuple{N}} where N<:Symbol","page":"Strategies","title":"Base.nameof","text":"The name of the strategy module.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Base.similar-Tuple{Strategies.Strategy}","page":"Strategies","title":"Base.similar","text":"Creates a similar strategy with optional changes.\n\nsimilar(\n    s::Strategies.Strategy;\n    mode,\n    timeframe,\n    exc\n) -> Union{Strategies.Strategy{var\"#s178\", _A, _B, <:Misc.MarginMode{H}} where H<:Misc.HedgedMode, Strategies.Strategy{var\"#s178\", _A, _B, M} where {H<:Misc.HedgedMode, M<:Misc.MarginMode{H}}} where {var\"#s178\"<:Misc.ExecMode, _A, _B<:ExchangeID}\n\n\nThe similar function creates a new strategy that is similar to the given one. It allows for optional changes to the mode, timeframe, and exchange. The new strategy is created with the same self, margin mode, and universe as the original, but with a copy of the original's configuration.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Collections.iscashable-Tuple{Strategies.Strategy}","page":"Strategies","title":"Collections.iscashable","text":"Checks if the strategy's cash matches its universe.\n\niscashable(s::Strategies.Strategy) -> Bool\n\n\nThe iscashable function checks if the cash of the strategy is cashable within the universe of the strategy. It returns true if the cash is cashable, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Data.candleat-Tuple{Instances.AssetInstance, Any, Any}","page":"Strategies","title":"Data.candleat","text":"Get the candle for the asset at date with timeframe tf.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#ExchangeTypes.exchange-Tuple{Strategies.Strategy}","page":"Strategies","title":"ExchangeTypes.exchange","text":"Strategy exchange.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Exchanges.marketsid-Union{Tuple{Type{<:S}}, Tuple{S}} where S<:Strategies.Strategy","page":"Strategies","title":"Exchanges.marketsid","text":"Retrieves the market identifiers for a given strategy type.\n\nmarketsid(s::Type{<:S<:Strategies.Strategy}) -> Any\n\n\nThe marketsid function invokes the ping! function with the strategy type and StrategyMarkets() as arguments. This function is used to fetch the market identifiers associated with a specific strategy type.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Instruments.freecash-Tuple{Strategies.Strategy}","page":"Strategies","title":"Instruments.freecash","text":"Cash that is not committed, and therefore free to use for new orders.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.attrs-Tuple{Strategies.Strategy}","page":"Strategies","title":"Misc.attrs","text":"The strategy Config attributes.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.execmode-Union{Tuple{Union{Type{S}, S}}, Tuple{S}, Tuple{M}} where {M<:Misc.ExecMode, S<:(Strategies.Strategy{M})}","page":"Strategies","title":"Misc.execmode","text":"Returns the strategy execution mode.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.marginmode-Union{Tuple{Union{Type{<:T}, T}}, Tuple{T}, Tuple{M}} where {M<:Misc.MarginMode, T<:(Strategies.Strategy{X, N, E, M} where {X, N, E})}","page":"Strategies","title":"Misc.marginmode","text":"Get the strategy margin mode.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.ping!-Tuple{Strategies.Strategy, Dates.DateTime, Any}","page":"Strategies","title":"Misc.ping!","text":"Called on each timestep iteration, possible multiple times. Receives:\n\ncurrent_time: the current timestamp to evaluate (the current candle would be current_time - timeframe).\nctx: The context of the executor.\n\nping!(\n    _::Strategies.Strategy,\n    current_time::Dates.DateTime,\n    ctx\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.ping!-Tuple{Strategies.Strategy, OrderTypes.Order, OrderTypes.OrderError, Instances.AssetInstance}","page":"Strategies","title":"Misc.ping!","text":"When an order is canceled the strategy is pinged with an order error. \n\nping!(\n    s::Strategies.Strategy,\n    ::OrderTypes.Order,\n    err::OrderTypes.OrderError,\n    ::Instances.AssetInstance;\n    kwargs...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.ping!-Tuple{Strategies.Strategy, Strategies.ResetStrategy}","page":"Strategies","title":"Misc.ping!","text":"Called at the end of the reset! function applied to a strategy.\n\nping!(_::Strategies.Strategy, _::Strategies.ResetStrategy)\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.ping!-Tuple{Strategies.Strategy, Strategies.StartStrategy}","page":"Strategies","title":"Misc.ping!","text":"Called before the strategy is started. \n\nping!(_::Strategies.Strategy, _::Strategies.StartStrategy)\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.ping!-Tuple{Strategies.Strategy, Strategies.StopStrategy}","page":"Strategies","title":"Misc.ping!","text":"Called after the strategy is stopped. \n\nping!(_::Strategies.Strategy, _::Strategies.StopStrategy)\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.ping!-Tuple{Strategies.Strategy, Strategies.WarmupPeriod}","page":"Strategies","title":"Misc.ping!","text":"How much lookback data the strategy needs. \n\nping!(\n    s::Strategies.Strategy,\n    _::Strategies.WarmupPeriod\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.ping!-Tuple{Type{<:Strategies.Strategy}, Any, Strategies.LoadStrategy}","page":"Strategies","title":"Misc.ping!","text":"Called to construct the strategy, should return the strategy instance.\n\nping!(\n    _::Type{<:Strategies.Strategy},\n    cfg,\n    _::Strategies.LoadStrategy\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.ping!-Tuple{Type{<:Strategies.Strategy}, Strategies.StrategyMarkets}","page":"Strategies","title":"Misc.ping!","text":"Market symbols that populate the strategy universe\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Misc.reset!","page":"Strategies","title":"Misc.reset!","text":"Resets the state of a strategy.\n\nreset!(s::Strategies.Strategy)\nreset!(s::Strategies.Strategy, config)\n\n\nThe reset! function is used to reset the state of a given strategy. It empties the buy and sell orders, resets the holdings and assets, and optionally re-applies the strategy configuration defaults. If the strategy is currently running, the reset operation is aborted with a warning.\n\n\n\n\n\n","category":"function"},{"location":"API/strategies/#Strategies._assetval-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, Any, Any}","page":"Strategies","title":"Strategies._assetval","text":"Calculates the asset value for both long and short positions.\n\n_assetval(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    n_holdings,\n    min_hold,\n    max_hold;\n    price\n)\n\n\nThis function iterates over both long and short positions. If the asset instance for a position is not zero, it increments the number of holdings and calculates the value of the asset for the position at the current price. It then updates the minimum and maximum holdings using the _mmh function. The function returns the updated number of holdings, minimum holdings, and maximum holdings.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies._assetval-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, Any, Any, Any}","page":"Strategies","title":"Strategies._assetval","text":"Calculates the asset value for a NoMarginInstance.\n\n_assetval(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin},\n    n_holdings,\n    min_hold,\n    max_hold;\n    price\n)\n\n\nThis function checks if the cash of the NoMarginInstance is not zero. If it's not, it increments the number of holdings and calculates the value of the asset at the current price. It then updates the minimum and maximum holdings using the _mmh function. The function returns the updated number of holdings, minimum holdings, and maximum holdings.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies._defined_marginmode-Tuple{Any}","page":"Strategies","title":"Strategies._defined_marginmode","text":"Determines the margin mode of a module.\n\n_defined_marginmode(mod) -> Any\n\n\nThis function attempts to determine the margin mode of a given module. It first tries to access the S property of the module to get the margin mode. If this fails, it then tries to access the SC property of the module.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies._file-Tuple{Any, Any, Any}","page":"Strategies","title":"Strategies._file","text":"Determines the file path for a strategy source.\n\n_file(src, cfg, is_project) -> Any\n\n\nThis function determines the file path for a strategy source based on whether it is a project or not. If it is a project, it constructs the file path relative to the configuration path. If it is not a project, it retrieves the source file from the strategy's configuration or defaults to a predefined path. In case the file path is not found, it throws an ArgumentError with a detailed message.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies._include_projectless-Tuple{Any, Any}","page":"Strategies","title":"Strategies._include_projectless","text":"Retrieves the source file for a strategy without a project.\n\nThe _include_projectless function retrieves the source file for a strategy that does not have a project. It checks the sources attribute of the strategy's configuration.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies._mmh-NTuple{4, Any}","page":"Strategies","title":"Strategies._mmh","text":"Updates the minimum and maximum holdings based on the provided value.\n\n_mmh(ai, val, min_hold, max_hold) -> Tuple{Any, Any}\n\n\nGiven an asset instance, a value, and the current minimum and maximum holdings, this function updates the minimum and maximum holdings if the provided value is less than the current minimum or greater than the current maximum. It returns the updated minimum and maximum holdings.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies._no_inv_contracts-Tuple{Exchange, Any}","page":"Strategies","title":"Strategies._no_inv_contracts","text":"Checks for inverse contracts in an exchange.\n\n_no_inv_contracts(exc::Exchange, uni)\n\n\nThis function checks for the presence of inverse contracts in a given exchange. If any inverse contracts are found, it asserts an error.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies._strat_load_checks-Tuple{Strategies.Strategy, Misc.Config}","page":"Strategies","title":"Strategies._strat_load_checks","text":"Performs checks on a loaded strategy.\n\n_strat_load_checks(\n    s::Strategies.Strategy,\n    config::Misc.Config\n) -> Strategies.Strategy\n\n\nThis function performs checks on a loaded strategy. It asserts that the margin mode and execution mode of the strategy match the configuration. It also sets the verbose property of the strategy to false.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies._strategy_config-Tuple{Any, Any}","page":"Strategies","title":"Strategies._strategy_config","text":"Determines the configuration for a strategy.\n\n_strategy_config(src, path; load, config_args...)\n\n\nThis function determines the configuration for a strategy based on the source and path. If the strategy is to be loaded, it attempts to load the strategy cache. If the cache does not exist or is not a valid configuration, it creates a new configuration.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies._strategy_type-Tuple{Any, Any}","page":"Strategies","title":"Strategies._strategy_type","text":"Determines the strategy type of a module.\n\n_strategy_type(mod, cfg) -> Any\n\n\nThis function determines the strategy type of a given module. It first tries to access the S property of the module to get the strategy type. If this fails, it then tries to access the SC property of the module. The function also checks if the exchange is specified in the strategy or in the configuration.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.asset_bysym-Tuple{Strategies.Strategy, Any}","page":"Strategies","title":"Strategies.asset_bysym","text":"Retrieves an asset instance by symbol.\n\nasset_bysym(s::Strategies.Strategy, sym) -> Any\n\n\nThis function retrieves an asset instance by symbol sym from a strategy s. It first checks if the asset instance is already cached in the strategy's attributes. If not, it retrieves the asset instance from the strategy's universe. If the asset instance is not found, it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.assets-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.assets","text":"Assets loaded by the strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.bare_load-Tuple{Module, Type, Misc.Config}","page":"Strategies","title":"Strategies.bare_load","text":"Loads a strategy without default settings.\n\nbare_load(\n    mod::Module,\n    t::Type,\n    config::Misc.Config\n) -> Union{Strategies.Strategy{var\"#s178\", _A, _B, <:Misc.MarginMode{H}} where H<:Misc.HedgedMode, Strategies.Strategy{var\"#s178\", _A, _B, M} where {H<:Misc.HedgedMode, M<:Misc.MarginMode{H}}} where {var\"#s178\"<:Misc.ExecMode, _A, _B<:ExchangeID}\n\n\nThis function loads a strategy without default settings. It invokes the ping! function of the module with the strategy type and StrategyMarkets(). It then creates a new Strategy instance with the module, assets, and configuration. The sandbox property is set based on the mode of the configuration. Finally, it performs checks on the loaded strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.current_total","page":"Strategies","title":"Strategies.current_total","text":"Calculates the total value of a MarginStrategy with Paper.\n\ncurrent_total(\n    s::Strategies.Strategy{Misc.Paper, N, <:ExchangeID, <:Misc.WithMargin, C} where {N, C};\n    ...\n) -> Any\ncurrent_total(\n    s::Strategies.Strategy{Misc.Paper, N, <:ExchangeID, <:Misc.WithMargin, C} where {N, C},\n    price_func;\n    kwargs...\n) -> Any\n\n\nThis function calculates the total value of a MarginStrategy{Paper} by summing up the value of all holdings and cash. The value of each holding is calculated using a provided price function. The default price function used is lasttrade_price_func, which returns the closing price of the last trade.\n\n\n\n\n\n","category":"function"},{"location":"API/strategies/#Strategies.current_total-Tuple{Strategies.SimStrategy{N, <:ExchangeID, <:Misc.WithMargin, C} where {N, C}}","page":"Strategies","title":"Strategies.current_total","text":"Calculates the total value of a MarginStrategy.\n\ncurrent_total(\n    s::Strategies.SimStrategy{N, <:ExchangeID, <:Misc.WithMargin, C} where {N, C};\n    price_func,\n    kwargs...\n) -> Any\n\n\nThis function calculates the total value of a MarginStrategy by summing up the value of all holdings and cash. The value of each holding is calculated using a provided price function. The default price function used is lasttrade_price_func, which returns the closing price of the last trade.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.current_total-Tuple{Strategies.SimStrategy{N, <:ExchangeID, NoMargin, C} where {N, C}}","page":"Strategies","title":"Strategies.current_total","text":"Calculates the total value of a NoMarginStrategy.\n\ncurrent_total(\n    s::Strategies.SimStrategy{N, <:ExchangeID, NoMargin, C} where {N, C};\n    price_func,\n    kwargs...\n) -> Any\n\n\nThis function calculates the total value of a NoMarginStrategy by summing up the value of all holdings and cash. The value of each holding is calculated using a provided price function. The default price function used is lasttrade_price_func, which returns the closing price of the last trade.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.current_total-Tuple{Strategies.Strategy{Misc.Paper, N, <:ExchangeID, NoMargin, C} where {N, C}}","page":"Strategies","title":"Strategies.current_total","text":"Calculates the total value of a NoMarginStrategy with Paper.\n\ncurrent_total(\n    s::Strategies.Strategy{Misc.Paper, N, <:ExchangeID, NoMargin, C} where {N, C};\n    price_func,\n    kwargs...\n) -> Any\n\n\nThis function calculates the total value of a NoMarginStrategy{Paper} by summing up the value of all holdings and cash. The value of each holding is calculated using a provided price function. The default price function used is lasttrade_price_func, which returns the closing price of the last trade.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.default!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.default!","text":"Set strategy defaults.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.default_load-Tuple{Module, Type, Misc.Config}","page":"Strategies","title":"Strategies.default_load","text":"Loads a strategy with default settings.\n\ndefault_load(\n    mod::Module,\n    t::Type,\n    config::Misc.Config\n) -> Union{Strategies.Strategy{var\"#s178\", _A, _B, <:Misc.MarginMode{H}} where H<:Misc.HedgedMode, Strategies.Strategy{var\"#s178\", _A, _B, M} where {H<:Misc.HedgedMode, M<:Misc.MarginMode{H}}} where {var\"#s178\"<:Misc.ExecMode, _A, _B<:ExchangeID}\n\n\nThis function loads a strategy with default settings. It invokes the ping! function of the module with the strategy type and StrategyMarkets(). It then creates a new Strategy instance with the module, assets, and configuration. The sandbox property is set based on the mode of the configuration. Finally, it performs checks on the loaded strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.find_path-Tuple{Any, Any}","page":"Strategies","title":"Strategies.find_path","text":"Finds the path of a given file.\n\nfind_path(file, cfg) -> Any\n\n\nThe find_path function checks various locations to find the path of a given file. It checks the current working directory, user directory, configuration directory, and project directory. If the file is not found, it raises an error.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.instances-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.instances","text":"Strategy assets instance.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.lasttrade_date","page":"Strategies","title":"Strategies.lasttrade_date","text":"Returns the date of the last trade for an asset instance.\n\nlasttrade_date(ai) -> Any\nlasttrade_date(ai, def) -> Any\n\n\nThis function returns the date of the last trade for an AssetInstance. If the history of the asset instance is empty, it returns the timestamp of the last candle.\n\n\n\n\n\n","category":"function"},{"location":"API/strategies/#Strategies.lasttrade_func-Tuple{Any}","page":"Strategies","title":"Strategies.lasttrade_func","text":"Returns a function for the last trade date of a strategy.\n\nlasttrade_func(s) -> Union{typeof(last), Returns}\n\n\nThis function returns a function that, when called, gives the date of the last trade for a Strategy. If there is no last trade, it returns the last function.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.lasttrade_price_func-Tuple{Any}","page":"Strategies","title":"Strategies.lasttrade_price_func","text":"The asset close price of the candle where the last trade was performed.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.logpath-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.logpath","text":"Generates the path for strategy logs.\n\nlogpath(\n    s::Strategies.Strategy;\n    name,\n    path_nodes...\n) -> String\n\n\nThe logpath function generates a path for storing strategy logs. It takes the strategy and optional parameters for the name of the log file and additional path nodes. The function checks if the directory for the logs exists and creates it if necessary. It then returns the full path to the log file.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.logs-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.logs","text":"Retrieves the logs for a strategy.\n\nlogs(s::Strategies.Strategy) -> Vector{Any}\n\n\nThe logs function collects and returns all the logs associated with a given strategy. It fetches the logs from the directory specified in the strategy's path.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.minmax_holdings-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.minmax_holdings","text":"Calculates the minimum and maximum holdings for a strategy.\n\nminmax_holdings(\n    s::Strategies.Strategy\n) -> NamedTuple{(:min, :max, :count), <:Tuple{Tuple{Any, Any}, Tuple{Any, Any}, Int64}}\n\n\nThis function iterates over the holdings of a strategy. For each holding, it calculates the current price and updates the number of holdings, minimum holdings, and maximum holdings using the _assetval function. The function returns the minimum holdings, maximum holdings, and the count of holdings.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.reload!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.reload!","text":"Reloads OHLCV data for assets in the strategy universe.\n\nreload!(s::Strategies.Strategy)\n\n\nThe reload! function empties the data for each asset instance in the strategy's universe and then loads new data. This is useful for refreshing the strategy's knowledge of the market state.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.save_strategy-Tuple{Any}","page":"Strategies","title":"Strategies.save_strategy","text":"Saves the state of a strategy.\n\nsave_strategy(s)\n\n\nThis function saves the state of a given strategy. It determines the cache path and saves the strategy state to this path.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.sizehint!-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.sizehint!","text":"Keeps track of max allocated containers size for strategy and asset instances in the universe.\n\nsizehint!(s::Strategies.Strategy)\n\n\nThis function keeps track of the maximum allocated containers size for strategy and asset instances in the universe. It updates the sizes of various containers based on the current state of the strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.strategy","page":"Strategies","title":"Strategies.strategy","text":"Loads a strategy from a source, module, or string.\n\nstrategy(src::Union{Module, String, Symbol}; ...) -> Any\nstrategy(\n    src::Union{Module, String, Symbol},\n    path::String;\n    load,\n    config_args...\n) -> Any\n\n\nThis function loads a strategy from a given source, module, or string. It first determines the configuration for the strategy based on the source and path. If the strategy is to be loaded, it attempts to load the strategy cache. Finally, it returns the loaded strategy.\n\n\n\n\n\n","category":"function"},{"location":"API/strategies/#Strategies.strategy!-Tuple{Module, Misc.Config}","page":"Strategies","title":"Strategies.strategy!","text":"Loads a strategy from a module.\n\nstrategy!(mod::Module, cfg::Misc.Config) -> Any\n\n\nThis function loads a strategy from a given module. It first checks and sets the mode and margin of the configuration if they are not set. It then determines the strategy type of the module and checks if the exchange is specified in the strategy or in the configuration. Finally, it tries to load the strategy with default settings, if it fails, it loads the strategy without default settings.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.strategy!-Tuple{Symbol, Misc.Config}","page":"Strategies","title":"Strategies.strategy!","text":"Loads a strategy from a symbol source.\n\nstrategy!(src::Symbol, cfg::Misc.Config) -> Any\n\n\nThis function loads a strategy from a given symbol source. It first determines the file path for the strategy source and checks if it is a project. If it is a project, it activates and instantiates the project. The function then includes the source file and uses it. If the source file is not defined in the parent module, it is evaluated and tracked for changes. Finally, the function returns the loaded strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.strategy-Tuple{}","page":"Strategies","title":"Strategies.strategy","text":"Returns the default strategy (BareStrat). \n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.strategy_cache_path-Tuple{}","page":"Strategies","title":"Strategies.strategy_cache_path","text":"Returns the path to the strategy cache.\n\nstrategy_cache_path() -> String\n\n\nThis function returns the path to the strategy cache. It checks if the path exists and creates it if it doesn't.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.throttle-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.throttle","text":"The throttle attribute determines the strategy polling interval.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.trades_count-Tuple{Strategies.Strategy, Val{:liquidations}}","page":"Strategies","title":"Strategies.trades_count","text":"Counts all trades recorded in the strategy universe.\n\ntrades_count(\n    s::Strategies.Strategy,\n    _::Val{:liquidations}\n) -> NamedTuple{(:trades, :liquidations), <:Tuple{Any, Any}}\n\n\nThis function iterates over the universe of a strategy. For each asset instance in the universe, it increments a counter by the length of the asset instance's history. The function returns the total count of trades.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.trades_count-Tuple{Strategies.Strategy, Val{:positions}}","page":"Strategies","title":"Strategies.trades_count","text":"Counts the number of long, short, and liquidation trades in the strategy universe.\n\ntrades_count(\n    s::Strategies.Strategy,\n    _::Val{:positions}\n) -> NamedTuple{(:long, :short, :liquidations), <:Tuple{Any, Any, Any}}\n\n\nThis function iterates over the universe of a strategy. For each asset instance in the universe, it counts the number of long trades, short trades, and liquidation trades. The function returns the total count of long trades, short trades, and liquidation trades.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.trades_count-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.trades_count","text":"All trades recorded in the strategy universe (includes liquidations).\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.tradesedge-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.tradesedge","text":"Returns the first and last trade of any asset in the strategy universe.\n\ntradesedge(s::Strategies.Strategy) -> Tuple{Any, Any}\n\n\nThis function returns the first and last trade of any asset in the strategy universe for a given Strategy. If there are no trades, it returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.tradesedge-Tuple{Type{Dates.DateTime}, Strategies.Strategy}","page":"Strategies","title":"Strategies.tradesedge","text":"Returns the dates of the first and last trade present in the strategy.\n\ntradesedge(\n    _::Type{Dates.DateTime},\n    s::Strategies.Strategy\n) -> Tuple{Any, Any}\n\n\nThis function returns the dates of the first and last trade of any asset in the strategy universe for a given Strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.tradesperiod-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.tradesperiod","text":"Returns the recorded trading period from the trades history present in the strategy.\n\ntradesperiod(s::Strategies.Strategy) -> Any\n\n\nThis function returns the recorded trading period from the trades history present in the strategy. It calculates the period by subtracting the start date from the stop date.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.tradesrange","page":"Strategies","title":"Strategies.tradesrange","text":"Returns a DateRange spanning the historical time period of the trades recorded by the strategy.\n\ntradesrange(\n    s::Strategies.Strategy;\n    ...\n) -> TimeTicks.DateRange\ntradesrange(\n    s::Strategies.Strategy,\n    tf;\n    start_pad,\n    stop_pad\n) -> TimeTicks.DateRange\n\n\nThis function returns a DateRange that spans the historical time period of the trades recorded by the strategy. It calculates the range by adding the start and stop pads to the edges of the trades.\n\n\n\n\n\n","category":"function"},{"location":"API/strategies/#Strategies.universe-Tuple{Strategies.Strategy}","page":"Strategies","title":"Strategies.universe","text":"The strategy AssetCollection.\n\n\n\n\n\n","category":"method"},{"location":"API/strategies/#Strategies.@define_candle_func-Tuple{Any}","page":"Strategies","title":"Strategies.@define_candle_func","text":"Defines a set of functions for a given candle function.\n\nThis macro generates two functions for each candle function passed to it. The first function is for getting the candle data from an AssetInstance at a specific date. The second function is for getting the candle data from a Strategy at a specific date with a specified timeframe. The timeframe defaults to the strategy's timeframe if not provided.\n\n\n\n\n\n","category":"macro"},{"location":"API/strategies/#Strategies.@interface-Tuple{}","page":"Strategies","title":"Strategies.@interface","text":"Provides a common interface for strategy execution.\n\nThe interface macro imports the ping! function from the Strategies module, the assets and exchange functions, and the pong! function from the Executors module. This macro is used to provide a common interface for strategy execution.\n\n\n\n\n\n","category":"macro"},{"location":"API/strategies/#Strategies.@notfound-Tuple{Any}","page":"Strategies","title":"Strategies.@notfound","text":"Raises an error when a strategy is not found at a given path.  \n\n\n\n\n\n","category":"macro"},{"location":"API/stats/#Stats","page":"Stats","title":"Stats","text":"","category":"section"},{"location":"API/stats/","page":"Stats","title":"Stats","text":"Modules = [Stats]","category":"page"},{"location":"API/stats/#Stats.METRICS","page":"Stats","title":"Stats.METRICS","text":"All the metrics that supported.\n\n\n\n\n\n","category":"constant"},{"location":"API/stats/#Stats.TradesTuple","page":"Stats","title":"Stats.TradesTuple","text":"A NamedTuple representing trade data, including date, amount, price, value, fees, fees_base, size, leverage, entryprice, and order.\n\n\n\n\n\n","category":"type"},{"location":"API/stats/#Stats._annualize-Tuple{Any, Any}","page":"Stats","title":"Stats._annualize","text":"Annualizes a volatility value.\n\n_annualize(v, tf)\n\n\nThis function takes a volatility value v and a timeframe tf as parameters. It multiplies v by the square root of the ratio of the number of days in a year times the period of tf to the period of a day. This effectively converts v from a volatility per tf period to an annual volatility.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._basebalance-NTuple{8, Any}","page":"Stats","title":"Stats._basebalance","text":"Calculates the base balance for a given order.\n\n_basebalance(\n    o,\n    ai,\n    entryprice,\n    amount,\n    leverage,\n    price,\n    _,\n    _\n) -> Any\n\n\nThis function takes an order o, an AssetInstance ai, entryprice, amount, leverage, and price as parameters. If o is missing, the function returns nothing. Otherwise, it calculates the value as the product of amount and price, and the fees based on the value and the maximum fees for ai and o. The function then returns the earned amount based on o, entryprice, amount, leverage, price, value, and fees. This essentially adds the earned amount to the base balance. TODO: add fees in base curr to balance calc\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._basebalance-Tuple{OrderTypes.ReduceOrder, Vararg{Any, 7}}","page":"Stats","title":"Stats._basebalance","text":"Calculates the negative of the earned amount for a ReduceOrder.\n\n_basebalance(\n    o::OrderTypes.ReduceOrder,\n    _,\n    entryprice,\n    amount,\n    leverage,\n    price,\n    value,\n    fees\n) -> Any\n\n\nThis function is specifically designed for ReduceOrder instances.  It calculates the earned amount based on the order's entryprice, amount, leverage, price, value, and fees, and then returns the negative of this amount. This essentially subtracts the earned amount from the base balance.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._cum_value_balance-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any}","page":"Stats","title":"Stats._cum_value_balance","text":"Calculates the cumulative value balance for a MarginInstance.\n\n_cum_value_balance(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    df\n) -> Any\n\n\nThis function takes a MarginInstance ai and a DataFrame df as parameters.  It defines a helper function cvb that calculates the value of an order based on various parameters,  and updates some variables (last_lev, last_ep, last_side) with the details of the last non-missing order.\n\nThe function then applies cvb to each order in df, along with the corresponding ai, entryprice, cum_base, leverage, and close values from df. The earned amounts for each order are returned as a vector.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._earned-NTuple{7, Any}","page":"Stats","title":"Stats._earned","text":"Calculates the earned amount in a trade considering entryprice, amount, leverage, price, and fees.\n\n_earned(\n    o,\n    entryprice,\n    amount,\n    leverage,\n    price,\n    _,\n    fees\n) -> Any\n\n\nThe function computes the earned amount as the absolute value of the product of entryprice and amount divided by leverage, plus the profit and loss (pnl) calculated from the entryprice, price, amount, and the position side of the order, minus fees.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._rawcalmar-Tuple{Any}","page":"Stats","title":"Stats._rawcalmar","text":"Computes the non-annualized Calmar ratio.\n\n_rawcalmar(returns; tf) -> Any\n\n\nCalculates the Calmar ratio given an array of returns. The ratio is the annual return divided by the maximum drawdown. tf specifies the timeframe for the returns and defaults to one day.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._rawexpectancy-Tuple{Any}","page":"Stats","title":"Stats._rawexpectancy","text":"Computes the trading expectancy.\n\n_rawexpectancy(returns) -> Any\n\n\nCalculates the trading expectancy given an array of returns. This is a measure of the mean value of both winning and losing trades. It takes into account both the probability and the average win/loss of trades.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._rawsharpe-Tuple{Any}","page":"Stats","title":"Stats._rawsharpe","text":"Computes the non-annualized Sharpe ratio.\n\n_rawsharpe(returns; rfr, tf) -> Any\n\n\nCalculates the Sharpe ratio given an array of returns. The ratio is computed as the excess of the mean return over the risk-free rate rfr, divided by the standard deviation of the returns. tf specifies the timeframe for the returns and defaults to one day.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._rawsortino-Tuple{Any}","page":"Stats","title":"Stats._rawsortino","text":"Computes the non-annualized Sortino ratio.\n\n_rawsortino(returns; rfr, tf) -> Any\n\n\nCalculates the Sortino ratio given an array of returns. The ratio is the excess of the mean return over the risk-free rate rfr, divided by the standard deviation of the negative returns. tf specifies the timeframe for the returns and defaults to one day.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._returns_arr-Tuple{Any}","page":"Stats","title":"Stats._returns_arr","text":"Calculates the simple returns for an array of prices.\n\n_returns_arr(arr)\n\n\nThis function takes an array of prices arr as a parameter, calculates the differences between successive prices, divides each difference by the corresponding previous price, and returns the resulting array of simple returns. Please note that the first element of the return array would be NaN due to the lack of a previous price for the first element in arr.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._spent-NTuple{7, Any}","page":"Stats","title":"Stats._spent","text":"Calculates the spent amount in a trade considering leverage, value and fees.\n\n_spent(_, _, _, leverage, _, value, fees) -> Any\n\n\nThe function calculates the spent amount as the value divided by leverage plus fees, and returns the negative absolute value of this amount.  An assertion ensures that the calculated value is non-negative before negation.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._tradesdf","page":"Stats","title":"Stats._tradesdf","text":"Retrieves trades from an AssetInstance within a specified range and transforms them into a DataFrame.\n\n_tradesdf(\n    ai::Instances.AssetInstance\n) -> Union{Nothing, DataFrames.DataFrame}\n_tradesdf(\n    ai::Instances.AssetInstance,\n    from\n) -> Union{Nothing, DataFrames.DataFrame}\n_tradesdf(\n    ai::Instances.AssetInstance,\n    from,\n    to\n) -> Union{Nothing, DataFrames.DataFrame}\n\n\nThe function retrieves trades within this range and then transforms them into a DataFrame using the _tradesdf() function.\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats._tradesdf-Tuple{AbstractVector}","page":"Stats","title":"Stats._tradesdf","text":"Transforms an AbstractVector of trades into a DataFrame.\n\n_tradesdf(trades::AbstractVector) -> DataFrames.DataFrame\n\n\nThe function creates an empty DataFrame from TradesTuple and appends the trades. Afterwards, it renames the :date column to :timestamp.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._valueat-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Vararg{Any, 5}}","page":"Stats","title":"Stats._valueat","text":"Calculates the value of a position at a given timestamp.\n\n_valueat(\n    ai,\n    cum_amount,\n    timestamp,\n    leverage,\n    entryprice,\n    pos\n)\n\n\nThis function takes a MarginInstance ai, a cum_amount, a timestamp, a leverage, an entryprice, and a position pos as parameters. It first calculates the closing price at the given timestamp, the value of the position based on the cumulative amount and the closing price, and the fees based on this value. It then returns the earned amount based on these values, using the _earned function.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats._valueat-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, Any, Any, Vararg{Any}}","page":"Stats","title":"Stats._valueat","text":"Calculates the value of a position at a given timestamp for a NoMarginInstance.\n\n_valueat(ai, cum_amount, timestamp, args)\n\n\nThis function takes a NoMarginInstance ai, a cum_amount, and a timestamp as parameters, along with any number of additional arguments. It calculates the value of the position as the product of the cumulative amount and the closing price at the given timestamp, and returns this value. Note: For a NoMarginInstance, leverage is not considered, hence the value is directly dependent on the cumulative amount and the closing price.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.applytimeframe!-Tuple{Any, Any}","page":"Stats","title":"Stats.applytimeframe!","text":"Applies a given timeframe to the timestamps in a DataFrame.\n\napplytimeframe!(df, tf) -> Any\n\n\nThis function removes the sample column from the DataFrame df and applies the tf timeframe to the timestamp column.  The DataFrame is then returned with the updated timestamps.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.aroundtrades-Tuple{Any, Any}","page":"Stats","title":"Stats.aroundtrades","text":"Provides trade data for a given asset instance around a specified timeframe.\n\naroundtrades(ai, tf)\n\n\nIt calculates a start and a stop date based on the dates of the first and last trades in the AssetInstance history and the specified timeframe. It then extracts the OHLCV data for the AssetInstance within this date range, and resamples this data to the specified timeframe. The resultant resampled DataFrame is returned.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.bydate-Tuple{Any, Any, Vararg{Any}}","page":"Stats","title":"Stats.bydate","text":"Groups trade data by date and other specified tags.\n\nbydate(\n    data,\n    tf,\n    tags...;\n    sort\n) -> DataFrames.GroupedDataFrame\n\n\nThe function converts timestamps in data to a suitable format based on tf and then groups the data by the specified tags and the converted timestamps.  The sort parameter determines whether the resulting grouped data should be sorted or not.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.cagr","page":"Stats","title":"Stats.cagr","text":"Computes the Compound Annual Growth Rate (CAGR) for a given strategy.\n\ncagr(s::Strategies.Strategy) -> Any\ncagr(s::Strategies.Strategy, prd::Dates.Period) -> Any\ncagr(\n    s::Strategies.Strategy,\n    prd::Dates.Period,\n    initial\n) -> Any\ncagr(\n    s::Strategies.Strategy,\n    prd::Dates.Period,\n    initial,\n    price_func\n) -> Any\n\n\nCalculates the CAGR for a Strategy s over a specified Period prd, defaulting to the period of the strategy's trades. The initial cash amount initial and the pricing function price_func can also be specified.\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.calmar","page":"Stats","title":"Stats.calmar","text":"Computes the Calmar ratio for a given strategy.\n\ncalmar(s::Strategies.Strategy) -> Any\ncalmar(s::Strategies.Strategy, tf) -> Any\n\n\nCalculates the Calmar ratio for a Strategy s over a specified timeframe tf, defaulting to one day.\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.entryexit-Tuple{Any}","page":"Stats","title":"Stats.entryexit","text":"Counts the number of entries and exits in a trade.\n\nentryexit(\n    g\n) -> NamedTuple{(:entries, :exits), <:Tuple{Any, Any}}\n\n\nThe function takes a trade as input, counts the number of entries (negative values) and exits (positive values) and returns a tuple with these counts.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.expand","page":"Stats","title":"Stats.expand","text":"Expands a DataFrame to include all timestamps in a range.\n\nexpand(df) -> Any\nexpand(df, tf) -> Any\n\n\nThis function takes a DataFrame df and an optional timeframe tf (which defaults to the timeframe of df). It creates a new DataFrame that includes all timestamps within the range of df and the given timeframe, and then joins this new DataFrame with df using an outer join on the timestamp column. The resulting DataFrame is then sorted by timestamp.\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.expectancy","page":"Stats","title":"Stats.expectancy","text":"Computes the trading expectancy for a given strategy.\n\nexpectancy(s::Strategies.Strategy) -> Any\nexpectancy(s::Strategies.Strategy, tf) -> Any\n\n\nCalculates the trading expectancy for a Strategy s over a specified timeframe tf, defaulting to one day.\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.ffill!","page":"Stats","title":"Stats.ffill!","text":"Forward fills missing values in a vector.\n\nffill!(v)\nffill!(v, out)\n\n\nThis function takes a vector v and an optional output vector out (which defaults to v itself). It starts with the first value in v (which must not be missing) and applies the coalesce function to each subsequent pair of values in v and out. The coalesce function replaces each missing value in v with the corresponding value from out. The function then returns out with the filled missing values. This is effectively a forward fill operation, carrying the most recent non-missing value forward to replace missing values.\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.isincreaseorder-Tuple{O} where O<:(OrderTypes.IncreaseOrder)","page":"Stats","title":"Stats.isincreaseorder","text":"Checks if an Order is an IncreaseOrder.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.isreduceorder-Tuple{O} where O<:(OrderTypes.ReduceOrder)","page":"Stats","title":"Stats.isreduceorder","text":"Checks if an Order is a ReduceOrder.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.maxdd-Tuple{Any}","page":"Stats","title":"Stats.maxdd","text":"Computes the maximum drawdown for a series of returns.\n\nmaxdd(\n    returns\n) -> NamedTuple{(:dd, :ath, :cum_returns), <:Tuple{Any, Any, Any}}\n\n\nCalculates the maximum drawdown given an array of returns. The drawdown is the largest percentage drop in the cumulative product of 1 plus the returns.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.multi-Tuple{Strategies.Strategy, Vararg{Symbol}}","page":"Stats","title":"Stats.multi","text":"Returns a dict of calculated metrics for a given strategy.\n\nmulti(\n    s::Strategies.Strategy,\n    metrics::Symbol...;\n    tf,\n    normalize,\n    norm_max\n) -> Any\n\n\nFor a Strategy s, calculates specified metrics over a specified timeframe tf, defaulting to one day. If normalize is true, the metrics are normalized with respect to norm_max.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.normalize_metric","page":"Stats","title":"Stats.normalize_metric","text":"Normalize a metric. Based on the value of max. \n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.resample_trades","page":"Stats","title":"Stats.resample_trades","text":"Aggregates all trades of a strategy in a single dataframe\n\nresample_trades(s::Strategies.Strategy; ...) -> Any\nresample_trades(\n    s::Strategies.Strategy,\n    tf;\n    style,\n    byinstance,\n    custom,\n    expand_dates\n) -> Any\n\n\nbyinstance: (trades_df, ai) -> nothing can modify the dataframe of a single instance before it is appended to the full df. style: :full or :minimal specifies what columns should be aggregated in the resampled df custom: similar to style but instead allows you to define custom aggregation rules (according to DataFrame) expand_dates: returns a contiguous dataframe from the first trade date to the last (inserting default ohlcv rows where no trades have happened.)\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.resample_trades-Tuple{Instances.AssetInstance, Any}","page":"Stats","title":"Stats.resample_trades","text":"Resamples trades data from a smaller to a higher timeframe.\n\nresample_trades(\n    ai::Instances.AssetInstance,\n    to_tf;\n    style,\n    custom\n) -> Any\n\n\nThis function takes an AssetInstance and a target timeframe to_tf as parameters, as well as optional style and custom parameters for additional customization. It extracts the trades data from the AssetInstance and resamples it to the target timeframe.  Volume adjustments are made based on the margin mode of the AssetInstance. The data is then grouped by date, transformed according to the margin mode, style, and custom parameters, and combined into a new DataFrame.  Finally, the target timeframe is applied to the timestamps in the DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.sharpe","page":"Stats","title":"Stats.sharpe","text":"Computes the Sharpe ratio for a given strategy.\n\nsharpe(s::Strategies.Strategy; ...) -> Any\nsharpe(s::Strategies.Strategy, tf; rfr) -> Any\n\n\nCalculates the Sharpe ratio for a Strategy s over a specified timeframe tf, defaulting to one day. The risk-free rate rfr can be specified, and defaults to 0.0.\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.sortino","page":"Stats","title":"Stats.sortino","text":"Computes the Sortino ratio for a given strategy.\n\nsortino(s::Strategies.Strategy; ...) -> Any\nsortino(s::Strategies.Strategy, tf; rfr) -> Any\n\n\nCalculates the Sortino ratio for a Strategy s over a specified timeframe tf, defaulting to one day. The risk-free rate rfr can be specified, and defaults to 0.0.\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.trades_balance","page":"Stats","title":"Stats.trades_balance","text":"Plots the trade history for all the assets in a strategy.\n\ntrades_balance(s; ...)\ntrades_balance(s, tf, args; return_all, byasset, kwargs...)\n\n\nreturn_all[true]: similar to the function for single assets, plus:\n\ncum_quote: the balance of cash for each timestamp\ncum_value_balance: the balance of all held assets in quote currency for each timestamp.\n\nbyasset[false]: also return a column that tracks the value balance by asset for each timestamp normalize_timeframes:\n\n\n\n\n\n","category":"function"},{"location":"API/stats/#Stats.trades_balance-Tuple{Instances.AssetInstance}","page":"Stats","title":"Stats.trades_balance","text":"Replays the trade history of a single asset instance.\n\ntrades_balance(\n    ai::Instances.AssetInstance;\n    tf,\n    return_all,\n    df,\n    initial_cash\n) -> Any\n\n\nreturn_all: if true returns a dataframe where:\n\nbase/quote_balance the volume generated by the trades that happened at that timestamp.\n:cum_total represents the total balance held for each timestamp.\n:cum_value_balance represents the value in quote currency of the asset for each timestamp.\n\nwarning: For single assets only\nIf your strategy trades multiple assets the profits returned by this function won't match the strategy actual holdings since calculation are done only w.r.t this single asset.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.trades_duration-Tuple{Instances.AssetInstance}","page":"Stats","title":"Stats.trades_duration","text":"Computes the average duration of trades for an asset instance.\n\ntrades_duration(ai::Instances.AssetInstance; raw, f) -> Any\n\n\nCalculates the average duration between trades for an AssetInstance ai. The raw parameter determines whether the result should be in raw format (in milliseconds) or a compact time format. The function f is used to aggregate the durations and defaults to the mean.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.trades_duration-Tuple{Strategies.Strategy}","page":"Stats","title":"Stats.trades_duration","text":"Computes the average duration of trades for a strategy.\n\ntrades_duration(s::Strategies.Strategy; f) -> Any\n\n\nCalculates the average duration between trades for a Strategy s. The function f is used to aggregate the durations and defaults to the mean.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.trades_hour-Tuple{Instances.AssetInstance}","page":"Stats","title":"Stats.trades_hour","text":"Computes the average hour of trades for an asset instance.\n\ntrades_hour(ai::Instances.AssetInstance; f) -> Any\n\n\nCalculates the average hour of trades for an AssetInstance ai. The function f is used to aggregate the hours and defaults to the mean.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.trades_leverage-Tuple{Instances.AssetInstance}","page":"Stats","title":"Stats.trades_leverage","text":"Computes the average leverage for trades of an asset instance.\n\ntrades_leverage(ai::Instances.AssetInstance; f) -> Any\n\n\nCalculates the average leverage of trades for an AssetInstance ai. The function f is used to aggregate the leverages and defaults to the mean.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.trades_monthday-Tuple{Instances.AssetInstance}","page":"Stats","title":"Stats.trades_monthday","text":"Computes the average day of the month for trades of an asset instance.\n\ntrades_monthday(ai::Instances.AssetInstance; f) -> Any\n\n\nCalculates the average day of the month for trades for an AssetInstance ai. The function f is used to aggregate the days and defaults to the mean.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.trades_size-Tuple{Instances.AssetInstance}","page":"Stats","title":"Stats.trades_size","text":"Computes the average trade size for an asset instance.\n\ntrades_size(ai::Instances.AssetInstance; f) -> Any\n\n\nCalculates the average size of trades for an AssetInstance ai. The function f is used to aggregate the sizes and defaults to the mean.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.trades_size-Tuple{Strategies.Strategy}","page":"Stats","title":"Stats.trades_size","text":"Computes the average trade size for a strategy.\n\ntrades_size(s::Strategies.Strategy; f) -> Any\n\n\nCalculates the average size of trades for a Strategy s. The function f is used to aggregate the sizes and defaults to the mean.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.trades_weekday-Tuple{Instances.AssetInstance}","page":"Stats","title":"Stats.trades_weekday","text":"Computes the average weekday of trades for an asset instance.\n\ntrades_weekday(ai::Instances.AssetInstance; f) -> Any\n\n\nCalculates the average weekday of trades for an AssetInstance ai. The function f is used to aggregate the weekdays and defaults to the mean.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.tradesvolume!-Tuple{Misc.WithMargin, Any}","page":"Stats","title":"Stats.tradesvolume!","text":"Entries subtract quote currency, Exits subtract base currency.\n\ntradesvolume!(_::Misc.WithMargin, data) -> Any\n\n\nThis function adjusts the volume of trades in the WithMargin mode.  It assigns size to quote_volume and amount to base_volume in the data.  It then modifies these volumes based on whether each order in data is an increase order or not.  For non-increase orders, base_volume is made non-positive and quote_volume is made non-negative.  For increase orders, base_volume is made non-negative and quote_volume is made non-positive.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.tradesvolume!-Tuple{NoMargin, Any}","page":"Stats","title":"Stats.tradesvolume!","text":"Buys subtract quote currency, while sells subtract base currency.\n\ntradesvolume!(_::NoMargin, data)\n\n\nThis function adjusts the volume of trades in the NoMargin mode. It assigns size to quote_volume and amount to base_volume in the data. In debug mode, it asserts that all sell orders have non-positive base volume and non-negative quote volume, and all buy orders have non-negative base volume and non-positive quote volume.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.transforms-Tuple{Misc.MarginMode, Any, Any}","page":"Stats","title":"Stats.transforms","text":"Applies custom transformations based on margin mode, style, and custom parameters.\n\ntransforms(m::Misc.MarginMode, style, custom) -> Vector{Any}\n\n\nDepending on the provided MarginMode, style and custom parameters, this function applies different transformations to the data. The customization allows for flexibility in data processing and analysis.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.zeromissing!-Tuple{Any}","page":"Stats","title":"Stats.zeromissing!","text":"Replaces missing values in a vector with 0.0.\n\nzeromissing!(v)\n\n\nThis function iterates over each index of the vector v.  If the value at a given index is missing, it replaces it with 0.0.  The vector v is then returned with the replaced values.\n\n\n\n\n\n","category":"method"},{"location":"API/stats/#Stats.@balance_arr-Tuple{}","page":"Stats","title":"Stats.@balance_arr","text":"Generates code to calculate the cumulative total balance for a given set of trades over a given timeframe.\n\nThis macro generates code that calculates the cumulative total balance for a given set of trades s over a given timeframe tf. It first gets a DataFrame of balances for s and tf using the trades_balance function. If this DataFrame is nothing (which means there are no trades), it immediately returns -Inf. Otherwise, it extracts the cum_total column from the DataFrame, which represents the cumulative total balance, and assigns this to balance. The generated code is then returned.\n\n\n\n\n\n","category":"macro"},{"location":"#What-is-PingPong?","page":"What is PingPong?","title":"What is PingPong?","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"PingPong is a bot for running automated trading strategies. It allows for interactive experimentation of new strategies through the julia REPL, and their live deployment to trading exchanges with almost zero code replication.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"The bot is based around the concept of strategies. A strategy requires a primary currency which represents its balance and a primary exchange where all the orders will be forwarded (and against which they will be checked for validity).","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Writing a pingpong strategy is equivalent to writing a julia module, that the bot will load (either dynamically or statically on deployments). Within the module you import the pingpong interface, such that you can specialize ping! entry functions relative only to your strategy, the rest is up to you.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"The framework provides a long list of convenience or utility functions to manipulate the strategy and assets objects defined in different modules. In fact the bot is quite modular and is made of almost 30 packages, even though the majority of them is required to actually run the bot.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"From the strategy you can manage orders through pong! functions and expect them to be executed during simulation and live trading (through the CCXT library, and other venues in a possible future) while returning the same data structures even if populated through different means.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"The advantage of PingPong over trading bots written in other programming languages is its flexibility thanks to the julia parametric type system that allows to extend the bot by specializing functions to perform ad hoc logic. An exchange is behaving differently compared to others? You can specialize the balance function over only that particular exchange by defining:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"balance(exc::Exchange{:MyQuirkyExchange}, args...) ... end","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"where :MyQuirkyExchange is the ExchangeID symbol of the exchange you are targeting. ","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"This is how strategy ping! functions also dispatch, because the strategies always have in their type parameters the Symbol which matches the module of the strategy itself. Indeed you cannot define multiple strategies with the same name. And it is also how we are able to have almost zero code duplication between simulation and live trading, the execution mode is just another type parameter of the strategy.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"The bot has tools to download, clean and store data, that make use of popular julia libraries. See Data, and tools to resample time series see Processing.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"It can:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"track live data like tickers, trades, ohlcv, see Watchers.\ncompute statistics about backtest runs, see Stats\ngenerate interactive and fully browsable plots for ohlcv data, indicators and backtesting runs, see Plotting\nOptimize strategy parameters Optimization","category":"page"},{"location":"#Install-(docker)","page":"What is PingPong?","title":"Install (docker)","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Recommended installation is through docker. There are 4 images:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":" precompiled 🧰 sysimage 📦\nonly runtime 🖥‍ pingpong-precomp pingpong-sysimage\nwith plotting and optimizer 📊 pingpong-precomp-interactive pingpong-sysimage-interactive","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"# Precompiled images are smaller, more flexible but have a slower startup. Compiled images are bigger, there might be unexpected issues, but are faster to startup.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"docker pull docker.io/panifie/pingpong-precomp\ndocker run -it --rm docker.io/panifie/pingpong-precomp julia\nusing PingPong # or PingPongInteractive for plotting and optimization","category":"page"},{"location":"#Install-(git)","page":"What is PingPong?","title":"Install (git)","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"PingPong.jl requires at least Julia 1.9. Is not in the julia registry, to install it do the following:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Clone the repository:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"git clone --recurse-submodules https://github.com/panifie/PingPong.jl","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Check the env vars in .envrc, then enabled them with direnv allow.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"cd PingPong.jl\ndirenv allow","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Activate the project specified by JULIA_PROJECT in the .envrc.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"julia ","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Download and build dependencies:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"] instantiate\nusing PingPong  # or PingPongInteractive for plotting and optimization","category":"page"},{"location":"#Quickstart","page":"What is PingPong?","title":"Quickstart","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Load the default strategy, which you can look up at ./user/strategies/SimpleStrategy/ or make your own.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"using PingPong\n\n@environment! # brings modules in scope\n# arguments override defaults (see `s.config` fields)\ns = strategy(:SimpleStrategy, exchange=:binance) ","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Download some data:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"# download last 1000 candles from strategy exchange\nfetch_ohlcv(s, from=-1000) ","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Load the data into the strategy universe:","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"load_ohlcv(s)","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Backtest the strategy within the period available from the loaded data.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"start!(s)","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Plot the simulated trades.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"using Plotting\nusing WGLMakie # or `GLMakie`\nplots!() # or `Pkg.activate(\"PingPongInteractive\"); using PingPongInteractive`\nballoons(s)","category":"page"},{"location":"#Packages","page":"What is PingPong?","title":"Packages","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"The most relevant underlying PingPong modules.","category":"page"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Engine: The actual backtest engine.\nStrategies: Types and concept for building strategies.\nExchanges: Loads exchanges instances, markets and pairlists, based on ccxt.\nPlotting: Output plots for ohlcv data, indicators, backtests, based on Makie.\nRemote Control the bot remotely.\nData: Loading and saving ohlcv data (and more), based Zarr.\nStats: Statistics about backtests, and live operations.\nProcessing: Data cleanup, normalization, resampling functions.\nWatchers: Services for data pipelines, from sources to storage.\nMisc: Ancillary stuff, like configuration, and some UI bits.\nAnalysis: The bulk of indicators evaluation, depends of a bunch of (heavy) julia libraries like CausalityTools and Indicators. Most of the package is implemented through optional deps such that you only import what you need.","category":"page"},{"location":"#Infos","page":"What is PingPong?","title":"Infos","text":"","category":"section"},{"location":"","page":"What is PingPong?","title":"What is PingPong?","text":"Troubleshooting\nDevdocs\nContacts","category":"page"},{"location":"customizations/backtest/#High-Frequency-Trading-(HFT)-Backtesting-Documentation","page":"Backtester","title":"High-Frequency Trading (HFT) Backtesting Documentation","text":"","category":"section"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"The SimMode class, also known as the pingpong backtester, utilizes Open-High-Low-Close-Volume (OHLCV) data to simulate the execution of trades.","category":"page"},{"location":"customizations/backtest/#Reasons-to-Avoid-Tick-by-Tick-Backtesting","page":"Backtester","title":"Reasons to Avoid Tick-by-Tick Backtesting","text":"","category":"section"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"Tick-by-tick backtesting may not be ideal due to several factors:","category":"page"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"Data Availability: Bid/ask tick data is often difficult to obtain and can be extremely voluminous, leading to increased resource consumption.\nData Reconstruction: Attempting to reconstruct order book data from trade history is speculative and can introduce significant bias.\nOverfitting Risks: High-detail backtesting can cause strategies to overfit to specific market maker behaviors, resulting in additional bias.\nComputational Costs: Intensive data and computational requirements may limit backtesting to a short time frame, insufficient for evaluating performance through different market conditions.","category":"page"},{"location":"customizations/backtest/#Implementing-HFT-Backtesting","page":"Backtester","title":"Implementing HFT Backtesting","text":"","category":"section"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"Should you decide to implement HFT backtesting, consider the following two approaches:","category":"page"},{"location":"customizations/backtest/#OHLCV-Based-Approach","page":"Backtester","title":"OHLCV-Based Approach","text":"","category":"section"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"A simpler method involves using the OHLCV model with extremely short-duration candles, such as 1s candles. The backtester processes time steps, typically using the strategy's base timeframe. By selecting a 1s timeframe and supplying the corresponding candles, you can achieve the desired time resolution for your backtest.","category":"page"},{"location":"customizations/backtest/#Tick-Based-Approach","page":"Backtester","title":"Tick-Based Approach","text":"","category":"section"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"A more complex method requires developing a new execution mode, which could be named TickSimMode. This involves adapting the backtest! function to handle tick data. While order creation logic may remain largely unchanged, functions like volumeat(ai, date) or openat, closeat, which currently fetch candle data, need to be modified. These functions should be tailored to compute the trade's actual price and volume from the tick data. This is analogous to customizing functions such as limitorder_ifprice! to work with tick data.\nIf you have access to full trades history, then you can reconstruct the orderbook (not implemented), and then the execution logic of PaperMode can be repurposed for the tick based backtester because it already operates with orderbook data.","category":"page"},{"location":"customizations/backtest/","page":"Backtester","title":"Backtester","text":"`example  Example of setting up a 1-second OHLCV backtest  Note Actual implementation details will vary based on your specific backtesting framework SimMode backtester = new SimMode(1s) backtesterloadData(pathto1s_candle_datacsv) backtesterrun() `","category":"page"},{"location":"types/#Types","page":"Types","title":"Types","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"By learning the main types you get to know the building blocks to start composing your strategy for backtesting and/or live trading.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"The main type is the Strategy and it has its own page. Other important types follow.","category":"page"},{"location":"types/#Instruments","page":"Types","title":"Instruments","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Asset and Derivative are implementations of the AbstractAsset abstract type, defined in the Instruments package. They are usually obtained after parsing a string. Assets are typically spot pairs of base and quote currency, while Derivatives can be either swaps or contracts with settlement dates. These are \"static\" structures that do not query real-time data. The only information they hold is what can be parsed from the string itself.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"raw: The parsed substring.\nbc: Base currency.\nqc: Quote currency.\nfiat: true if the pair involves stable currencies, which is a static list defined in Instruments.fiatnames.\nleveraged: true if the base currency is a leveraged token, which is a type of token that usually involves periodic rebalancing. This should be considered as additional information and may be unreliable, as there is no standard for naming such assets.\nunleveraged_bc: If the pair is leveraged, this field returns the base currency without the \"multiplier\", allowing you to find similar markets of the same currency.","category":"page"},{"location":"types/#Derivatives-only-fields","page":"Types","title":"Derivatives only fields","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"asset: The simpler Asset type, which forwards all its fields.\nsc: The settlement currency.\nid: A string that usually represents the settlement date.\nstrike: The strike price of the contract.\nkind: If it is an option, either Call or Put; otherwise, Unkn (unknown).","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Asset can be conveniently constructed from the REPL using a\"BTC/USDT\" or d\"BTC/USDT:USDT\" for Derivatives.","category":"page"},{"location":"types/#Asset-instances","page":"Types","title":"Asset instances","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"The AssetInstance is a rich type that refers to a particular asset. It is not parametrized over a specific asset, but rather over the AbstractAsset implementation, the exchange, and the margin mode. An asset instance's information is always related to a specific exchange. For example, cash(ai) should return the amount of cash available for that asset on the exchange matching the instance's ExchangeID parameter.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Here are the properties of the AssetInstance:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"asset: The underlying implementation of AbstractAsset.\ndata: A SortedDict (smallest to largest) of OHLCV data. The key is a TimeFrame, and the value is a DataFrame with columns: timestamp, high, open, low, close, and volume.\nhistory: The trade history of the asset.\ncash: The amount of owned cash.\ncash_committed: The total amount of cash used by pending orders.\nexchange: The exchange of this asset instance.\nlongpos/shortpos: The Positions when the margin mode is activated. committed/cash refers to the position cash within margin trading.\nlimits/precision: See ccxt.\nfees: The trading fees as a decimal percentage for takers or makers.","category":"page"},{"location":"types/#Positions","page":"Types","title":"Positions","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"When trading with margin, asset instances manage the status of long or short positions. In NotHedged mode (the default), you can only have either a long or short position open at any given time. Positions cash and cash_committed replace the asset instance's own fields.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"The following are the fields of the position struct:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"status: Represents the current status of the position, which can be either open (PositionOpen()) or closed (PositionClose()).\nasset: Represents the derivative inherited from the asset instance.\ntimestamp: Indicates the last time the position was updated, such as when leverage, margin, or position size was modified.\nliquidation_price: Represents the price that would trigger a liquidation event.\nentryprice: Represents the average price of entry for the position.\nmaintenance_margin: Specifies the minimum margin required to avoid liquidation, measured in the quote currency.\ninitial_margin: Specifies the minimum margin required to open the position.\nadditional_margin: Represents the margin added on top of the initial margin.\nnotional: Indicates the value of the position with respect to the current price.\ncash/cash_committed: Represents the amount of cash held, which should always be equal to the number of contracts multiplied by the contract size.\nleverage: Specifies the leverage factor for the position.\nmin_size: Represents the same value as limits.cost.min of the asset instance.\nhedged: Indicates whether the margin mode is hedged (true) or not (false).\ntiers: Refers to a LeverageTiersDict defined in the Exchanges module. It is parsed from ccxt and is required to fetch the correct maintenance margin rate based on the position size.\nthis_tier: Represents the current tier of the position, which is updated when the notional value changes.","category":"page"},{"location":"types/#Orders","page":"Types","title":"Orders","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Order types parameters are:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"OrderType{<:OrderSide}: The order type is an abstract type with the OrderSide parameter which can be Buy, Sell, or rarely Both. An OrderType can be, for example, a LimitOrderType or a MarketOrderType. These types are themselves supertypes for more specific orders like FOKOrderType and GTCOrderType. Creating order instances parametrized with different kinds should produce different behavior in order execution.\nAbstractAsset, ExchangeID: same as asset instances, orders refer to a kind of asset on a specific exchange.\nPositionSide: either Long or Short, the order refers to either a long or short position. Once the order is filled, its amount will be added to the cash of the matching position.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Orders have mostly simple data fields:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"asset: the AbstractAsset implementation that refers to it\nexc: the ExchangeID of the matching exchange\ndate: the date the order was opened\nprice: the target price of the order, for market orders, this would be the last price before the order was opened.\namount: the total amount requested by the order\nattrs: An unspecified named tuple that is used to hold custom data specific to order types.","category":"page"},{"location":"types/#Trades","page":"Types","title":"Trades","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"Trades are \"atomic\" events. Orders are composed of one or more trades. They have the same type parameters as the orders. A trade for a specific order matches its exact type parameters.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"order: The order to which this trade belongs.\ndate: The execution date of the trade.\namount: The sum of the amounts of all the trades performed by an order is always below or equal to the order amount.\nprice: The price can differ from the order price depending on whether the order is a limit or market order.\nvalue: The product of the price and amount.\nfees: The fees of the trade, in the quote currency. They can be positive or negative (they are favorable if negative).\nsize: The product of the price and amount, plus or minus the fees.\nleverage: The leverage that was used for the order and with which the trade was executed. We currently do not allow changing the leverage while there are open orders. Therefore, trades that belong to the same order should have the same leverage. Without margin, the leverage should always be equal to 1.0.","category":"page"},{"location":"types/#Dates","page":"Types","title":"Dates","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"The Julia main Dates package is never imported directly. It is instead exported by the package TimeTicks, which, among many utility functions, overrides the now function to always use the UTC timezone.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"A very important type is the TimeFrame type, which defines a segment of time. Most of the time, the concrete type of a TimeFrame will be a time period (Dates.Period).","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"For convenience, timeframes can be constructed using the tf\"1m\" notation for a 1-minute timeframe. This notation can be freely used because, by using the macro, the timeframe is replaced at compile time. Moreover, construction is cached and the instances are singletons (@assert tf\"1m\" === tf\"1m\"). Parsing is also cached, but only by calling convert(TimeFrame, v) or timeframe(v), and it incurs only the lookup cost (~500ns).","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Parsing is done to match the timeframe naming used within CCTX, and the time period used should be expected to be in Millisecond.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Dates can also be constructed within the repl using the dt prefix. For example, dt\"2020-\" will create a DateTime value for the date 2020-01-01T00:00:00. We also implement a DateRange, which is used to keep track of the time between two dates, and it also works as an iterator when the step field (Period) is defined. Date ranges can be conveniently created using the prefix dtr. For example, dtr\"2020-..2021-\" will construct a daterange for the full year 2020. You can specify the date precision up to the second as specified by the standard, like dtr\"2020-01-01T:00:00:01..2021-01-01T00:00:01\".","category":"page"},{"location":"types/#OHLCV","page":"Types","title":"OHLCV","text":"","category":"section"},{"location":"types/","page":"Types","title":"Types","text":"We use the DataFrames package, so when we refer to OHLCV data, there is a DataFrame involved. Within the Data package, there are multiple utility functions to deal with OHLCV data. Some of these functions include:","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"ohlcv/at(df, date): This function allows you to get the value of a column at a particular index by date. For example, you can use closeat(df, date) to fetch the close value at a specific date.\ndf[dt\"2020-01-01\", :close]: This syntax allows you to directly fetch the close value at the nearest matching date by using the dt prefix.\ndf[dtr\"2020-..2021-\"]: This syntax allows you to slice the dataframe for the rows within a specific date range using the dtr prefix.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Additionally, there are utility functions for guessing the timeframe of an OHLCV dataframe by looking at the difference between timestamps. You can use the timeframe!(df) function to set the \"timeframe\" key on the metadata of the timestamp column of the dataframe.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"Please make sure this documentation is up to date. Check if it lists all the public fields of the struct and remove any sentences that mention functions that do not exist. Also, fix any spelling, grammar, and syntax errors.","category":"page"},{"location":"types/","page":"Types","title":"Types","text":"info: Numbered types\nSome types have a number at the end, you can just ignore it, eventually it will be removed.","category":"page"},{"location":"API/misc/#Misc","page":"Misc","title":"Misc","text":"","category":"section"},{"location":"API/misc/","page":"Misc","title":"Misc","text":"Modules = [PingPong.Misc]","category":"page"},{"location":"API/misc/#Misc.ATOL","page":"Misc","title":"Misc.ATOL","text":"The margin of error to use [2eps].\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.Iterable","page":"Misc","title":"Misc.Iterable","text":"An union of iterable types.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.WithMargin","page":"Misc","title":"Misc.WithMargin","text":"Any margin mode.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.ZERO","page":"Misc","title":"Misc.ZERO","text":"Static zero(DFT)\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.config","page":"Misc","title":"Misc.config","text":"Global configuration instance.\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.fetch_limits","page":"Misc","title":"Misc.fetch_limits","text":"Exchange ohlcv candles limits.\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.futures_exchange","page":"Misc","title":"Misc.futures_exchange","text":"Some exchanges are split into different classes in ccxt.\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.results","page":"Misc","title":"Misc.results","text":"Holds recently evaluated statements.\n\n\n\n\n\n","category":"constant"},{"location":"API/misc/#Misc.Config","page":"Misc","title":"Misc.Config","text":"Creates a Config object from a profile and path.\n\nConfig(profile::Union{Module, String, Symbol}; ...) -> Any\nConfig(\n    profile::Union{Module, String, Symbol},\n    path::String;\n    hasentry,\n    kwargs...\n) -> Any\n\n\nThis function creates a Config object using the provided profile and path. The profile can be a Symbol, Module, or String representing a specific configuration setup or a user/project profile. If hasentry is true, it also checks for an entry point.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.Config-2","page":"Misc","title":"Misc.Config","text":"Strategy config.\n\npath: File path that loaded this config.\nmode: Execution mode (Sim, Paper, Live)\nexchange: A symbol to instantiate an exchange (a raw ExchangeID symbol)\nsandbox: Exchange sandbox mode flag\nqc: The quote currency for the strategy cash.\nmargin: Configures the margin mode of the strategy (NoMargin, Isolated or Cross)\nleverage: The default leverage that should be used when opening position with margin mode.\nmin_vol: A minimum acceptable volume, e.g. for filtering markets.\ninitial_cash: Starting cash, used when instantiating a strategy.\nmin_size: Default order size.\nmin_timeframe: The default (shortest) timeframe of the candles.\ntimeframes: Vector of sorted timeframes that the strategy uses (for loading data).\nwindow: The default number of candles (OHLCV).\nsources: Mapping of modules symbols name to (.jl) file paths\nattrs: Generic metadata container.\ntoml: Raw toml that instantiated this config.\ndefaults\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.ContiguityException","page":"Misc","title":"Misc.ContiguityException","text":"An exception that is thrown when the data stored ends before the new data starts (or vice versa).\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.Cross","page":"Misc","title":"Misc.Cross","text":"NotHedged CrossMargin mode.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.CrossHedged","page":"Misc","title":"Misc.CrossHedged","text":"Hedged CrossMargin mode.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.CrossMargin","page":"Misc","title":"Misc.CrossMargin","text":"Cross margin mode handles margin across all assets (NOT IMPLEMENTED).\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.DFT","page":"Misc","title":"Misc.DFT","text":"The floating point number type to use.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.ExecAction","page":"Misc","title":"Misc.ExecAction","text":"An ExecAction is any holy trait singleton used to dispatch ping! and pong! functions.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.ExecMode","page":"Misc","title":"Misc.ExecMode","text":"ExecMode is one of Sim, Paper, Live.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.Hedged","page":"Misc","title":"Misc.Hedged","text":"Hedged implies both short and long positions can be held.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.HedgedMode","page":"Misc","title":"Misc.HedgedMode","text":"HedgedMode is one of Hedged, NotHedged.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.Isolated","page":"Misc","title":"Misc.Isolated","text":"NotHedged IsolatedMargin mode.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.IsolatedHedged","page":"Misc","title":"Misc.IsolatedHedged","text":"Hedged IsolatedMargin mode.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.IsolatedMargin","page":"Misc","title":"Misc.IsolatedMargin","text":"Isolated margin mode handles margin for each asset separately.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.LeftContiguityException","page":"Misc","title":"Misc.LeftContiguityException","text":"An exception that is thrown when the data stored starts before the new data ends.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.Live","page":"Misc","title":"Misc.Live","text":"Live execution.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.Long","page":"Misc","title":"Misc.Long","text":"Long position side.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.MM","page":"Misc","title":"Misc.MM","text":"Min, max named tuple\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.MarginMode","page":"Misc","title":"Misc.MarginMode","text":"Margin mode is one of Isolated, Cross, NoMargin.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.NoMargin","page":"Misc","title":"Misc.NoMargin","text":"No margin mode, margin handling is disabled (usually in simple spot markets).\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.NotHedged","page":"Misc","title":"Misc.NotHedged","text":"NotHedged implies only one position side can be held.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.Paper","page":"Misc","title":"Misc.Paper","text":"Paper execution.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.PositionSide","page":"Misc","title":"Misc.PositionSide","text":"Position side is one of Long, Short.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.RightContiguityException","page":"Misc","title":"Misc.RightContiguityException","text":"An exception that is thrown when the data stored ends before the new data starts.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.Short","page":"Misc","title":"Misc.Short","text":"Short position side.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.Sim","page":"Misc","title":"Misc.Sim","text":"Simulated execution.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.TaskFlag","page":"Misc","title":"Misc.TaskFlag","text":"Used to indicate that a task is still running.\n\nf: The function that indicates that the task is still running (returns a Bool).\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Misc.TaskFlag-Tuple{}","page":"Misc","title":"Misc.TaskFlag","text":"The default task flag\n\nUses the task local storage to communicate if the task is still running.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.UniqueIterator","page":"Misc","title":"Misc.UniqueIterator","text":"Returns an iterator that yields unique elements from an iterable.\n\n\n\n\n\n","category":"type"},{"location":"API/misc/#Base.copy-Tuple{Misc.Config}","page":"Misc","title":"Base.copy","text":"Creates a (shallow) copy of the Config object.\n\ncopy(c::Misc.Config) -> Any\n\n\nThis function returns a new Config object that is a copy of the given Config object c.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc._find_module-Tuple{Any}","page":"Misc","title":"Misc._find_module","text":"Finds the module corresponding to a given symbol.\n\n_find_module(sym) -> Any\n\n\nThis function takes a symbol sym and attempts to find the corresponding module in the loaded modules.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc._instantiate_workers-Tuple{Any}","page":"Misc","title":"Misc._instantiate_workers","text":"Instantiates worker processes for a given module.\n\n_instantiate_workers(\n    mod;\n    force,\n    num\n) -> Union{Nothing, Int64}\n\n\nThis function takes a module mod and optionally a boolean force and an integer num. It spawns num worker processes for mod. If force is true, it first kills any existing worker processes for mod.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc._options!-Tuple{Any, Any}","page":"Misc","title":"Misc._options!","text":"Sets the options in cfg based on provided name.\n\n_options!(cfg, name) -> Any\n\n\nThis function iterates over the options defined in the cfg object's TOML and sets each option according to the values provided under the given name.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc._path!-Tuple{Any, Any}","page":"Misc","title":"Misc._path!","text":"Sets the path in cfg if the file exists.\n\n_path!(cfg, path) -> Any\n\n\nThis function sets the path field of the cfg object to the provided path if a file exists at that location.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc._sources!-Tuple{Any, Any}","page":"Misc","title":"Misc._sources!","text":"Sets the sources in cfg based on provided name.\n\n_sources!(cfg, name)\n\n\nThis function iterates over the sources defined in the cfg object's TOML and sets each source according to the values provided under the given name.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc._toml!-Tuple{Any, Any}","page":"Misc","title":"Misc._toml!","text":"Sets the TOML config in cfg if the file exists.\n\n_toml!(cfg, name; check)\n\n\nThis function sets the toml field of the cfg object to the parsed contents of a TOML file with the provided name, if the file exists.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.after-Tuple{AbstractVector, Any}","page":"Misc","title":"Misc.after","text":"Returns a view of the vector after a specified value.\n\nafter(v::AbstractVector, d; kwargs...) -> Any\n\n\nThis function returns a view of the vector v starting from the position after the first occurrence of d. The behavior can be adjusted using keyword arguments passed to rangeafter.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.approxzero-Tuple{T} where T","page":"Misc","title":"Misc.approxzero","text":"Checks if a value is approximately zero.\n\napproxzero(v; atol) -> Any\n\n\nThis function takes a value v and a tolerance atol. It returns true if the absolute difference between v and zero is less than or equal to atol, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.attr!-Tuple{Any, Any, Any}","page":"Misc","title":"Misc.attr!","text":"Get k from the attrs field of the input object, or v if k is not present, setting k to v.\n\nattr!(d, k, v) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.attr-Tuple{Any, Any, Any}","page":"Misc","title":"Misc.attr","text":"Get k from the attrs field of the input object, or v if k is not present.\n\nattr(d, k, v) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.attr-Tuple{Any, Any}","page":"Misc","title":"Misc.attr","text":"Get k from the attrs field of the input object.\n\nattr(d, k) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.attrs-Tuple{Any, Vararg{Any}}","page":"Misc","title":"Misc.attrs","text":"Get all keys... from the attrs field of the input object.\n\nattrs(d, keys...) -> Dict{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.attrs-Tuple{Any}","page":"Misc","title":"Misc.attrs","text":"Get the attrs field of the input object.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.before-Tuple{AbstractVector, Any}","page":"Misc","title":"Misc.before","text":"Complement of after.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.between-Tuple{AbstractVector, Any, Any}","page":"Misc","title":"Misc.between","text":"Returns a view of the sorted vector v, indexed using rangebetween.\n\nbetween(v::AbstractVector, left, right; kwargs...) -> Any\n\n\njulia> between([1, 2, 3, 3, 3], 3, 3; strict=true)\n0-element view(::Vector{Int64}, 6:5) with eltype Int64\njulia> between([1, 2, 3, 3, 3], 1, 3; strict=true)\n1-element view(::Vector{Int64}, 2:2) with eltype Int64:\n 2\njulia> between([1, 2, 3, 3, 3], 2, 3; strict=false)\n2-element view(::Vector{Int64}, 3:4) with eltype Int64:\n 3\n 3\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.config!-Tuple{String}","page":"Misc","title":"Misc.config!","text":"Parses the toml file and populates the config cfg.\n\nconfig!(\n    name::String;\n    cfg,\n    path,\n    check\n) -> Misc.Config{Float64}\n\n\nThis function updates the configuration object cfg by parsing the TOML file specified by name and path. If check is true, the function validates the config.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.config_path-Tuple{}","page":"Misc","title":"Misc.config_path","text":"Determines the config file path.\n\nThis function attempts to find the configuration file using find_config(). If it doesn't exist in the default directory, it falls back to the active project directory.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.dec!-Union{Tuple{Ref{I}}, Tuple{I}} where I<:Integer","page":"Misc","title":"Misc.dec!","text":"Decrement an integer reference by one\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.default_dir-Tuple{}","page":"Misc","title":"Misc.default_dir","text":"Returns the default directory path for the project.\n\ndefault_dir() -> String\n\n\nThis function returns the directory of the active project if it exists. Otherwise, it uses the JULIA_PROJECT from the environment variables. If neither exist, it defaults to the current directory.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.default_local_dir-Tuple","page":"Misc","title":"Misc.default_local_dir","text":"Returns the default local directory.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.drop-Union{Tuple{N}, Tuple{NamedTuple, Tuple{Vararg{Symbol, N}}}} where N","page":"Misc","title":"Misc.drop","text":"Returns a NamedTuple without the given keys.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.exchange_keys-Tuple{Any}","page":"Misc","title":"Misc.exchange_keys","text":"Retrieves the API keys for a specific exchange.\n\nexchange_keys(name; sandbox)\n\n\nThis function tries to open and parse a JSON file named after the exchange name, which should contain the API keys.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.execmode-Tuple","page":"Misc","title":"Misc.execmode","text":"Returns the execution mode of the arguments.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.find_config","page":"Misc","title":"Misc.find_config","text":"Finds the configuration file in the given path.\n\nfind_config(; ...) -> Union{Nothing, String}\nfind_config(cur_path; name, dir) -> Any\n\n\nThis function recursively searches for a file with the specified name starting from cur_path. It stops once the file is found or when it reaches the root directory.\n\n\n\n\n\n","category":"function"},{"location":"API/misc/#Misc.gtxzero-Tuple{T} where T","page":"Misc","title":"Misc.gtxzero","text":"Checks if a value is greater than or approximately equal to zero.\n\ngtxzero(v; atol) -> Any\n\n\nThis function takes a value v and a tolerance atol. It returns true if v is greater than zero or if the absolute difference between v and zero is less than or equal to atol, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.hasattr-Tuple{Any, Any}","page":"Misc","title":"Misc.hasattr","text":"Check if k is present in the attrs field of the input object.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.hasattr-Tuple{Any, Vararg{Any}}","page":"Misc","title":"Misc.hasattr","text":"Check if any of keys... is present in the attrs field of the input object.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.inc!-Union{Tuple{Ref{I}}, Tuple{I}} where I<:Integer","page":"Misc","title":"Misc.inc!","text":"Increment an integer reference by one\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.init_task-Tuple{Task, Any}","page":"Misc","title":"Misc.init_task","text":"Initializes a task with a given state.\n\ninit_task(t::Task, state) -> Task\n\n\nThis function initializes a task t with a given state. It sets up the task's storage dictionary which includes running flag, state, and a condition variable for notification.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.isdirempty-Tuple{AbstractString}","page":"Misc","title":"Misc.isdirempty","text":"Checks if a directory is empty.\n\nisdirempty(path::AbstractString) -> Bool\n\n\nThis function takes a path and returns true if the directory at the given path is empty, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.isstrictlysorted-Tuple","page":"Misc","title":"Misc.isstrictlysorted","text":"Checks if an iterable is strictly sorted.\n\nisstrictlysorted(itr...) -> Bool\n\n\nThis function takes an iterable itr and returns true if the elements in itr are strictly increasing, and false otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.istaskrunning-Tuple{Task}","page":"Misc","title":"Misc.istaskrunning","text":"Check if a task is running.\n\nistaskrunning(t::Task) -> Bool\n\n\nThis function checks if a task (t) is running. A task is considered running if it has started and is not yet done.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.istaskrunning-Tuple{}","page":"Misc","title":"Misc.istaskrunning","text":"Checks if the current task is running.\n\nThis function checks if the current task is running by accessing the task's local storage.\n\nwarning: Don't use within macros\nUse the homonymous macro @istaskrunning() instead.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.keys_path-Tuple{AbstractString}","page":"Misc","title":"Misc.keys_path","text":"Generates the path for the JSON keys file.\n\nkeys_path(exc_name::AbstractString) -> String\n\n\nThis function constructs a filename from the given exc_name, replacing any existing .json extension, and joins it with the user directory path.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.marginmode-Tuple","page":"Misc","title":"Misc.marginmode","text":"Returns the margin mode of the arguments.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.modifyattr!-Tuple{Any, Any, Any, Vararg{Any}}","page":"Misc","title":"Misc.modifyattr!","text":"Set k in the attrs field of the input object to v.\n\nmodifyattr!(d, v, op, keys...)\n\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.negative-Tuple{Any}","page":"Misc","title":"Misc.negative","text":"negate(abs(v))\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.opposite-Tuple{Type{Misc.Long}}","page":"Misc","title":"Misc.opposite","text":"The opposite position side (Long -> Short, Short -> Long)\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.positive-Tuple{Any}","page":"Misc","title":"Misc.positive","text":"Alias to abs\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.queryfromstruct","page":"Misc","title":"Misc.queryfromstruct","text":"Creates a query from a struct type.\n\nqueryfromstruct(T::Type; ...) -> Dict{Any, Any}\nqueryfromstruct(T::Type, sep; kwargs...) -> Dict{Any, Any}\n\n\nThis function takes a struct type T and a separator sep, and creates a query string using the fields and their values in T.\n\n\n\n\n\n","category":"function"},{"location":"API/misc/#Misc.rangeafter-Tuple{AbstractVector, Any}","page":"Misc","title":"Misc.rangeafter","text":"Finds the range after a specified value in a vector.\n\nrangeafter(v::AbstractVector, d; strict, kwargs...) -> Any\n\n\nThis function takes a vector v and a value d, and returns a range that starts after the first occurrence of d in v. If strict is true, the range starts after d, otherwise it starts at d.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.rangebefore-Tuple{AbstractVector, Any}","page":"Misc","title":"Misc.rangebefore","text":"Complement of rangeafter.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.rangebetween-Tuple{AbstractVector, Any, Any}","page":"Misc","title":"Misc.rangebetween","text":"Finds the range between two specified values in a vector.\n\nrangebetween(\n    v::AbstractVector,\n    left,\n    right;\n    kwargs...\n) -> Any\n\n\nThis function takes a vector v and two values left and right, and returns a range that starts from the position of left and ends at the position of right in v.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.reset!-Tuple{Misc.Config}","page":"Misc","title":"Misc.reset!","text":"Resets the Config object to its default values.\n\nreset!(c::Misc.Config)\n\n\nThis function iterates over the fields of the Config object c and resets each field to its default value. (stored in the defaults field)\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.rewritekeys!-Tuple{AbstractDict, Any}","page":"Misc","title":"Misc.rewritekeys!","text":"Rewrites keys in a dictionary based on a function.\n\nrewritekeys!(dict::AbstractDict, f) -> AbstractDict\n\n\nThis function takes a dictionary dict and a function f, and rewrites each key in the dictionary by applying the function f to it.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.setattr!-Tuple{Any, Any, Vararg{Any}}","page":"Misc","title":"Misc.setattr!","text":"Set k in the attrs field of the input object to v.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.setoffline!-Tuple{}","page":"Misc","title":"Misc.setoffline!","text":"Sets the offline mode.\n\nsetoffline!() -> Bool\n\n\nThis function sets the offline mode based on the PINGPONG_OFFLINE environment variable. If the environment variable is set, it parses its value as a boolean to set the offline mode. It is used to skip some errors during precompilation, if precompiling offline.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.shift!","page":"Misc","title":"Misc.shift!","text":"Shifts elements in a vector.\n\nshift!(\n    arr::Vector{<:AbstractFloat}\n) -> Vector{<:AbstractFloat}\nshift!(\n    arr::Vector{<:AbstractFloat},\n    n\n) -> Vector{<:AbstractFloat}\nshift!(\n    arr::Vector{<:AbstractFloat},\n    n,\n    def\n) -> Vector{<:AbstractFloat}\n\n\nThis function shifts the elements in arr by n positions to the left. The new elements added to the end of the array are set to the value of def.\n\n\n\n\n\n","category":"function"},{"location":"API/misc/#Misc.start_task-Tuple{Task, Any}","page":"Misc","title":"Misc.start_task","text":"Initializes and starts a task with a given state.\n\nstart_task(t::Task, state) -> Task\n\n\nThis function initializes a task t with a given state, schedules the task, and then returns the task.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.stop_task-Tuple{Task}","page":"Misc","title":"Misc.stop_task","text":"Stops a task if it's running.\n\nstop_task(t::Task) -> Bool\n\n\nThis function attempts to stop a running task t. It sets the task's running flag to false and notifies any waiting threads if applicable.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.swapkeys-Union{Tuple{V}, Tuple{K}, Tuple{AbstractDict{K, V}, Type, Any}} where {K, V}","page":"Misc","title":"Misc.swapkeys","text":"Swaps keys in a dictionary based on a function and new key type.\n\nswapkeys(\n    dict::AbstractDict{K, V},\n    k_type::Type,\n    f;\n    dict_type\n) -> Any\n\n\nThis function takes a dictionary dict, a function f, and a new key type k_type. It returns a new dictionary of type dict_type where each key is transformed by the function f and cast to k_type.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.task_sem-Tuple{Any}","page":"Misc","title":"Misc.task_sem","text":"Retrieves or initializes a semaphore for a task.\n\ntask_sem(task) -> Any\n\n\nThis function retrieves or initializes a semaphore for a task task. If the semaphore doesn't exist, it initializes a new one with an empty queue and a condition variable.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.toprecision-Tuple{AbstractFloat, Int64}","page":"Misc","title":"Misc.toprecision","text":"When precision is a Integer it represents the number of decimals.\n\ntoprecision(n::AbstractFloat, prec::Int64) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.toprecision-Tuple{AbstractFloat, UInt64}","page":"Misc","title":"Misc.toprecision","text":"Round a float to a given precision (SIGNIFICANT_DIGITS).\n\ntoprecision(n::AbstractFloat, prec::UInt64) -> Any\n\n\nSIGNIFICANT_DIGITS precision mode is similar to DECIMAL_PLACES except that the last digit is the one that is rounded\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.toprecision-Tuple{Union{AbstractFloat, Integer}, AbstractFloat}","page":"Misc","title":"Misc.toprecision","text":"When precision is a float it represents the pip.\n\ntoprecision(\n    n::Union{AbstractFloat, Integer},\n    prec::AbstractFloat\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.truncate_file-Tuple{Any, Any}","page":"Misc","title":"Misc.truncate_file","text":"Truncate a file to contain only the last nlines lines.\n\ntruncate_file(filename, nlines) -> Any\n\n\nOpens the file for reading, keeps only the last nlines lines, then opens the file again for writing and overwrites it with those last lines. Throws an error if nlines is not a positive integer.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.waitforcond-Tuple{Any, Any}","page":"Misc","title":"Misc.waitforcond","text":"Waits for a certain condition for a specified time.\n\nwaitforcond(cond, time) -> Int64\n\n\nThis function waits for a certain condition cond to be met within a specified time. The condition cond is a function that returns a boolean value. The function continuously checks the condition until it's true or until the specified time has passed.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.waitforcond-Tuple{Function, Any}","page":"Misc","title":"Misc.waitforcond","text":"Waits for a condition function to return true for a specified time.\n\nwaitforcond(cond::Function, time) -> Int64\n\n\nThis function waits for a condition function cond to return true. It keeps checking the condition for a specified time.\n\n\n\n\n\n","category":"method"},{"location":"API/misc/#Misc.@as_dfdict","page":"Misc","title":"Misc.@as_dfdict","text":"Binds a mrkts variable to a Dict{String, DataFrame} where the keys are the pairs names and the data is the OHLCV data of the pair.\n\n\n\n\n\n","category":"macro"},{"location":"API/misc/#Misc.@istaskrunning-Tuple{}","page":"Misc","title":"Misc.@istaskrunning","text":"Checks if the current task is running (Macro).\n\nEquivalent to istaskrunning() but should be used within other macros.\n\n\n\n\n\n","category":"macro"},{"location":"API/misc/#Misc.@lev!-Tuple{}","page":"Misc","title":"Misc.@lev!","text":"Toggle config leverage flag\n\n\n\n\n\n","category":"macro"},{"location":"API/misc/#Misc.@margin!-Tuple{}","page":"Misc","title":"Misc.@margin!","text":"Toggle config margin flag.\n\n\n\n\n\n","category":"macro"},{"location":"API/misc/#Misc.@skipoffline","page":"Misc","title":"Misc.@skipoffline","text":"Same as the Lang.@ignoremacro, but only ifPINGPONG_OFFLINE` is set.\n\n\n\n\n\n","category":"macro"},{"location":"API/misc/#Misc.@start_task-Tuple{Any, Any}","page":"Misc","title":"Misc.@start_task","text":"Starts a task with a given state and code block.\n\nThis macro initializes and starts a task with a given state and code block. It creates a task with the provided code, initializes it with the state, and schedules the task for running.\n\n\n\n\n\n","category":"macro"},{"location":"API/strategytools/#StrategyTools","page":"StrategyTools","title":"StrategyTools","text":"","category":"section"},{"location":"API/strategytools/","page":"StrategyTools","title":"StrategyTools","text":"This module implements routines common to many strategies.","category":"page"},{"location":"API/strategytools/","page":"StrategyTools","title":"StrategyTools","text":"Modules = [StrategyTools]","category":"page"},{"location":"API/strategytools/#StrategyTools.MovingExtrema","page":"StrategyTools","title":"StrategyTools.MovingExtrema","text":"MovingExtrema2: keep track of minimum and maximum values within a moving window.\n\n\n\n\n\n","category":"type"},{"location":"API/strategytools/#StrategyTools.MovingExtrema-Tuple{Int64}","page":"StrategyTools","title":"StrategyTools.MovingExtrema","text":"MovingExtrema2: Keep track of minima and maxima within a moving window.\n\nMovingExtrema(window::Int64) -> StrategyTools.MovingExtrema\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#Base.:/-Tuple{TimeFrames.TimeFrame, Any}","page":"StrategyTools","title":"Base.:/","text":"TimeFrame division\n\n/(tf::TimeFrames.TimeFrame, d; type) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#Base.extrema-Tuple{StrategyTools.MovingExtrema}","page":"StrategyTools","title":"Base.extrema","text":"Get the minimum and maximum values in the MovingExtrema2 buffer.\n\nextrema(\n    q::StrategyTools.MovingExtrema\n) -> Tuple{Union{Missing, Float64}, Union{Missing, Float64}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#Base.push!-Tuple{StrategyTools.MovingExtrema, Float64}","page":"StrategyTools","title":"Base.push!","text":"Pushes a new value to the MovingExtrema2 buffer.\n\npush!(\n    q::StrategyTools.MovingExtrema,\n    value::Float64\n) -> Deque{Float64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#Misc.pong!-Tuple{Function, Strategies.RTStrategy, Instances.AssetInstance, Dates.DateTime, SimWarmup}","page":"StrategyTools","title":"Misc.pong!","text":"Initiates the warmup process for a real-time strategy instance.\n\npong!(\n    cb::Function,\n    s::Strategies.RTStrategy,\n    ai::Instances.AssetInstance,\n    ats::Dates.DateTime,\n    ::SimWarmup;\n    n_candles\n)\n\n\nIf warmup has not been previously completed for the given asset instance, it performs the necessary preparations.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#Misc.pong!-Tuple{Strategies.RTStrategy, InitSimWarmup}","page":"StrategyTools","title":"Misc.pong!","text":"Initializes warmup attributes for a strategy.\n\npong!(\n    s::Strategies.RTStrategy,\n    ::InitSimWarmup;\n    timeout,\n    n_candles\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools._warmup!-Tuple{Function, Strategies.Strategy, Instances.AssetInstance, Dates.DateTime}","page":"StrategyTools","title":"StrategyTools._warmup!","text":"Executes the warmup routine with a custom callback for a strategy.\n\n_warmup!(\n    callback::Function,\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance,\n    ats::Dates.DateTime;\n    n_candles\n)\n\n\nThe function prepares the trading strategy by simulating past data before live execution starts.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.belowtotal-Tuple{Any, Any, Any}","page":"StrategyTools","title":"StrategyTools.belowtotal","text":"Check if collateral is below a calculated threshold\n\nbelowtotal(s, ai, p; qt) -> Any\n\n\nDetermines if the collateral of a position p is less than the minimum required amount or a dynamic threshold based on s[:qt_base].\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.cdfrompnl-Union{Tuple{T}, Tuple{Any, Any}, Tuple{Any, Any, T}} where T","page":"StrategyTools","title":"StrategyTools.cdfrompnl","text":"Calculates the cooldown period based on the profit and loss values.\n\ncdfrompnl(s, pnl) -> Any\ncdfrompnl(s, pnl, cdu) -> Any\n\n\nThis function calculates the cooldown period (cd) using the profit and loss (pnl) values, the cooldown unit (cdu), and the strategy's cooldown_base.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.copyohlcv!-Union{Tuple{T2}, Tuple{T1}, Tuple{T1, T2}} where {T1, T2<:Instances.AssetInstance}","page":"StrategyTools","title":"StrategyTools.copyohlcv!","text":"Updates the OHLCV data for a destination asset instance from a source.\n\ncopyohlcv!(ai_dst, ai_src::Instances.AssetInstance)\n\n\nExisting OHLCV data for the destination is cleared before copying to ensure accurate and up-to-date information.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.copyohlcv!-Union{Tuple{T}, Tuple{T, T}} where T<:Strategies.Strategy","page":"StrategyTools","title":"StrategyTools.copyohlcv!","text":"Copies OHLCV data from one strategy instance to another.\n\ncopyohlcv!(\n    s_dst::Strategies.Strategy,\n    s_src::Strategies.Strategy\n)\n\n\nEnsures that the destination strategy's asset instances are updated with the source's OHLCV data for matching market symbols.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.copypnl!-NTuple{4, Any}","page":"StrategyTools","title":"StrategyTools.copypnl!","text":"Copies simulated PnL data to the main strategy instance.\n\ncopypnl!(s, ai, s_sim, ai_sim) -> Union{Nothing, Bool}\n\n\nTransfers PnL data from a simulation instance to the corresponding asset in the main strategy and marks the asset as warmed up.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.degrees-Tuple{Any}","page":"StrategyTools","title":"StrategyTools.degrees","text":"Calculate angle of a slope.\n\ndegrees(slp) -> Any\n\n\nCalculates the angle in degrees of the slope slp.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.get_signal_value-Tuple{Any, Any}","page":"StrategyTools","title":"StrategyTools.get_signal_value","text":"Retrieve a signal value from a dictionary for a given key.\n\nget_signal_value(ct, k) -> Any\n\n\nExtracts the sig.value from the property of the dictionary item identified by k.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.hasentrycash-Tuple{Any, Any}","page":"StrategyTools","title":"StrategyTools.hasentrycash","text":"Verify if free cash is above the entry cost minimum\n\nhasentrycash(s, ai) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.hasexitcash-Tuple{Any, Any}","page":"StrategyTools","title":"StrategyTools.hasexitcash","text":"Assess if amount exceeds the minimum exit amount\n\nhasexitcash(amt, ai) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.initpnl!","page":"StrategyTools","title":"StrategyTools.initpnl!","text":"Initializes the PnL tracking structure for each asset in the universe.\n\ninitpnl!(s; ...) -> Any\ninitpnl!(s, uni; n) -> Any\n\n\nSets up a LittleDict with a circular buffer to store PnL data, defaulting to 100 entries.\n\n\n\n\n\n","category":"function"},{"location":"API/strategytools/#StrategyTools.iscrossed-Tuple{Any, Any, Any, Any, Val}","page":"StrategyTools","title":"StrategyTools.iscrossed","text":"Check if a signal crossover condition is met at a given time.\n\niscrossed(s, ai, ats, sig_b, drc::Val) -> Any\n\n\nEvaluates if the closing prices at specified times cross a threshold in the direction drc. Uses timeframes and signals to determine the crossover.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.iscrossed-Tuple{Val{:above}}","page":"StrategyTools","title":"StrategyTools.iscrossed","text":"Determine if a crossover occurred in a specified direction.\n\niscrossed(::Val{:above}; a, b, prev_a, prev_b)\n\n\nChecks if values a, b, and c satisfy the conditions for a crossover in the specified direction (:above or :below).\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.islastts-Tuple{Strategies.SimStrategy, Any, Any, Any}","page":"StrategyTools","title":"StrategyTools.islastts","text":"Check if last timestamp is within time frame for a simulation strategy.\n\nislastts(\n    _::Strategies.SimStrategy,\n    _,\n    ats,\n    tf\n) -> Tuple{Bool, Any}\n\n\nChecks if the last timestamp ts is within the time frame tf for the simulation strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.isrecenttrade-Tuple{Instances.AssetInstance, Dates.DateTime, TimeFrames.TimeFrame}","page":"StrategyTools","title":"StrategyTools.isrecenttrade","text":"Checks if a trade was made recently\n\nisrecenttrade(\n    ai::Instances.AssetInstance,\n    ats::Dates.DateTime,\n    tf::TimeFrames.TimeFrame\n) -> Bool\n\n\nChecks if a trade was made recently by checking if the last trade time for the given asset instance is more recent than the current time frame. If no trades were made, it returns true.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.isstaleohlcv-Tuple{Strategies.RTStrategy, Any}","page":"StrategyTools","title":"StrategyTools.isstaleohlcv","text":"Determines if the OHLCV data is stale for specified conditions.\n\nisstaleohlcv(s::Strategies.RTStrategy, ai; ats, tf, backoff)\n\n\nThe function checks whether the latest time stamp of OHLCV data is not older than the backoff period. If older, it returns true, indicating the data is stale. Used to avoid reprocessing the same ohlcv candle.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.isstaleohlcv-Tuple{Strategies.SimStrategy, Vararg{Any}}","page":"StrategyTools","title":"StrategyTools.isstaleohlcv","text":"Determines if the OHLCV data is stale for a simulation strategy.\n\nisstaleohlcv(\n    s::Strategies.SimStrategy,\n    args...;\n    kwargs...\n) -> Bool\n\n\nFor a simulation strategy it is always up-to-date, so always returns false.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.istrending!-Tuple{Strategies.Strategy, Instances.AssetInstance, Dates.DateTime, Any}","page":"StrategyTools","title":"StrategyTools.istrending!","text":"Check if an asset is trending for a given signal\n\nistrending!(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance,\n    ats::Dates.DateTime,\n    sig_name;\n    func\n) -> Bool\n\n\nChecks if the asset ai is trending at time ats for the signal sig_name in the strategy s. The trending condition is determined by the provided func::Function which has the signature:\n\nfunc(::SignalState, ::Int, ::DataFrame)::Bool\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.liveloop-Tuple{Any, Strategies.RTStrategy, Any}","page":"StrategyTools","title":"StrategyTools.liveloop","text":"Map function asynchronously for a real-time strategy.\n\nliveloop(f, s::Strategies.RTStrategy, iter)\n\n\nAsynchronously maps the function f over the iterable iter for the real-time strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.liveloop-Tuple{Any, Strategies.SimStrategy, Any}","page":"StrategyTools","title":"StrategyTools.liveloop","text":"Apply function to iterable for a simulation strategy.\n\nliveloop(f, s::Strategies.SimStrategy, iter) -> Any\n\n\nApplies the function f to each element of the iterable iter for the simulation strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.liveloop-Tuple{Any, Strategies.Strategy}","page":"StrategyTools","title":"StrategyTools.liveloop","text":"Apply function to iterable for a strategy.\n\nliveloop(f, s::Strategies.Strategy)\n\n\nApplies the function f to each element of the iterable iter for the strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.livesleep-Tuple{Strategies.RTStrategy, Any}","page":"StrategyTools","title":"StrategyTools.livesleep","text":"Sleep function for a real-time strategy.\n\nlivesleep(s::Strategies.RTStrategy, n)\n\n\nMakes the real-time strategy s sleep for n seconds.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.livesleep-Tuple{Strategies.SimStrategy, Any}","page":"StrategyTools","title":"StrategyTools.livesleep","text":"Sleep function for a simulation strategy.\n\nlivesleep(s::Strategies.SimStrategy, _)\n\n\nDoes nothing for the simulation strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.log-Tuple{Strategies.RTStrategy, Any, Vararg{Any}}","page":"StrategyTools","title":"StrategyTools.log","text":"Log function for a strategy.\n\nlog(s::Strategies.RTStrategy, f, args...)\n\n\nLogs the function f with its arguments args for the strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.log-Tuple{Strategies.SimStrategy, Any, Vararg{Any}}","page":"StrategyTools","title":"StrategyTools.log","text":"Log function for a simulation strategy.\n\nlog(s::Strategies.SimStrategy, f, args...)\n\n\nLogs the function f with its arguments args for the simulation strategy s.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.select_orderkwargs-Tuple{Symbol, Type{OrderTypes.Buy}, Any, Any}","page":"StrategyTools","title":"StrategyTools.select_orderkwargs","text":"Select additional keyword arguments for Buy orders based on order type\n\nselect_orderkwargs(\n    otsym::Symbol,\n    ::Type{OrderTypes.Buy},\n    ai,\n    ats;\n    incr\n) -> Union{@NamedTuple{}, NamedTuple{(:price,), <:Tuple{Any}}}\n\n\nDepending on the order type symbol, additional keyword arguments are selected to define order parameters like price. This method specifically handles the Buy side logic by adjusting price based on closing value.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.select_orderkwargs-Tuple{Symbol, Type{OrderTypes.Sell}, Any, Any}","page":"StrategyTools","title":"StrategyTools.select_orderkwargs","text":"Selects an order type based on the strategy, order side, and position side\n\nselect_orderkwargs(\n    otsym::Symbol,\n    ::Type{OrderTypes.Sell},\n    ai,\n    ats;\n    incr\n) -> Union{@NamedTuple{}, NamedTuple{(:price,), <:Tuple{Any}}}\n\n\nSelects an order type os based on the strategy s and the position side p. The order type is determined by the ordertype attribute of the strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.select_ordertype","page":"StrategyTools","title":"StrategyTools.select_ordertype","text":"Selects an order type based on the strategy, order side, and position side\n\nselect_ordertype(\n    s::Strategies.Strategy,\n    os::Type{<:OrderTypes.OrderSide};\n    ...\n) -> Tuple{Type, Any}\nselect_ordertype(\n    s::Strategies.Strategy,\n    os::Type{<:OrderTypes.OrderSide},\n    p::Misc.PositionSide;\n    t\n) -> Tuple{Type, Any}\n\n\nSelects an order type os based on the strategy s and the position side p. The order type is determined by the ordertype attribute of the strategy.\n\n\n\n\n\n","category":"function"},{"location":"API/strategytools/#StrategyTools.signal_range-Tuple{Any, Any, Any}","page":"StrategyTools","title":"StrategyTools.signal_range","text":"Return the inputs for the fit! function of the signal.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.signal_value-Tuple{Any}","page":"StrategyTools","title":"StrategyTools.signal_value","text":"Dispatch on typeof(sig.state)\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.signals!-Tuple{Any, Vararg{Any}}","page":"StrategyTools","title":"StrategyTools.signals!","text":"Update or initialize strategy signals.\n\nsignals!(s, args...; kwargs...)\n\n\nHandles dynamic indicator updates based on strategy configurations. Redirects to signals! with appropriate value tagging and error management.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.signals!-Tuple{Strategies.Strategy, Any, Val{:update}}","page":"StrategyTools","title":"StrategyTools.signals!","text":"Update signals for a strategy.\n\nsignals!(s::Strategies.Strategy, ats, _::Val{:update})\n\n\nIterates over the universe of assets and for each asset iterates over the configured signals. Calls update_signal! to update each indicator with the current asset time series and configuration.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.signals!-Tuple{Strategies.Strategy, Val{:warmup}}","page":"StrategyTools","title":"StrategyTools.signals!","text":"Update signals for a strategy.\n\nsignals!(\n    s::Strategies.Strategy,\n    ::Val{:warmup};\n    force,\n    history\n) -> Union{Nothing, Bool}\n\n\nIterates over the universe of assets and for each asset iterates over the configured signals. Calls update_signal! to update each indicator with the current asset time series and configuration.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.signals-NTuple{4, Any}","page":"StrategyTools","title":"StrategyTools.signals","text":"Create multiple signal definitions and instantiate a new Signals17 object.\n\nsignals(\n    signals,\n    timeframes,\n    count,\n    params\n) -> StrategyTools.Signals17\n\n\nConstructs a dictionary of signals from input tuples and then creates a Signals17 instance using these definitions. Each signal configuration is converted into a typed tuple preserving the structure required by Signals17.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.track_expectancy!-Tuple{Any, Any}","page":"StrategyTools","title":"StrategyTools.track_expectancy!","text":"Calculates the win rate and profit/loss thresholds for a trading strategy.\n\ntrack_expectancy!(s, ai) -> Any\n\n\nUpdates s[:profit_thresh] and s[:loss_thresh] based on the trading results.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.trackcd!-NTuple{4, Any}","page":"StrategyTools","title":"StrategyTools.trackcd!","text":"Updates the cooldown period for an asset instance in the strategy.\n\ntrackcd!(s, ai, ats, ts) -> Any\n\n\nThe function calculates the cooldown period for the asset instance ai in the strategy s at the current timestamp ts.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.tracklev!-Tuple{Any, Any}","page":"StrategyTools","title":"StrategyTools.tracklev!","text":"Adjusts the leverage for an asset based on the Kelly criterion.\n\ntracklev!(\n    s,\n    ai;\n    dampener\n) -> NamedTuple{(:time, :raw_val, :value), <:Tuple{Any, Any, Any}}\n\n\nApplies a damping function to the raw Kelly leverage to ensure it remains within practical limits.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.trackpnl!-NTuple{4, Any}","page":"StrategyTools","title":"StrategyTools.trackpnl!","text":"Records the profit and loss (PnL) for a given asset instance at a specific timestamp.\n\ntrackpnl!(s, ai, ats, ts) -> Any\n\n\nThe PnL is calculated based on the position side and the closing price at the given timestamp.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.trackqt!-Tuple{Any, Any, Any}","page":"StrategyTools","title":"StrategyTools.trackqt!","text":"Tracks the target quantity of an asset over time for trading strategy s.\n\ntrackqt!(s, ai, ats; f) -> Any\n\n\nThe quantity is determined by the function f and is adjusted based on the asset ai and timestamp ats.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.update_data!-Tuple{Any, Any}","page":"StrategyTools","title":"StrategyTools.update_data!","text":"Update or initialize mutable data related to asset information.\n\nupdate_data!(ai, tf) -> DataFrames.DataFrame\n\n\nThis function acquires or creates a data frame for the ai asset using the timeframe tf, then refreshes its OHLCV data by fetching new entries from the specified time onwards, based on the asset's symbol and exchange details. The update process may involve checking the existing data timestamps to avoid unnecessary data retrieval.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.update_signal!-NTuple{4, Any}","page":"StrategyTools","title":"StrategyTools.update_signal!","text":"Update signal\n\nupdate_signal!(ai, ats, ai_signals, sig_name; tf, count)\n\n\nUpdates the signal sig_name for asset ai based on new data up to timestamp ats. Uses a lookback window of count timeframes tf.\n\n\n\n\n\n","category":"method"},{"location":"API/strategytools/#StrategyTools.waitohlcv-Tuple{Any, Any}","page":"StrategyTools","title":"StrategyTools.waitohlcv","text":"Waits for OHLCV data to update up to a specified time.\n\nwaitohlcv(s, since; interval)\n\n\nThe function continuously checks if the latest data in each asset's time frame is up-to-date with the since parameter. It pauses execution using sleep for the given interval until the condition is met.\n\n\n\n\n\n","category":"method"},{"location":"engine/backtesting/#Running-a-Backtest","page":"Backtesting","title":"Running a Backtest","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"To perform a backtest, you need to construct a strategy by following the guidelines in the Strategy Documentation. Once the strategy is created, you can call the start! function on it to begin the backtest.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"The entry function that is called in all modes is ping!(s::Strategy, ts::DateTime, ctx). This function takes three arguments:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"s: The strategy object that you have created.\nts: The current date. In live mode, it is very close to now(), while in simulation mode, it is the date of the iteration step.\nctx: Additional context information that can be passed to the function.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"During the backtest, the ping! function is responsible for executing the strategy's logic at each timestep. It is called repeatedly with updated values of ts until the backtest is complete.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"It is important to note that the ping! function should be implemented in your strategy module according to your specific trading logic.","category":"page"},{"location":"engine/backtesting/#Example","page":"Backtesting","title":"Example","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Here is an example of how to use the ping! function in a strategy module:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"module ExampleStrategy\n\n# Define the ping! function\nping!(s::Strategy, ts::DateTime, ctx) = begin\n    # Insert your trading logic here\nend\n\nend","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Let's run a backtest.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"using Engine.Strategies\nusing Engine.Executors: SimMode as sm\ns = strategy(:Example)\n# Load data in the strategy universe (you need to already have it)\nfill!(s) # or stub!(s.universe, datadict)\n# backtest the strategy within the period available from the loaded data.\nsm.start!(s)\n# Lets see how we fared:\ndisplay(s)\n## output\nName: Example\nConfig: 10.0(USDT)(Base Size), 100.0(USDT)(Initial Cash)\nUniverse: 3 instances, 1 exchanges\nHoldings: assets(trades): 2(977), min BTC: 23.13(USDT), max XMR: 79.611(USDT)\nPending buys: 3\nPending sells: 0\nUSDT: 32.593 (Cash)\nUSDT: 156.455 (Total)","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Our backtest indicates that our strategy:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Operated on 3 assets (instances)\nExecuted 977 trades\nStarted with 100 USDT and finished with 32 USDT in cash, and assets worth 156 USDT\nThe asset with the minimum value at the end was BTC, and the one with the maximum value was XMR\nAt the end, there were 3 open buy orders and no open sell orders.","category":"page"},{"location":"engine/backtesting/#Orders","page":"Backtesting","title":"Orders","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"To place a limit order within your strategy, you call pong! just like any call to the executor. Here are the arguments:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"trade = pong!(s, GTCOrder{Buy}, ai; price, amount, date=ts)","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Where s is your Strategy{Sim, ...} instance, ai is the AssetInstance to which the order refers (it should be one present in your s.universe). The amount is the quantity in base currency and date should be the one fed to the ping! function. During backtesting, this would be the current timestamp being evaluated, and during live trading, it would be a recent timestamp. If you look at the example strategy, ts is current and ats is available. The available timestamp ats is the one that matches the last candle that doesn't give you forward knowledge. The date given to the order call (pong!) must always be the current timestamp.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"A limit order call might return a trade if the order was queued correctly. If the trade hasn't completed the order, the order is queued in s.buy/sellorders[ai]. If isnothing(trade) is true, it means the order failed and was not scheduled. This can happen if the cost of the trade did not meet the asset limits, or there wasn't enough commitable cash. If instead ismissing(trade) is true, it means that the order was scheduled, but no trade has yet been performed. In backtesting, this happens if the price of the order is too low (buy) or too high (sell) for the current candle high/low prices.","category":"page"},{"location":"engine/backtesting/#Limit-Order-Types","page":"Backtesting","title":"Limit Order Types","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"In addition to GTC (Good Till Canceled) orders, there are also IOC (Immediate Or Cancel) and FOK (Fill Or Kill) orders:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"GTC: This order remains active until it is either filled or canceled.\nIOC: This order must be executed immediately. Any portion of the order that cannot be filled immediately will be canceled.\nFOK: This order must be executed in its entirety or not at all.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"All three are subtypes of a limit order, <: LimitOrder>. You can create them by calling pong! as shown below:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"trade = pong!(s, IOCOrder{Buy}, ai; price, amount, date=ts)\ntrade = pong!(s, FOKOrder{Sell}, ai; price, amount, date=ts)","category":"page"},{"location":"engine/backtesting/#Market-Order-Types","page":"Backtesting","title":"Market Order Types","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Market order types include:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"MarketOrder: This order is executed at the best available price in the market.\nLiquidationOrder: This order is similar to a MarketOrder, but its execution price might differ from the candle price.\nReduceOnlyOrder: This is a market order that is automatically triggered when manually closing a position.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"All of these behave in the same way, except for the LiquidationOrder. For example, a ReduceOnlyOrder is triggered when manually closing a position, as shown below:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"pong!(s, ai, Long(), now(), PositionClose())","category":"page"},{"location":"engine/backtesting/#Market-Orders","page":"Backtesting","title":"Market Orders","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Although the ccxt library allows setting timeInForce for market orders because exchanges generally permit it, there isn't definitive information about how a market order is handled in these cases. Given that we are dealing with cryptocurrencies, some contexts like open and close times days are lost. It's plausible that timeInForce only matters when the order book doesn't have enough liquidity; otherwise, market orders are always immediate and fully filled orders. For this reason, we always consider market orders as FOK orders, and they will always have timeInForce set to FOK when executed live (through ccxt) to match the backtester.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"warning: Market orders can be surprising\nMarket orders always go through in the backtest. If the candle has no volume, the order incurs in heavy slippage, and the execution price of the trades can exceed the candle high/low price.","category":"page"},{"location":"engine/backtesting/#Checks","page":"Backtesting","title":"Checks","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Before an order is created, several checks are performed to sanitize the values. For instance, if the specified amount is too small, the system will automatically adjust it to the minimum allowable amount. However, if there isn't sufficient cash after this adjustment, the order will fail. For more information on precision and limits, please refer to the ccxt documentation.","category":"page"},{"location":"engine/backtesting/#Fees","page":"Backtesting","title":"Fees","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"The fees are derived from the AssetInstance fees property, which is populated by parsing the ccxt data for the specific symbol. Every trade takes these fees into account.","category":"page"},{"location":"engine/backtesting/#Slippage","page":"Backtesting","title":"Slippage","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Slippage is factored into the trade execution process. Here's how it works for different types of orders:","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Limit Orders: These can only experience positive slippage. When an order is placed and the price moves in your favor, the actual execution price becomes slightly lower (for buy orders) or higher (for sell orders). The slippage formula considers volatility (high/low) and fill ratio (amount/volume). The more volume the order takes from the candle, the lower the positive slippage will be. Conversely, higher volatility leads to higher positive slippage. Positive slippage is only added for candles that move against the order side, meaning it will only be added on red candles for buys, and green candles for sells.\nMarket Orders: These can only experience negative slippage. There is always a minimum slippage added, which by default corresponds to the difference between open and close prices (other formulas are available, check the API reference). On top of this, additional skew is added based on volume and volatility.","category":"page"},{"location":"engine/backtesting/#Liquidations","page":"Backtesting","title":"Liquidations","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"In isolated margin mode, liquidations are triggered by checking the LIQUIDATION_BUFFER. You can customize the buffer size by setting the value of the environment variable PINGONG_LIQUIDATION_BUFFER. This allows you to adjust the threshold at which liquidations are triggered.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"To obtain more accurate estimations, you can utilize the effective funding rate. This can be done by downloading the funding rate history using the Fetch module. By analyzing the funding rate history, you can gain insights into the funding costs associated with trading in isolated margin mode.","category":"page"},{"location":"engine/backtesting/#Backtesting-Performance","page":"Backtesting","title":"Backtesting Performance","text":"","category":"section"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Local benchmarking indicates that the :Example strategy, which employs FOK orders, operates on three assets, trades in spot markets, and utilizes a simple logic (which can be reviewed in the strategy code) to execute orders, currently takes approximately ~8 seconds to cycle through ~1.3M * 3 (assets) ~= 3.9M candles, executing ~6000 trades on a single x86 core.","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"It's crucial to note that the type of orders executed and the number of trades performed can significantly impact the runtime, aside from other evident factors like additional strategy logic or the number of assets. Therefore, caution is advised when interpreting claims about a backtester's ability to process X rows in Y time without additional context. Furthermore, our order creation logic always ensures that order inputs adhere to the exchange's limits, and we also incorporate slippage and probability calculations, enabling the backtester to be \"MC simmable\".","category":"page"},{"location":"engine/backtesting/","page":"Backtesting","title":"Backtesting","text":"Backtesting a strategy with margin will inevitably be slower due to the need to account for all the necessary calculations, such as position states and liquidation triggers.","category":"page"},{"location":"contacts/#Github","page":"Contacts","title":"Github","text":"","category":"section"},{"location":"contacts/","page":"Contacts","title":"Contacts","text":"Submit an issue","category":"page"},{"location":"contacts/#Discord","page":"Contacts","title":"Discord","text":"","category":"section"},{"location":"contacts/","page":"Contacts","title":"Contacts","text":"join the discord chat   (Image: Discord) ","category":"page"},{"location":"stats/#Stats-Module-Documentation","page":"Stats","title":"Stats Module Documentation","text":"","category":"section"},{"location":"stats/","page":"Stats","title":"Stats","text":"The Stats module provides functions for analyzing the outcomes of backtest runs within the trading strategy framework.","category":"page"},{"location":"stats/#Resampling-Trades","page":"Stats","title":"Resampling Trades","text":"","category":"section"},{"location":"stats/","page":"Stats","title":"Stats","text":"Using the Stats.resample_trades function, trades can be resampled to a specified time frame. This aggregates the profit and loss (PnL) of each trade for every asset in the strategy over the given period.","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"using PingPong\nusing Stats\n\nstrategy_instance = strategy(:Example)\nStats.resample_trades(strategy_instance, tf\"1d\")","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"In the example above, all trades are resampled to a daily resolution (1d), summing the PnL for each asset within the strategy.","category":"page"},{"location":"stats/#Trade-Balance-Calculation","page":"Stats","title":"Trade Balance Calculation","text":"","category":"section"},{"location":"stats/","page":"Stats","title":"Stats","text":"The Stats.trades_balance function calculates the cumulative balance over time for a given time frame, using the cum_total column as a reference. This function relies on the prior resampling of trades through resample_trades.","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"Stats.trades_balance(strategy_instance, tf\"1d\")","category":"page"},{"location":"stats/#Performance-Metrics","page":"Stats","title":"Performance Metrics","text":"","category":"section"},{"location":"stats/","page":"Stats","title":"Stats","text":"The module includes implementations of common trading performance metrics such as Sharpe ratio (sharpe), Sortino ratio (sortino), Calmar ratio (calmar), and expectancy (expectancy).","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"Stats.sharpe(strategy_instance, tf\"1d\", rfr=0.01)\nStats.sortino(strategy_instance, tf\"1d\", rfr=0.01)\nStats.calmar(strategy_instance, tf\"1d\")\nStats.expectancy(strategy_instance, tf\"1d\")","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"Each of these functions calculates the respective metric over a daily time frame, with rfr representing the risk-free rate, which is an optional parameter for the Sharpe and Sortino ratios.","category":"page"},{"location":"stats/#Multi-Metric-Calculation","page":"Stats","title":"Multi-Metric Calculation","text":"","category":"section"},{"location":"stats/","page":"Stats","title":"Stats","text":"To calculate multiple metrics simultaneously, use the multi function. It allows for the normalization of results, ensuring metric values are constrained between 0 and 1.","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"Stats.multi(strategy_instance, :sortino, :calmar; tf=tf\"1d\", normalize=true)","category":"page"},{"location":"stats/","page":"Stats","title":"Stats","text":"The normalize option normalizes the metric values by dividing by a predefined constant and then clipping the results to the range [0, 1].","category":"page"},{"location":"API/collections/#Collections","page":"Collections","title":"Collections","text":"","category":"section"},{"location":"API/collections/","page":"Collections","title":"Collections","text":"Modules = [PingPong.Engine.Collections]","category":"page"},{"location":"API/collections/#Collections.Collections","page":"Collections","title":"Collections.Collections","text":"=Collections= module\n\n\n\n\n\n","category":"module"},{"location":"API/collections/#Collections.AssetCollection","page":"Collections","title":"Collections.AssetCollection","text":"A type representing a collection of asset instances.\n\ndata\n\nThis type is used to store and manage a collection of asset instances. Each instance is linked to an asset and an exchange identifier. Elements from AssetCollection can be accessed using getindex and setindex! which accepts different types including ExchangeID, AbstractAsset, AbstractString, MatchString, or a combination of base, quote currency, and exchange. Iterating over the collection only iterates over the instances within.\n\n\n\n\n\n","category":"type"},{"location":"API/collections/#TimeTicks.DateRange","page":"Collections","title":"TimeTicks.DateRange","text":"Makes a date range that spans the common minimum and maximum dates of the collection.\n\nDateRange(\n    ac::Collections.AssetCollection;\n    ...\n) -> TimeTicks.DateRange\nDateRange(\n    ac::Collections.AssetCollection,\n    tf;\n    skip_empty\n) -> TimeTicks.DateRange\n\n\nThe DateRange function takes the following parameters:\n\nac: an AssetCollection object which encapsulates a collection of assets.\ntf (optional): a TimeFrame object that represents a specific time frame. If not provided, the function will calculate the date range based on all time frames in the AssetCollection.\nskip_empty (optional, default is false): a boolean that indicates whether to skip empty data frames in the calculation of the date range.\n\n\n\n\n\n","category":"type"},{"location":"API/collections/#Collections.bqe-Union{Tuple{T}, Tuple{DataFrames.DataFrame, T, T, T}} where T<:Symbol","page":"Collections","title":"Collections.bqe","text":"Dispatch based on either base, quote currency, or exchange.\n\n\n\n\n\n","category":"method"},{"location":"API/collections/#Collections.flatten-Tuple{Collections.AssetCollection}","page":"Collections","title":"Collections.flatten","text":"Returns a dictionary of all the OHLCV dataframes present in the asset collection.\n\nflatten(\n    ac::Collections.AssetCollection\n) -> SortedDict{TimeFrames.TimeFrame, Vector{DataFrames.DataFrame}, Base.Order.ForwardOrdering}\n\n\nThe flatten function takes the following parameter:\n\nac: an AssetCollection object which encapsulates a collection of assets.\n\nThe function returns a SortedDict where the keys are TimeFrame objects and the values are vectors of DataFrames that represent OHLCV (Open, High, Low, Close, Volume) data. The dictionary is sorted by the TimeFrame keys.\n\n\n\n\n\n","category":"method"},{"location":"API/collections/#Collections.iscashable-Tuple{Instruments.AbstractCash, Collections.AssetCollection}","page":"Collections","title":"Collections.iscashable","text":"Checks that all assets in the universe match the cash currency.\n\niscashable(\n    c::Instruments.AbstractCash,\n    ac::Collections.AssetCollection\n) -> Bool\n\n\nThe iscashable function takes the following parameters:\n\nc: an AbstractCash object which encapsulates a representation of cash.\nac: an AssetCollection object which encapsulates a collection of assets.\n\n\n\n\n\n","category":"method"},{"location":"API/collections/#Collections.prettydf-Tuple{Collections.AssetCollection}","page":"Collections","title":"Collections.prettydf","text":"Pretty prints the AssetCollection DataFrame.\n\nprettydf(ac::Collections.AssetCollection; full) -> Any\n\n\nThe prettydf function takes the following parameters:\n\nac: an AssetCollection object which encapsulates a collection of assets.\nfull (optional, default is false): a boolean that indicates whether to print the full DataFrame. If true, the function prints the full DataFrame. If false, it prints a truncated version.\n\n\n\n\n\n","category":"method"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/#Precompilation-Issues","page":"Troubleshooting","title":"Precompilation Issues","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Dependency Conflicts: After updating the repository, new dependencies may cause precompilation to fail. Ensure all packages are fully resolved by running:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"include(\"resolve.jl\")\nrecurse_projects() # Optionally set update=true","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Starting the REPL: Rather than starting a REPL and then activating the project, launch Julia directly with the project as an argument to avoid precompilation issues:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"julia --project=./PingPong","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Python-Dependent Precompilation: Precompiling code that relies on Python, such as exchange functions, may lead to segmentation faults. To prevent this:\nClear global caches, like TICKERS_CACHE100, before precompilation. Ensure global constants are empty, as their contents are serialized during precompilation.\nAvoid using macros that directly insert Python objects, such as @py, in precompilable functions.\nPersistent Precompilation Skipping: If a package consistently skips precompilation, check if JULIA_NOPRECOMP environment variable includes dependencies of the package.","category":"page"},{"location":"troubleshooting/#Python-Module-Discovery","page":"Troubleshooting","title":"Python Module Discovery","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Missing Python Dependencies: If Python reports missing modules, execute the following in the Julia REPL with the current repository activated:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"; find ./ -name .CondaPkg | xargs -I {} rm -r {} # Removes existing Conda environments\nusing Python # Activates our Python wrapper with CondaPkg environment variable fixes\nimport Pkg; Pkg.instantiate()","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Force CondaPkg Environment Resolution: In the case of persistent issues, force resolution of the CondaPkg environment by running:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using Python.PythonCall.C.CondaPkg\nCondaPkg.resolve(force=true)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Then, restart the REPL.","category":"page"},{"location":"troubleshooting/#Unresponsive-Exchange-Instance","page":"Troubleshooting","title":"Unresponsive Exchange Instance","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Idle Connection Closure: If an exchange instance remains idle for an extended period, the connection may close. It should time out according to the ccxt exchange timeout. Following a timeout error, the connection will re-establish, and API-dependent functions will resume normal operation.","category":"page"},{"location":"troubleshooting/#Data-Saving-Issues","page":"Troubleshooting","title":"Data Saving Issues","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"LMDB Size Limitations: When using LMDB with Zarr, the initial database size is set to 64MB by default. To increase the maximum size:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using Data\nzi = zinstance()\nData.mapsize!(zi, 1024) # Sets the DB size to 1GB\nData.mapsize!!(zi, 100) # Adds 100MB to the current mapsize (resulting in 1.1GB total)","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Increase the mapsize before reaching the limit to continue saving data.","category":"page"},{"location":"troubleshooting/#Misaligned-Plotting-Tooltips","page":"Troubleshooting","title":"Misaligned Plotting Tooltips","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Rendering Bugs: If you encounter misaligned tooltips with WGLMakie, switch to GLMakie to resolve rendering issues:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using GLMakie\nGLMakie.activate!()","category":"page"},{"location":"troubleshooting/#Segfaults-when-saving-ohlcv","page":"Troubleshooting","title":"Segfaults when saving ohlcv","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"The default ZarrInstance uses an LMDB store. It is possible that the underlying lmdb database has been corrupted. To fix this the database must be re-created. Either delete the database manually (default path is in under Data.DATA_PATH) or run this code on a fresh repl:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using Data\nData.zinstance(force=true)","category":"page"},{"location":"troubleshooting/#LMDB-not-available","page":"Troubleshooting","title":"LMDB not available","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"LMDB requires a precompiled binary. If it is not available for your platform you can disable it by setting the data_store preference in your strategy (or top package) Project.toml.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"[preferences.Data]\ndata_store = \"\" # Disables lmdb (set it back to \"lmdb\" to enable lmdb)","category":"page"},{"location":"troubleshooting/#Debugging-in-vscode","page":"Troubleshooting","title":"Debugging in vscode","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"To trigger breakpoints inside functions wrapped with a custom logger, like when executing a strategy with start!(::Strategy), it might be necessary to disable loading of Base.CoreLogging compiled module. Inside your user settings modify the option julia.debuggerDefaultCompiled as shown below:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"    \"julia.debuggerDefaultCompiled\": [\n        \"ALL_MODULES_EXCEPT_MAIN\",\n        \"-Base.CoreLogging\"\n    ],","category":"page"},{"location":"customizations/customizations/#Extending-the-Framework/Bot","page":"Overview","title":"Extending the Framework/Bot","text":"","category":"section"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"The framework provides parametrized types for various elements such as:","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"Strategies\nAssets\nInstances\nOrders and Trades\nExchanges","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"Parametrizing strategies enables the implementation of models like the ping pong model, which distinguishes between simulations and live executions. The other parametrized types facilitate the introduction of custom logic and behavior.","category":"page"},{"location":"customizations/customizations/#Implementing-Custom-Order-Types","page":"Overview","title":"Implementing Custom Order Types","text":"","category":"section"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"If an exchange offers a unique order type, you can define it by creating a new abstract type that inherits from OrderType. For example:","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"`julia using OrderTypes abstract type MyCustomOrderTypeS  OrderTypeS end `","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"After defining the new order type, implement the necessary functions that deviate from the standard market or limit order logic. Ideally, the order execution should be fine-grained, allowing for minimalistic customization. Only the essential functions differing from standard orders need definition, thereby avoiding modifications to existing shared behavior. If customization is not suitably granular, please file an issue for further enhancements.","category":"page"},{"location":"customizations/customizations/#Dealing-with-Inconsistent-Exchange-Interfaces","page":"Overview","title":"Dealing with Inconsistent Exchange Interfaces","text":"","category":"section"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"Exchanges sometimes exhibit inconsistent behavior through their APIs. Although CCXT provides a unified layer for a significant portion of the exchange APIs, private APIs might still be needed for certain exchanges. Review the exchange-specific API to determine which functions could be overridden. If a function is particularly complex, we may consider splitting it to facilitate more straightforward customization.","category":"page"},{"location":"customizations/customizations/#Strategy-Specific-Functions","page":"Overview","title":"Strategy-Specific Functions","text":"","category":"section"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"Functions often accept strategies as arguments, and strategy names are included within type parameters. This design allows for the creation of strategy-specific functions, also known as \"snowflake\" functions. While this flexibility is powerful, it should be used judiciously to prevent unnecessary complexity.","category":"page"},{"location":"customizations/customizations/","page":"Overview","title":"Overview","text":"Remember to leverage this flexibility to enhance functionality without overcomplicating the system, thus avoiding \"complexity bankruptcy.\"","category":"page"},{"location":"API/analysis/analysis/#Analysis","page":"Analysis","title":"Analysis","text":"","category":"section"},{"location":"API/analysis/analysis/","page":"Analysis","title":"Analysis","text":"Library for common strategy signals generation.","category":"page"},{"location":"API/analysis/analysis/","page":"Analysis","title":"Analysis","text":"Modules = [Analysis, Analysis.Query]","category":"page"},{"location":"API/analysis/analysis/#Analysis.bbands!-Tuple{DataFrames.AbstractDataFrame}","page":"Analysis","title":"Analysis.bbands!","text":"Adds Bollinger Bands to a DataFrame.\n\nbbands!(\n    df::DataFrames.AbstractDataFrame;\n    kwargs...\n) -> DataFrames.AbstractDataFrame\n\n\nThe bbands! function takes the following parameters:\n\ndf: an AbstractDataFrame to which the Bollinger Bands will be added.\nkwargs: a variable number of optional keyword arguments that allow you to specify additional parameters for the Bollinger Bands.\n\nThe function calculates the Bollinger Bands for the data in df based on the specified parameters in kwargs. Bollinger Bands are a type of statistical chart characterizing the prices and volatility over time of a financial instrument or commodity, using a formulaic method propounded by John Bollinger in the 1980s. The function modifies the input DataFrame df in place by adding the calculated Bollinger Bands.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.down_successrate-Tuple{Any, Union{String, Symbol}}","page":"Analysis","title":"Analysis.down_successrate","text":"Complement of up_successrate.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.find_bottomed-Tuple{AbstractDict{String, Data.PairData}}","page":"Analysis","title":"Analysis.find_bottomed","text":"See find_bottomed.\n\nfind_bottomed(\n    pairs::AbstractDict{String, Data.PairData};\n    kwargs...\n) -> Dict{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.find_bottomed-Tuple{AbstractVector{Data.PairData}}","page":"Analysis","title":"Analysis.find_bottomed","text":"Finds pairs that have bottomed out in the given data for long positions.\n\nfind_bottomed(\n    pairs::AbstractVector{Data.PairData};\n    bb_thresh,\n    up_thresh,\n    n,\n    mn,\n    mx\n) -> Dict{Any, Any}\n\n\nThe find_bottomed function takes the following parameters:\n\npairs: an AbstractVector of PairData objects that represent pair data.\nbb_thresh (optional, default is 0.05): a threshold value which the Bollinger Bands value must exceed to be considered a bottom.\nup_thresh (optional, default is 0.05): a threshold value which the price change must exceed to be considered an uptrend.\nn (optional, default is 12): an integer that represents the number of periods to consider for the bottom and uptrend detection.\nmn (optional, default is 1.0): a minimum value for the price to be considered a bottom.\nmx (optional, default is 90.0): a maximum value for the price to be considered a bottom.\n\nThe function scans through the pairs in the pairs vector and determines which pairs have bottomed out based on the specified criteria.\n\nThe function returns a list of pairs that have bottomed out for long positions.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.find_peaked-Tuple{AbstractDict{String, Data.PairData}}","page":"Analysis","title":"Analysis.find_peaked","text":"See find_peaked.\n\nfind_peaked(\n    pairs::AbstractDict{String, Data.PairData};\n    kwargs...\n) -> Dict{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.find_peaked-Tuple{AbstractVector{Data.PairData}}","page":"Analysis","title":"Analysis.find_peaked","text":"Complementary to find_bottomed.\n\nfind_peaked(\n    pairs::AbstractVector{Data.PairData};\n    bb_thresh,\n    up_thresh,\n    n,\n    mn,\n    mx\n) -> Dict{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.fltsummary-Tuple{AbstractVector{Tuple{AbstractFloat, Data.PairData}}}","page":"Analysis","title":"Analysis.fltsummary","text":"Generates a summary of a vector of tuples containing Floats and PairData.\n\nfltsummary(\n    flt::AbstractVector{Tuple{AbstractFloat, Data.PairData}}\n) -> Any\n\n\nThis function takes a vector flt of tuples, where each tuple contains an AbstractFloat and a PairData. It generates a summary of flt, providing insights into the characteristics of the Floats and PairData in the vector.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.gridbbands-Tuple{DataFrames.AbstractDataFrame}","page":"Analysis","title":"Analysis.gridbbands","text":"Generates a grid of Bollinger Bands with varying parameters.\n\ngridbbands(\n    df::DataFrames.AbstractDataFrame;\n    n_range,\n    sigma_range,\n    corr\n) -> Tuple{Dict{Any, Any}, DataFrames.DataFrame}\n\n\nThe gridbbands function takes the following parameters:\n\ndf: an AbstractDataFrame that represents historical market data.\nn_range (optional, default is 2:2:100): a range that represents the range of possible values for the number of periods to calculate the moving average over.\nsigma_range (optional, default is [1.0]): an array that represents the range of possible values for the number of standard deviations to calculate the bands at.\ncorr (optional, default is :corke): a symbol that represents the correlation method to use.\n\nThe function generates a grid of Bollinger Bands based on the input DataFrame df and the specified parameters. Each band in the grid uses a different combination of n_range and sigma_range.\n\nThe function returns a DataFrame that represents the grid of Bollinger Bands.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.gridrenko-Tuple{AbstractDict}","page":"Analysis","title":"Analysis.gridrenko","text":"gridrenko over a dict of PairData.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.gridrenko-Tuple{DataFrames.AbstractDataFrame}","page":"Analysis","title":"Analysis.gridrenko","text":"Generates a grid of Renko charts with varying parameters.\n\ngridrenko(\n    data::DataFrames.AbstractDataFrame;\n    head_range,\n    tail_range,\n    n_range\n) -> Vector{Any}\n\n\nThe gridrenko function takes the following parameters:\n\ndata: an AbstractDataFrame that represents historical market data.\nhead_range (optional, default is 1:10): a range that represents the range of possible values for the head in the Renko chart. The head is the most recent part of the chart.\ntail_range (optional, default is 1:3): a range that represents the range of possible values for the tail in the Renko chart. The tail is the oldest part of the chart.\nn_range (optional, default is 10:10:200): a range that represents the range of possible values for the number of periods to calculate the Average True Range (ATR) over.\n\nThe function generates a grid of Renko charts based on the input DataFrame data and the specified parameters. Each chart in the grid uses a different combination of head_range, tail_range, and n_range. The function returns a DataFrame that represents the grid of Renko charts.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.is_bottomed-Tuple{DataFrames.DataFrame}","page":"Analysis","title":"Analysis.is_bottomed","text":"Determines if a bottom has occurred in the OHLCV data.\n\nis_bottomed(ohlcv::DataFrames.DataFrame; thresh, n) -> Any\n\n\nThe is_bottomed function takes the following parameters:\n\nohlcv: a DataFrame that represents OHLCV (Open, High, Low, Close, Volume) data.\nthresh (optional, default is 0.05): a threshold value which the price change must exceed to be considered a bottom.\nn (optional, default is 26): an integer that represents the number of periods to consider for the bottom detection.\n\nThe function determines if a bottom has occurred in the OHLCV data based on the specified threshold and number of periods. A bottom is considered to have occurred when the price change exceeds the threshold within the given number of periods. The function returns a boolean that indicates whether a bottom has occurred.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.is_peaked-Tuple{DataFrames.DataFrame}","page":"Analysis","title":"Analysis.is_peaked","text":"Determines if a peak has occurred in the OHLCV data.\n\nis_peaked(ohlcv::DataFrames.DataFrame; thresh, n) -> Any\n\n\nThe is_peaked function takes the following parameters:\n\nohlcv: a DataFrame that represents OHLCV (Open, High, Low, Close, Volume) data.\nthresh (optional, default is 0.05): a threshold value which the price change must exceed to be considered a peak.\nn (optional, default is 26): an integer that represents the number of periods to consider for the peak detection.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.is_slopebetween-Tuple{DataFrames.DataFrame}","page":"Analysis","title":"Analysis.is_slopebetween","text":"Checks if slope of a DataFrame is within certain bounds.\n\nis_slopebetween(\n    ohlcv::DataFrames.DataFrame;\n    mn,\n    mx,\n    n\n) -> Any\n\n\nThis function takes a DataFrame ohlcv and optionally three integers mn (default is 5), mx (default is 90), and n (default is 26). It checks if the slope of a linear regression line fit to the last n data points in ohlcv is between mn and mx.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.is_uptrend-Tuple{DataFrames.DataFrame}","page":"Analysis","title":"Analysis.is_uptrend","text":"Determines if an uptrend has occurred in the OHLCV data.\n\nis_uptrend(ohlcv::DataFrames.DataFrame; thresh, n) -> Any\n\n\nThe is_uptrend function takes the following parameters:\n\nohlcv: a DataFrame that represents OHLCV (Open, High, Low, Close, Volume) data.\nthresh (optional, default is 0.05): a threshold value which the price change must exceed to be considered an uptrend.\nn (optional, default is 26): an integer that represents the number of periods to consider for the uptrend detection.\n\nThe function determines if an uptrend has occurred in the OHLCV data based on the specified threshold and number of periods. An uptrend is considered to have occurred when the price change exceeds the threshold within the given number of periods.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.isrenkoentry-Tuple{AbstractDict}","page":"Analysis","title":"Analysis.isrenkoentry","text":"Determines if the current state in a Renko chart indicates an entry point.\n\nisrenkoentry(data::AbstractDict; kwargs...) -> Vector{Bool}\n\n\nThe isrenkoentry function takes the following parameters:\n\ndata: an AbstractDict that represents the current state in a Renko chart.\nkwargs: a variable number of optional keyword arguments that allow you to specify additional criteria for an entry point.\n\nThe function determines if the current state in the Renko chart represented by data indicates an entry point based on the specified criteria. An entry point in a Renko chart is typically determined by a change in the direction of the bricks (or boxes).\n\nThe function returns a boolean that indicates whether the current state represents an entry point.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.isrenkoentry-Tuple{DataFrames.AbstractDataFrame}","page":"Analysis","title":"Analysis.isrenkoentry","text":"A good renko entry is determined by X candles of the opposite color after Y candles.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.maxmin-Tuple{Any}","page":"Analysis","title":"Analysis.maxmin","text":"Identifies maximum and minimum points in a DataFrame.\n\nmaxmin(df; order, threshold, window) -> Any\n\n\nThe maxmin function takes the following parameters:\n\ndf: a DataFrame in which to identify maxima and minima.\norder (optional, default is 1): an integer specifying how many points on each side of a point to use for the comparison to consider the point as a maximum or minimum. For example, if order=3, a point will be considered a maximum if it has three datapoints in either direction that are smaller than it.\nthreshold (optional, default is 0.0): a threshold value which the datapoint must exceed to be considered a maximum or minimum.\nwindow (optional, default is 100): a window size to apply a moving maximum/minimum filter.\n\nThe function identifies maximum and minimum points in the DataFrame df based on the specified order, threshold, and window. It then returns a DataFrame with the identified maxima and minima.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.renkodf-Tuple{Any}","page":"Analysis","title":"Analysis.renkodf","text":"Generates a Renko chart DataFrame.\n\nrenkodf(df; box_size, use_atr, n) -> Any\n\n\nThe renkodf function takes the following parameters:\n\ndf: a DataFrame that represents historical market data.\nbox_size (optional, default is 10.0): a float that represents the box size for the Renko chart. This is the minimum price change required to form a new brick in the chart.\nuse_atr (optional, default is false): a boolean that indicates whether to use the Average True Range (ATR) to determine the box size. If true, the function will calculate the ATR over n periods and use this as the box size.\nn (optional, default is 14): an integer that represents the number of periods to calculate the ATR over if use_atr is true.\n\nThe function generates a Renko chart DataFrame based on the input DataFrame df and the specified parameters. Renko charts are price charts with rising and falling bricks (or boxes) that are based on changes in price, not time, unlike most charts. They help filter out market noise and can be a useful tool in technical analysis. The function returns a DataFrame that represents the Renko chart.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.slopeangle-Tuple{Any}","page":"Analysis","title":"Analysis.slopeangle","text":"Calculates the slope angle for a given array.\n\nslopeangle(arr; n) -> Any\n\n\nThis function takes an array arr and optionally an integer n (default is 10). It calculates the slope angle of a linear regression line fit to the last n data points in arr.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.slopefilter","page":"Analysis","title":"Analysis.slopefilter","text":"Applies a slope filter to a dataset.\n\nslopefilter(\n;\n    ...\n) -> Vector{Tuple{AbstractFloat, Data.PairData}}\nslopefilter(\n    timeframe;\n    qc,\n    minv,\n    maxv,\n    window\n) -> Vector{Tuple{AbstractFloat, Data.PairData}}\n\n\nThis function applies a slope filter to a dataset. It checks whether the slope of a linear regression line fit to the data meets certain criteria, and retains only those data points that pass the filter.\n\n\n\n\n\n","category":"function"},{"location":"API/analysis/analysis/#Analysis.slopefilter-Tuple{AbstractDict}","page":"Analysis","title":"Analysis.slopefilter","text":"slopefilter over a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.supres-Tuple{Any}","page":"Analysis","title":"Analysis.supres","text":"Identifies support and resistance levels in a DataFrame.\n\nsupres(df; order, threshold, window) -> Any\n\n\nThe supres function takes the following parameters:\n\ndf: a DataFrame in which to identify support and resistance levels.\norder (optional, default is 1): an integer specifying how many points on each side of a point to use for the comparison to consider the point as a support or resistance level. For example, if order=3, a point will be considered a support/resistance level if it has three datapoints in either direction that are smaller/larger than it.\nthreshold (optional, default is 0.0): a threshold value which the datapoint must exceed to be considered a support or resistance level.\nwindow (optional, default is 16): a window size to apply a moving maximum/minimum filter.\n\nThe function identifies support and resistance levels in the DataFrame df based on the specified order, threshold, and window. It then returns a DataFrame with the identified support and resistance levels.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.up_successrate-Tuple{Any, Union{String, Symbol}}","page":"Analysis","title":"Analysis.up_successrate","text":"Calculates the success rate of given column against the next candle.\n\nup_successrate(\n    df,\n    bcol::Union{String, Symbol};\n    threshold\n) -> Any\n\n\nThe up_successrate function takes the following parameters:\n\ndf: a DataFrame that represents historical market data.\nbcol: a Symbol or String that represents the column name in df to calculate the success rate against.\nthreshold (optional, default is 0.05): a threshold value which the price change must exceed to be considered a success.\n\nThe function calculates the success rate of a particular strategy indicated by bcol for buying or selling. A trade is considered successful if the price change in the next candle exceeds the threshold. The direction of the trade (buy or sell) is determined by the bcol column: true for buy and false for sell.\n\nThe function returns a float that represents the success rate of the strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Base.filter-Tuple{Function, AbstractDict, Real, Real}","page":"Analysis","title":"Base.filter","text":"Filters and sorts a list of pairs using a predicate function.\n\nfilter(\n    pred::Function,\n    pairs::AbstractDict,\n    min_v::Real,\n    max_v::Real\n) -> Vector{Tuple{AbstractFloat, Data.PairData}}\n\n\nThis function takes a list of pairs and a predicate function. It filters the list by applying the predicate function to each pair and keeping only those pairs for which the function returns a Real number. The function then sorts the filtered list based on the returned Real numbers.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.Query.average_roc-Tuple{Any}","page":"Analysis","title":"Analysis.Query.average_roc","text":"Calculates the average Rate of Change (ROC) for a set of markets.\n\naverage_roc(mrkts) -> DataFrames.DataFrame\n\n\nThis function average_roc takes a set of markets mrkts as input. It calculates the average Rate of Change (ROC) for these markets over a certain period. The ROC is a momentum oscillator that measures the percentage change in price between the current price and the price a certain number of periods ago. The function returns the average ROC for the set of markets.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.Query.cbot-Tuple{DataFrames.AbstractDataFrame, Any}","page":"Analysis","title":"Analysis.Query.cbot","text":"Filter pairs in hs that are bottomed longs.\n\ncbot(\n    hs::DataFrames.AbstractDataFrame,\n    mrkts;\n    n,\n    min_n,\n    sort_col,\n    fb_kwargs\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.Query.cpek-Tuple{DataFrames.AbstractDataFrame, Any}","page":"Analysis","title":"Analysis.Query.cpek","text":"Filter pairs in hs that are peaked long.\n\ncpek(\n    hs::DataFrames.AbstractDataFrame,\n    mrkts;\n    n,\n    min_n,\n    sort_col,\n    fb_kwargs\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.Query.is_slopebetween-Tuple{DataFrames.DataFrame}","page":"Analysis","title":"Analysis.Query.is_slopebetween","text":"Checks if slope of a DataFrame is within certain bounds.\n\nis_slopebetween(\n    ohlcv::DataFrames.DataFrame;\n    mn,\n    mx,\n    n\n) -> Any\n\n\nThis function takes a DataFrame ohlcv and optionally three integers mn (default is 5), mx (default is 90), and n (default is 26). It checks if the slope of a linear regression line fit to the last n data points in ohlcv is between mn and mx.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.Query.last_day_roc-Tuple{Any, Any}","page":"Analysis","title":"Analysis.Query.last_day_roc","text":"Calculates the last day's Rate of Change (ROC) for a set of markets.\n\nlast_day_roc(r, mrkts) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.Query.slopeangle-Tuple{Any}","page":"Analysis","title":"Analysis.Query.slopeangle","text":"Calculates the slope angle for a given array.\n\nslopeangle(arr; n) -> Any\n\n\nThis function takes an array arr and optionally an integer n (default is 10). It calculates the slope angle of a linear regression line fit to the last n data points in arr.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.Query.slopefilter","page":"Analysis","title":"Analysis.Query.slopefilter","text":"Applies a slope filter to a dataset.\n\nslopefilter(\n;\n    ...\n) -> Vector{Tuple{AbstractFloat, Data.PairData}}\nslopefilter(\n    timeframe;\n    qc,\n    minv,\n    maxv,\n    window\n) -> Vector{Tuple{AbstractFloat, Data.PairData}}\n\n\nThis function applies a slope filter to a dataset. It checks whether the slope of a linear regression line fit to the data meets certain criteria, and retains only those data points that pass the filter.\n\n\n\n\n\n","category":"function"},{"location":"API/analysis/analysis/#Analysis.Query.slopefilter-Tuple{AbstractDict}","page":"Analysis","title":"Analysis.Query.slopefilter","text":"slopefilter over a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/analysis/analysis/#Analysis.Query.@bbranges","page":"Analysis","title":"Analysis.Query.@bbranges","text":"Calculates Bollinger Bands for a given market pair over a specified timeframe.\n\n\n\n\n\n","category":"macro"},{"location":"API/analysis/analysis/#Analysis.Query.@excfilter-Tuple{Any}","page":"Analysis","title":"Analysis.Query.@excfilter","text":"Filters exchange data based on slope angle and saves the output.\n\nThe excfilter macro takes a non-prefixed exchange name exc_name. It performs several operations:\n\nIf the CCXT instance for the exchange is not already loaded, it loads it.\nIt loads the pairs list and relative data for the exchange based on the current configuration settings.\nIt applies a filter to the data based on the slope angle.\nIt saves the output in the results dictionary under the key corresponding to the exchange name.\nThe output is a tuple of the form (trg, flt, data), where:\ntrg: The pairs, sorted by slope\nflt: The filtered pairs data\ndata: The full data for the exchange\n\nThis macro is useful for filtering and sorting pairs data for individual exchanges based on the slope angle.\n\n\n\n\n\n","category":"macro"},{"location":"API/data/#Data","page":"Data","title":"Data","text":"","category":"section"},{"location":"API/data/","page":"Data","title":"Data","text":"Modules = [PingPong.Data]","category":"page"},{"location":"API/data/#Data.OHLCV_CHUNK_SIZE","page":"Data","title":"Data.OHLCV_CHUNK_SIZE","text":"Default ZArray chunk size.\n\n\n\n\n\n","category":"constant"},{"location":"API/data/#Data.OHLCV_COLUMNS","page":"Data","title":"Data.OHLCV_COLUMNS","text":"Columns for OHLCV data: timestamp, open, high, low, close, volume\n\n\n\n\n\n","category":"constant"},{"location":"API/data/#Data.OHLCV_COLUMNS_COUNT","page":"Data","title":"Data.OHLCV_COLUMNS_COUNT","text":"Count of OHLCV_COLUMNS\n\n\n\n\n\n","category":"constant"},{"location":"API/data/#Data.OHLCV_COLUMNS_NOV","page":"Data","title":"Data.OHLCV_COLUMNS_NOV","text":"Only the OHLC columns of OHLCV_COLUMNS\n\n\n\n\n\n","category":"constant"},{"location":"API/data/#Data.OHLCV_COLUMNS_TS","page":"Data","title":"Data.OHLCV_COLUMNS_TS","text":"The timestamp column of OHLCV_COLUMNS\n\n\n\n\n\n","category":"constant"},{"location":"API/data/#Data.compressor","page":"Data","title":"Data.compressor","text":"Default zarr compressor used in the module (zstd, clevel=2).\n\n\n\n\n\n","category":"constant"},{"location":"API/data/#Data.Candle","page":"Data","title":"Data.Candle","text":"A struct representing a candlestick in financial trading.\n\ntimestamp\nopen\nhigh\nlow\nclose\nvolume\n\nCandle{T} is a parametric struct that represents a candlestick with generic type T, which must be a subtype of AbstractFloat.\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Data.DictView6","page":"Data","title":"Data.DictView6","text":"A view into a dictionary (a subset of keys).\n\nd\nkeys\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Data.EventTrace","page":"Data","title":"Data.EventTrace","text":"EventTrace structure for managing event data.\n\nlock\n_buf\n_zi\n_arr\n_cache\nfreq\nlast_flush\n\nRepresents a collection of events with caching capabilities. It is designed to efficiently handle large datasets by caching event data in memory. The structure includes a ZarrInstance for data storage, a ZArray for data access, a cache for temporary storage, a frequency for event timing, and an index for the next event.\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Data.LMDBDictStore","page":"Data","title":"Data.LMDBDictStore","text":"LMDBDictStore is a concrete implementation of the AbstractDictStore interface.\n\nLMDBDictStore represents a dictionary-like data store that uses LMDB as its backend. It is a subtype of AbstractDictStore defined in the Zarr package.\n\nLMDBDictStore has the following fields:\n\na: An instance of LMDBDict that represents the LMDB database.\nlock: A ReentrantLock used for thread-safety.\n\nLMDBDictStore can be created using the LMDBDictStore constructor function. It takes the following arguments:\n\npath::AbstractString: The path to the LMDB database.\nreset::Bool=false: If true, the LMDB database at the given path will be deleted and recreated.\nmapsize::Int=64MB: The maximum size of the LMDB database.\n\nLMDBDictStore implements the AbstractDictStore interface, which provides methods for reading and writing data to the store.\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Data.OHLCVTuple","page":"Data","title":"Data.OHLCVTuple","text":"Similar to a StructArray (and should probably be replaced by it), used for fast conversion.\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Data.PairData","page":"Data","title":"Data.PairData","text":"PairData is a low level struct, to attach some metadata to a ZArray. (deprecated)\"\n\nname\ntf\ndata\nz\n\nInstead of constructing a PairData, directly use the OHLCV DataFrame to hold the pair information and the ZArray itself.\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Data.TimeFrameError","page":"Data","title":"Data.TimeFrameError","text":"A custom exception representing a time frame error.\n\nfirst\nlast\ntd\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Data.ZarrInstance","page":"Data","title":"Data.ZarrInstance","text":"Candles data is stored with hierarchy PAIR -> [TIMEFRAMES...]. A pair is a ZGroup, a timeframe is a ZArray.\n\npath\nstore\ngroup\n\n\n\n\n\n","category":"type"},{"location":"API/data/#Base.Filesystem.rm-Tuple{LMDB.LMDBDict}","page":"Data","title":"Base.Filesystem.rm","text":"Remove all lmdb files associated with an LMDBDict object.\n\nrm(d::LMDB.LMDBDict) -> Union{Nothing, Bool}\n\n\nThis function removes all lmdb files associated with the given LMDBDict object. It deletes the lmdb database and all associated files.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Base.delete!-Tuple{Data.LMDBDictStore, Vararg{AbstractString}}","page":"Data","title":"Base.delete!","text":"Delete paths from an LMDBDictStore.\n\ndelete!(\n    store::Data.LMDBDictStore,\n    paths::AbstractString...;\n    recursive\n) -> Union{Nothing, LMDB.LMDBDict}\n\n\nThis function deletes the specified paths from an LMDBDictStore. It supports deleting paths recursively if the recursive parameter is set to true.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Base.delete!-Tuple{Zarr.DirectoryStore, Vararg{String}}","page":"Data","title":"Base.delete!","text":"Delete an element from a DirectoryStore. Also removes the directory.\n\ndelete!(\n    store::Zarr.DirectoryStore,\n    paths::String...;\n    recursive\n) -> Union{Nothing, Bool}\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Base.delete!-Tuple{Zarr.ZArray}","page":"Data","title":"Base.delete!","text":"Delete the ZArray from the underlying storage.\n\ndelete!(z::Zarr.ZArray; ok) -> Union{Nothing, Bool}\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Base.delete!-Tuple{Zarr.ZGroup, AbstractString}","page":"Data","title":"Base.delete!","text":"Delete an element from a ZGroup. If the element is a group, it will be recursively deleted.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Base.empty!-Tuple{LMDB.LMDBDict}","page":"Data","title":"Base.empty!","text":"Empty an LMDBDict object.\n\nempty!(d::LMDB.LMDBDict) -> Int32\n\n\nThis function empties an LMDBDict object by dropping the lmdb database and syncing the environment.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Base.empty!-Tuple{Zarr.ZArray}","page":"Data","title":"Base.empty!","text":"Resizes a ZArray to zero.\n\nempty!(z::Zarr.ZArray) -> Zarr.ZArray\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Base.empty!-Tuple{Zarr.ZGroup}","page":"Data","title":"Base.empty!","text":"Removes all arrays and groups from a ZGroup.\n\nempty!(g::Zarr.ZGroup)\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Base.isempty-Tuple{Zarr.ZArray}","page":"Data","title":"Base.isempty","text":"A ZArray is empty if its size is 0.\n\nisempty(z::Zarr.ZArray) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Base.unique!-Tuple{Function, Zarr.ZArray}","page":"Data","title":"Base.unique!","text":"Remove duplicate from a zarray.\n\nIn a 2d zarray where we want values where the second column is unique:\n\nunique!(x->x[2], z)\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data._check_contiguity-Tuple{AbstractFloat, AbstractFloat, AbstractFloat, AbstractFloat, Any}","page":"Data","title":"Data._check_contiguity","text":"Check the contiguity of timestamps between data and saved data.\n\n_check_contiguity(\n    data_first_ts::AbstractFloat,\n    data_last_ts::AbstractFloat,\n    saved_first_ts::AbstractFloat,\n    saved_last_ts::AbstractFloat,\n    td\n) -> Bool\n\n\nUsed to check the contiguity of timestamps between the data and saved data. It takes in the first and last timestamps of the data (data_first_ts and data_last_ts) and the first and last timestamps of the saved data (saved_first_ts and saved_last_ts). Typically used as a helper function within the context of saving or loading OHLCV data to ensure the contiguity of timestamps.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data._get_zarray-Tuple{Data.ZarrInstance, AbstractString, Tuple}","page":"Data","title":"Data._get_zarray","text":"Get a ZArray object from a ZarrInstance.\n\n_get_zarray(\n    zi::Data.ZarrInstance,\n    key::AbstractString,\n    sz::Tuple;\n    type,\n    overwrite,\n    reset\n)\n\n\nThis function is used to retrieve a ZArray object from a ZarrInstance. It takes in the ZarrInstance, key, size, and other optional parameters and returns the ZArray object.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data._load_ohlcv-Tuple{Zarr.ZArray, Any}","page":"Data","title":"Data._load_ohlcv","text":"Load ohlcv pair data from zarr instance. za: The zarr array holding the data key: the name of the array to load from the zarr instance (in the format exchange/timeframe/pair) td: the timeframe (as integer in milliseconds) of the target ohlcv table to be loaded from, to: date range\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.candleat-Union{Tuple{D}, Tuple{D, Dates.DateTime}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.candleat","text":"Get the candle at given date from a ohlcv dataframe as a Candle.\n\ncandleat(\n    df::DataFrames.AbstractDataFrame,\n    date::Dates.DateTime;\n    return_idx\n) -> Union{Data.Candle{Float64}, Tuple{Data.Candle{Float64}, Union{Int64, DataStructures.Tokens.IntSemiToken}}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.candleavl-Union{Tuple{D}, Tuple{D, TimeFrames.TimeFrame, Any}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.candleavl","text":"Fetch the candle expected to be available at a specific date and time frame from an OHLCV DataFrame.\n\ncandleavl(\n    df::DataFrames.AbstractDataFrame,\n    tf::TimeFrames.TimeFrame,\n    date\n) -> Union{Data.Candle{Float64}, Tuple{Data.Candle{Float64}, Union{Int64, DataStructures.Tokens.IntSemiToken}}}\n\n\nThe available candle is usually the candle that is date-wise left adjacent to the requested date.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.candlelast-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.candlelast","text":"Get the last candle from a ohlcv dataframe as a Candle.\n\ncandlelast(\n    df::DataFrames.AbstractDataFrame\n) -> Data.Candle{Float64}\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.candlepair-Union{Tuple{D}, Tuple{D, Dates.DateTime}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.candlepair","text":"Same as candleat but also fetches the previous candle, returning a Tuple{Candle, Candle}.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.check_data-Tuple{Any, Zarr.ZArray}","page":"Data","title":"Data.check_data","text":"Check the size of data against a ZArray.\n\ncheck_data(data, arr::Zarr.ZArray)\n\n\nUsed to check the size of data against a ZArray arr. It takes in the data and the ZArray arr as input. Compares the size of the data with the size of the ZArray. If the sizes do not match, it raises a SizeMismatchError.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.chunksize-Tuple{Any}","page":"Data","title":"Data.chunksize","text":"Choose chunk size depending on size of data with a predefined split (e.g. 1/100), padding to the nearest power of 2.\n\nchunksize(data; parts, def) -> Tuple{Any, Vararg{Any}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.closeat-Union{Tuple{D}, Tuple{D, Dates.DateTime}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.closeat","text":"See @candleat.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.closeavl-Union{Tuple{D}, Tuple{D, TimeFrames.TimeFrame, Any}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.closeavl","text":"See @candleavl\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.closelast-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.closelast","text":"See @candlelast\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.contiguous_ts-Tuple{Any, AbstractString}","page":"Data","title":"Data.contiguous_ts","text":"Check if a time series is contiguous based on a specified timeframe.\n\ncontiguous_ts(\n    series,\n    timeframe::AbstractString;\n    raise,\n    return_date\n) -> Union{Bool, Tuple{Bool, Any, Any}}\n\n\nThis function is used to check if a time series is contiguous based on a specified timeframe. It takes in the series as the input time series and the timeframe as a string representing the timeframe (e.g., \"1h\", \"1d\"). Optional parameters raise and return_date can be specified to customize the behavior of the function.\n\nraise: A flag indicating whether to raise a TimeFrameError if the time series is not contiguous. Default is true.\nreturn_date: A flag indicating whether to return the first non-contiguous date found in the time series. Default is false.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.default_value-Tuple{T} where T<:Type","page":"Data","title":"Data.default_value","text":"Get the default value of a given type t.\n\ndefault_value(t::Type) -> Data.Candle{Float64}\n\n\nThis function returns the default value of the specified type t.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.df!-Tuple","page":"Data","title":"Data.df!","text":"Construct a DataFrame without copying.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.empty_ohlcv-Tuple{}","page":"Data","title":"Data.empty_ohlcv","text":"An empty OHLCV dataframe.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.get_zgroup-Tuple{Zarr.AbstractStore}","page":"Data","title":"Data.get_zgroup","text":"Get the root group of a store.\n\nget_zgroup(store::Zarr.AbstractStore) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.highat-Union{Tuple{D}, Tuple{D, Dates.DateTime}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.highat","text":"See @candleat.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.highavl-Union{Tuple{D}, Tuple{D, TimeFrames.TimeFrame, Any}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.highavl","text":"See @candleavl\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.highlast-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.highlast","text":"See @candlelast\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.key_path-Tuple{Any, Any, Any}","page":"Data","title":"Data.key_path","text":"The full key of the data stored for the (exchange, pair, timeframe) combination.\n\nkey_path(exc_name, pair, timeframe) -> String\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.load-Tuple{Data.ZarrInstance, Any, Any, Any}","page":"Data","title":"Data.load","text":"Load a pair ohlcv data from storage. as_z: returns the ZArray\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.load_data-Tuple{Data.ZarrInstance, Any}","page":"Data","title":"Data.load_data","text":"Load data from zarr instance.\n\nload_data(\n    zi::Data.ZarrInstance,\n    key;\n    serialized,\n    kwargs...\n) -> Any\n\n\nzi: The zarr instance to use\nkey: the name of the array to load from the zarr instance (full key path).\ntype: Set to the type that zarr should use to store the data (only bits types). [Float64].\nsz: The chunks tuple which should match the shape of the already saved data.\nfrom: The starting index to load the data from. Default is an empty string, indicating no specific starting index.\nto: The ending index to load the data up to. Default is an empty string, indicating no specific ending index.\nz_col: The column in the Zarr array to load the data from. Default is 1.\ntype: The type of the data to be loaded. Default is Float64.\nserialized: A flag indicating whether the data is serialized. Default is false. If true, type is ignored.\nas_z: A flag indicating whether to return the loaded data as a ZArray. Default is false.\nwith_z: A flag indicating whether to return the loaded data along with the Zarr array (as tuple). Default is false.\n\nwarning: Mismatching chunks\nLoading data with from key with wrong dimensions (ndims(sz)) or shape (columns) will reset the stored zarray.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.load_ohlcv-Tuple{Data.ZarrInstance, AbstractString, Any, Any}","page":"Data","title":"Data.load_ohlcv","text":"Load OHLCV data from a ZarrInstance.\n\nload_ohlcv(\n    zi::Data.ZarrInstance,\n    exc_name::AbstractString,\n    pairs,\n    timeframe;\n    raw,\n    kwargs...\n) -> Dict{String}\n\n\nraw: A flag indicating whether to return the raw data or process it into an OHLCV format. Default is false.\nfrom: The starting timestamp (inclusive) for loading data. Default is an empty string, indicating loading from the beginning of the ZArray.\nto: The ending timestamp (exclusive) for loading data. Default is an empty string, indicating loading until the end of the ZArray.\nsaved_col: The column index of the timestamp data in the ZArray. Default is 1.\nas_z: A flag indicating whether to return the loaded data as a ZArray. Default is false.\nwith_z: A flag indicating whether to return the loaded data along with the ZArray object. Default is false.\n\nThis function is used to load OHLCV data from a ZarrInstance. It takes in the ZarrInstance zi, the exchange name exc_name, the currency pairs pairs, and the timeframe. Optional parameters raw and kwargs can be specified to customize the loading process.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.lowat-Union{Tuple{D}, Tuple{D, Dates.DateTime}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.lowat","text":"See @candleat.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.lowavl-Union{Tuple{D}, Tuple{D, TimeFrames.TimeFrame, Any}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.lowavl","text":"See @candleavl\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.lowlast-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.lowlast","text":"See @candlelast\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.ohlcvtuple-Tuple{}","page":"Data","title":"Data.ohlcvtuple","text":"Default OHLCVTuple value.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.openat-Union{Tuple{D}, Tuple{D, Dates.DateTime}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.openat","text":"See @candleat.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.openavl-Union{Tuple{D}, Tuple{D, TimeFrames.TimeFrame, Any}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.openavl","text":"See @candleavl\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.openlast-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.openlast","text":"See @candlelast\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.save_data-Tuple{Data.ZarrInstance, Any, Any}","page":"Data","title":"Data.save_data","text":"Save data to a ZarrInstance with additional options.\n\nsave_data(\n    zi::Data.ZarrInstance,\n    key,\n    data;\n    serialize,\n    data_col,\n    kwargs...\n) -> Any\n\n\ntype: The type of the data to be saved. Default is Float64.\ndata_col: The column of the data to be saved. Default is 1.\nz_col: The column in the Zarr array to save the data. Default is the same as data_col.\noverwrite: A flag indicating whether to overwrite existing data at the specified key. Default is true.\nreset: A flag indicating whether to reset the Zarr array before saving the data. Default is false.\nchunk_size: The size of the chunks to use when saving the data. Default is nothing, indicating auto-chunking.\n\nOnly dates seriality is ensured, not contiguity (unlike save_ohlcv) It creates a new array if needed, sets the chunk size if specified.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.save_ohlcv-Tuple{Data.ZarrInstance, Vararg{Any, 4}}","page":"Data","title":"Data.save_ohlcv","text":"Save OHLCV data to a ZArray.\n\nsave_ohlcv(\n    zi::Data.ZarrInstance,\n    exc_name,\n    pair,\n    timeframe,\n    data;\n    kwargs...\n) -> Union{Nothing, Zarr.ZArray}\n\n\ndata_col: The column index of the timestamp data in the input data. Default is 1.\nsaved_col: The column index of the timestamp data in the existing data. Default is equal to data_col.\ntype: The primitive type used for storing the data. Default is Float64.\nexisting: A flag indicating whether existing data should be considered during the save operation. Default is true.\noverwrite: A flag indicating whether existing data should be overwritten during the save operation. Default is true.\nreset: A flag indicating whether the ZArray should be reset before saving the data. Default is false.\ncheck:\n:bounds (default) only checks that new data is adjacent to previous data.\n:all checks full contiguity of previous and new data.\n:none or anything else, no checks are done.\n\nThe saveohlcv function saves OHLCV data to a ZArray. It performs checks on the input data and existing data (if applicable) to ensure contiguity and validity. If the checks pass, it calculates the offset based on the time difference between the first timestamps of the new and existing data. Then, it updates the ZArray with the new data starting at the calculated offset. The function provides various optional parameters to customize the save operation, such as handling existing data, overwriting, resetting, and performing checks.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.snakecased-Tuple{AbstractString}","page":"Data","title":"Data.snakecased","text":"Normalizes or special characthers separators to _.\n\nsnakecased(pair::AbstractString) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.stub!-Tuple","page":"Data","title":"Data.stub!","text":"A stub! function usually fills a container with readily available data.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.to_ohlcv-Tuple{Matrix}","page":"Data","title":"Data.to_ohlcv","text":"Convert raw ccxt OHLCV data (matrix) to a dataframe.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.to_ohlcv-Tuple{Tuple{Vector{Dates.DateTime}, Vararg{Vector{Float64}, 5}}}","page":"Data","title":"Data.to_ohlcv","text":"Construct an OHLCV dataframe backed by an OHLCVTuple.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.to_ohlcv-Union{Tuple{T}, Tuple{V}, Tuple{V, T}} where {V<:AbstractVector{Data.Candle}, T<:TimeFrames.TimeFrame}","page":"Data","title":"Data.to_ohlcv","text":"Convert data to OHLCV format.\n\nto_ohlcv(\n    data::AbstractVector{Data.Candle},\n    timeframe::TimeFrames.TimeFrame\n) -> Any\n\n\nThis function converts the input data to the OHLCV (Open, High, Low, Close, Volume) format, using the specified timeframe. It returns the converted data as a DataFrame.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.tobytes-Tuple{Any}","page":"Data","title":"Data.tobytes","text":"Convert a value data to its byte representation.\n\ntobytes(data) -> Vector{UInt8}\n\n\nThis function converts the input value data to its byte representation.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.todata-Tuple{Any}","page":"Data","title":"Data.todata","text":"Convert a byte array bytes to its original data representation.\n\ntodata(bytes) -> Any\n\n\nThis function converts the input byte array bytes back to its original data representation.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.volumeat-Union{Tuple{D}, Tuple{D, Dates.DateTime}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.volumeat","text":"See @candleat.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.volumeavl-Union{Tuple{D}, Tuple{D, TimeFrames.TimeFrame, Any}} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.volumeavl","text":"See @candleavl\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.volumelast-Tuple{D} where D<:DataFrames.AbstractDataFrame","page":"Data","title":"Data.volumelast","text":"See @candlelast\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.zdelete!-Tuple{Zarr.ZArray, Union{Nothing, Dates.DateTime}, Union{Nothing, Dates.DateTime}}","page":"Data","title":"Data.zdelete!","text":"Delete elements from a ZArray z within a specified date range.\n\nzdelete!(\n    z::Zarr.ZArray,\n    from_dt::Union{Nothing, Dates.DateTime},\n    to_dt::Union{Nothing, Dates.DateTime};\n    by,\n    select,\n    serialized,\n    buffer\n)\n\n\nThis function deletes elements from a ZArray z that fall within the specified date range. The range is defined by from_dt (inclusive) and to_dt (exclusive). The deletion is performed in place.\n\nThe by argument is optional and defaults to the identity function. It specifies the function used to extract the date value from each element of the ZArray. The select argument is optional and defaults to a function that selects the first column of each element in the ZArray. It specifies the function used to select the relevant portion of each element for deletion. The serialized argument is optional and defaults to false. If set to true, the ZArray is assumed to be serialized, and the deletion is performed on the serialized representation. The buffer argument is optional and can be used to provide an IOBuffer for intermediate storage during deletion.\n\n\n\n\n\n","category":"method"},{"location":"API/data/#Data.zilmdb","page":"Data","title":"Data.zilmdb","text":"Create a ZarrInstance at specified path using lmdb as backend.\n\nzilmdb(; ...) -> Data.ZarrInstance\nzilmdb(path::AbstractString; force) -> Data.ZarrInstance\n\n\nThis function creates a ZarrInstance object at the specified path using lmdb as the backend. It has an optional parameter 'force' to reset the underlying store.\n\n\n\n\n\n","category":"function"},{"location":"API/data/#Data.@as_mat-Tuple{Any}","page":"Data","title":"Data.@as_mat","text":"Redefines given variable to a Matrix with type of the underlying container type.\n\n\n\n\n\n","category":"macro"},{"location":"API/data/#Data.@candleat-Tuple{Any}","page":"Data","title":"Data.@candleat","text":"Get the candle value at a specific date from an OHLCV DataFrame.\n\nThis function returns the requested value at the specified date from the input OHLCV DataFrame. The optional parameter return_idx determines whether to also return the index of the opening price.\n\n\n\n\n\n","category":"macro"},{"location":"API/data/#Data.@candleavl-Tuple{Any}","page":"Data","title":"Data.@candleavl","text":"Fetch the candle value expected to be available at a specific date and time frame from an OHLCV DataFrame.\n\nThe available candle is usually the candle that is date-wise left adjacent to the requested date.\n\n\n\n\n\n","category":"macro"},{"location":"API/data/#Data.@candlelast-Tuple{Any}","page":"Data","title":"Data.@candlelast","text":"Get the last candle value from an OHLCV DataFrame (df).\n\n\n\n\n\n","category":"macro"},{"location":"API/data/#Data.@check_td-Tuple","page":"Data","title":"Data.@check_td","text":"Check the time delta between two rows in a DataFrame.\n\nThis macro is used to check the time delta between two DataFrame to ensure they are of the same time delta. It throws a TimeFrameError if the time delta does not match the specified time delta value. If no args are provided, the macro uses the za value as the default data to check.\n\n\n\n\n\n","category":"macro"},{"location":"API/data/#Data.@checkkey-Tuple{Any}","page":"Data","title":"Data.@checkkey","text":"Macro for checking if a key exists in a DictView.\n\nThis macro checks if a given key is present in the keys field of the DictView (d).\n\n\n\n\n\n","category":"macro"},{"location":"API/data/#Data.@to_mat","page":"Data","title":"Data.@to_mat","text":"Same as as_mat but returns the new matrix.\n\n\n\n\n\n","category":"macro"},{"location":"API/data/#Data.@zcreate-Tuple{}","page":"Data","title":"Data.@zcreate","text":"Create a ZArray using the zcreate macro.\n\nThis macro is used to create a ZArray object. It provides a convenient syntax for creating and initializing a ZArray with the specified elements. It's a dirty macro. Uses existing variables:\n\ntype: eltype of the array.\nkey: path of the array.\nsz: size of the array.\nzi: ZarrInstance object.\n\n\n\n\n\n","category":"macro"},{"location":"API/pbar/#Pbar","page":"Pbar","title":"Pbar","text":"","category":"section"},{"location":"API/pbar/","page":"Pbar","title":"Pbar","text":"Modules = [Pbar]","category":"page"},{"location":"API/pbar/#Pbar.Pbar","page":"Pbar","title":"Pbar.Pbar","text":"Progress bar wrapper.\n\n\n\n\n\n","category":"module"},{"location":"API/pbar/#Pbar.last_render","page":"Pbar","title":"Pbar.last_render","text":"Stores the timestamp of the last render in the progress bar.\n\n\n\n\n\n","category":"constant"},{"location":"API/pbar/#Pbar.min_delta","page":"Pbar","title":"Pbar.min_delta","text":"Stores the minimum time difference required between two render updates.\n\n\n\n\n\n","category":"constant"},{"location":"API/pbar/#Pbar.pbar","page":"Pbar","title":"Pbar.pbar","text":"Holds a reference to the current progress bar or nothing if no progress bar is active.\n\n\n\n\n\n","category":"constant"},{"location":"API/pbar/#Pbar.pbar_lock","page":"Pbar","title":"Pbar.pbar_lock","text":"Holds a lock to avoid flickering when updating the progress bar.\n\n\n\n\n\n","category":"constant"},{"location":"API/pbar/#Pbar.pbj","page":"Pbar","title":"Pbar.pbj","text":"The current job being rendered.\n\n\n\n\n\n","category":"constant"},{"location":"API/pbar/#Pbar.plu","page":"Pbar","title":"Pbar.plu","text":"The last update timestamp.\n\n\n\n\n\n","category":"constant"},{"location":"API/pbar/#Pbar.RunningJob","page":"Pbar","title":"Pbar.RunningJob","text":"Represents a job that is currently running in the progress bar.\n\njob\ncounter\nupdated_at\n\nThe RunningJob struct holds a ProgressJob, a counter, and a timestamp of when it was last updated. The job field is of type ProgressJob which represents the job that is currently running. The counter field is an integer that defaults to 1 and is used to keep track of the progress of the job. The updated_at field is a DateTime object that stores the timestamp of when the job was last updated.\n\n\n\n\n\n","category":"type"},{"location":"API/pbar/#Pbar.clearpbar","page":"Pbar","title":"Pbar.clearpbar","text":"Clears the current progress bar.\n\nclearpbar() -> Union{Nothing, Bool}\nclearpbar(pb) -> Union{Nothing, Bool}\n\n\nThe clearpbar function stops all jobs in the current progress bar, empties the job list, and then stops the progress bar itself. It uses a lock to ensure thread safety during these operations.\n\n\n\n\n\n","category":"function"},{"location":"API/pbar/#Pbar.complete!","page":"Pbar","title":"Pbar.complete!","text":"Complete a job.\n\n\n\n\n\n","category":"function"},{"location":"API/pbar/#Pbar.dorender","page":"Pbar","title":"Pbar.dorender","text":"Renders the progress bar if enough time has passed since the last render.\n\n\n\n\n\n","category":"function"},{"location":"API/pbar/#Pbar.frequency!-Tuple{Any}","page":"Pbar","title":"Pbar.frequency!","text":"Set the update frequency globally.\n\n\n\n\n\n","category":"method"},{"location":"API/pbar/#Pbar.pbar!-Tuple{}","page":"Pbar","title":"Pbar.pbar!","text":"Initializes a new progress bar.\n\npbar!(\n;\n    transient,\n    columns,\n    kwargs...\n) -> Term.Progress.ProgressBar\n\n\nThe pbar! function first clears any existing progress bar, then creates a new ProgressBar with the provided arguments. The transient argument defaults to true, and columns defaults to :default.\n\n\n\n\n\n","category":"method"},{"location":"API/pbar/#Pbar.pbclose!","page":"Pbar","title":"Pbar.pbclose!","text":"Stops the progress bar after completing the job.\n\n\n\n\n\n","category":"function"},{"location":"API/pbar/#Pbar.pbclose!-2","page":"Pbar","title":"Pbar.pbclose!","text":"Terminates the progress bar.\n\npbclose!()\npbclose!(pb::Term.Progress.ProgressBar)\npbclose!(pb::Term.Progress.ProgressBar, all)\n\n\nThe pbclose! function completes all jobs in the progress bar and then stops the progress bar itself.\n\n\n\n\n\n","category":"function"},{"location":"API/pbar/#Pbar.startjob!","page":"Pbar","title":"Pbar.startjob!","text":"Starts a new job in the progress bar.\n\n\n\n\n\n","category":"function"},{"location":"API/pbar/#Pbar.transient!","page":"Pbar","title":"Pbar.transient!","text":"Toggles pbar transient flag\n\n\n\n\n\n","category":"function"},{"location":"API/pbar/#Pbar.@pbar!","page":"Pbar","title":"Pbar.@pbar!","text":"Instantiate a progress bar:\n\ndata: length(data) determines the bar total\nunit: what unit the display\ndesc: description will appear over the progressbar\n\n\n\n\n\n","category":"macro"},{"location":"API/pbar/#Pbar.@pbclose!-Tuple{}","page":"Pbar","title":"Pbar.@pbclose!","text":"Calls pbclose! on the global progress bar.\n\n\n\n\n\n","category":"macro"},{"location":"API/pbar/#Pbar.@pbinit!-Tuple{}","page":"Pbar","title":"Pbar.@pbinit!","text":"Initializes the progress bar.\n\n\n\n\n\n","category":"macro"},{"location":"API/pbar/#Pbar.@pbstop!-Tuple{}","page":"Pbar","title":"Pbar.@pbstop!","text":"Stops the progress bar.\n\n\n\n\n\n","category":"macro"},{"location":"API/pbar/#Pbar.@pbupdate!","page":"Pbar","title":"Pbar.@pbupdate!","text":"Single update to the progressbar with the new value.\n\n\n\n\n\n","category":"macro"},{"location":"API/pbar/#Pbar.@withpbar!-Tuple{Any, Vararg{Any}}","page":"Pbar","title":"Pbar.@withpbar!","text":"Same as @pbar! but with implicit closing.\n\nThe first argument should be the collection to iterate over. Optional kw arguments:\n\ndesc: description\n\n\n\n\n\n","category":"macro"},{"location":"API/exchanges/#Exchanges","page":"Exchanges","title":"Exchanges","text":"","category":"section"},{"location":"API/exchanges/","page":"Exchanges","title":"Exchanges","text":"Modules = [PingPong.Exchanges, PingPong.Exchanges.ExchangeTypes]","category":"page"},{"location":"API/exchanges/#Exchanges.LEVERAGED_PAIR_OPTIONS","page":"Exchanges","title":"Exchanges.LEVERAGED_PAIR_OPTIONS","text":"A leveraged pair is a pair like BTC3L/USD.\n\n:yes : Leveraged pairs will not be filtered.\n:only : ONLY leveraged will be kept.\n:from : Selects non leveraged pairs, that also have at least one leveraged sibling.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.MARKET_TYPES","page":"Exchanges","title":"Exchanges.MARKET_TYPES","text":"Ccxt market types.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.TICKERSLIST_LOCK_DICT","page":"Exchanges","title":"Exchanges.TICKERSLIST_LOCK_DICT","text":"Lock held when fetching tickers (list).\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.TICKERS_CACHE100","page":"Exchanges","title":"Exchanges.TICKERS_CACHE100","text":"The cache for tickers which lasts for 100 minutes by exchange pair.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.activeCache1Min","page":"Exchanges","title":"Exchanges.activeCache1Min","text":"Caches active states (1minute).\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.currenciesCache1Hour","page":"Exchanges","title":"Exchanges.currenciesCache1Hour","text":"The cache for currencies which lasts for 1 hour by exchange.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.currency_lock","page":"Exchanges","title":"Exchanges.currency_lock","text":"This lock is only used during currency construction.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.leverageTiersCache","page":"Exchanges","title":"Exchanges.leverageTiersCache","text":"Leverage tiers are cached both in RAM and storage.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.marketsCache1Min","page":"Exchanges","title":"Exchanges.marketsCache1Min","text":"Caches markets (1minute).\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.tickersCache10Sec","page":"Exchanges","title":"Exchanges.tickersCache10Sec","text":"Caches tickers (10seconds).\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.tickersLockDict","page":"Exchanges","title":"Exchanges.tickersLockDict","text":"Lock held when fetching tickers (per ticker).\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#Exchanges.CcxtTrade","page":"Exchanges","title":"Exchanges.CcxtTrade","text":"A named tuple representing a trade in the CCXT (CryptoCurrency eXchange Trading) library.\n\ntimestamp\nsymbol\norder\ntype\nside\ntakerOrMaker\nprice\namount\ncost\nfee\nfees\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#Exchanges.CurrencyCash","page":"Exchanges","title":"Exchanges.CurrencyCash","text":"A CurrencyCash contextualizes a Cash instance w.r.t. an exchange. Operations are rounded to the currency precision.\n\ncash\nlimits\nprecision\nfees\nsandbox\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#Exchanges.CurrencyCash-Tuple{Type{<:ExchangeID}, Type{<:Cash}, Any}","page":"Exchanges","title":"Exchanges.CurrencyCash","text":"Create a CurrencyCash object.\n\nCurrencyCash(\n    id::Type{<:ExchangeID},\n    cash_type::Type{<:Cash},\n    v;\n    sandbox\n) -> Exchanges.CurrencyCash\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.LeverageTier","page":"Exchanges","title":"Exchanges.LeverageTier","text":"A type representing a tier of leverage.\n\nmin_notional\nmax_notional\nmax_leverage\ntier\nmmr\nbc\n\nThis type is used to store and manage information about a specific leverage tier. Each tier is defined by its minimum and maximum notional values, maximum leverage, tier number, and maintenance margin requirement.\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#Exchanges.LeverageTiersDict","page":"Exchanges","title":"Exchanges.LeverageTiersDict","text":"Every asset has a list of leverage tiers, that are stored in a SortedDict, if the exchange supports them.\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#Exchanges.TradeRole","page":"Exchanges","title":"Exchanges.TradeRole","text":"Taker Or Maker\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#Exchanges.TradeSide","page":"Exchanges","title":"Exchanges.TradeSide","text":"Buy or Sell\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#Ccxt.issupported-Tuple{TimeFrames.TimeFrame, Any}","page":"Exchanges","title":"Ccxt.issupported","text":"Check if a timeframe is supported by an exchange.\n\nissupported(tf::TimeFrames.TimeFrame, exc) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Data.load_ohlcv-Tuple{AbstractString}","page":"Exchanges","title":"Data.load_ohlcv","text":"Loads all pairs for a given timeframe, matching the global exc (Exchange object) and config.\n\nload_ohlcv(timeframe::AbstractString; kwargs...) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Data.load_ohlcv-Tuple{Exchange, AbstractString}","page":"Exchanges","title":"Data.load_ohlcv","text":"Loads all pairs for a given exchange and timeframe, matching the global config and zi (Zarr Instance).\n\nload_ohlcv(\n    exc::Exchange,\n    timeframe::AbstractString;\n    kwargs...\n) -> Dict{String}\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Data.load_ohlcv-Tuple{Union{AbstractDict, AbstractArray}, AbstractString}","page":"Exchanges","title":"Data.load_ohlcv","text":"Load given pairs from the global exc (Exchange object) and zi (Zarr Instance).\n\nload_ohlcv(\n    pairs::Union{AbstractDict, AbstractArray},\n    timeframe::AbstractString;\n    kwargs...\n) -> Dict{String}\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Data.load_ohlcv-Tuple{}","page":"Exchanges","title":"Data.load_ohlcv","text":"Load all pairs from the exchange according to the configured quote currency and timeframe.\n\nload_ohlcv() -> Dict{String}\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Data.save_ohlcv-Tuple{Any, Any, Any}","page":"Exchanges","title":"Data.save_ohlcv","text":"Updates pair data of the globally set Exchange instance.\n\nsave_ohlcv(pair, timeframe, data; kwargs...)\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges._cur-Tuple{Any, Any}","page":"Exchanges","title":"Exchanges._cur","text":"Returns the currency from the exchange if found.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges._lpf-Tuple{Any, Any}","page":"Exchanges","title":"Exchanges._lpf","text":"Returns the limits, precision, and fees for a currency as a named tuple.\n\n_lpf(\n    exc,\n    cur\n) -> NamedTuple{(:limits, :precision, :fees), <:Tuple{@NamedTuple{min::Float64, max::Float64}, Union{Float64, Int64}, Number}}\n\n\nThe tuple fields can be nothing if the currency property is not provided.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges._setfees!-Tuple{Any, Any, Any}","page":"Exchanges","title":"Exchanges._setfees!","text":"Ccxt fees can have different forms.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.accounts-Tuple{Exchange}","page":"Exchanges","title":"Exchanges.accounts","text":"The accounts available for the exchange.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.check-Tuple{Exchange}","page":"Exchanges","title":"Exchanges.check","text":"Checks if the python exchange instance supports all the calls required by PingPong.\n\ncheck(exc::Exchange; type)\n\n\nexc: an Exchange object to perform the check on.\ntype (optional, default is :basic): a symbol representing the type of check to perform.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.check_timeout","page":"Exchanges","title":"Exchanges.check_timeout","text":"Check that the exchange timeout is not too low wrt the interval.\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.current_account-Tuple{Exchange}","page":"Exchanges","title":"Exchanges.current_account","text":"The account currently being used by the exchange.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.default_leverage_tier-Tuple{Any}","page":"Exchanges","title":"Exchanges.default_leverage_tier","text":"Returns a default leverage tier for a specific symbol.\n\ndefault_leverage_tier(\n    sym\n) -> SortedDict{Int64, Exchanges.LeverageTier{Float64}, Base.Order.ForwardOrdering}\n\n\nThe default leverage tier has generous limits.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.emptycaches!-Tuple{}","page":"Exchanges","title":"Exchanges.emptycaches!","text":"Clears all Python-dependent caches.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.exckeys!-Tuple{Any}","page":"Exchanges","title":"Exchanges.exckeys!","text":"Set exchange api keys.\n\nexckeys!(exc; sandbox)\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.filter_markets-Tuple{Any}","page":"Exchanges","title":"Exchanges.filter_markets","text":"Get the markets of the ccxt instance, according to min_volume and quote currency.\n\nfilter_markets(exc; min_volume, quot, sep) -> Dict{Any, Any}\n\n\nThe filter_markets function takes the following parameters:\n\nexc: an Exchange object to get the markets from.\nmin_volume (optional, default is 10e4): the minimum volume that a market should have.\nquot (optional, default is \"USDT\"): the quote currency to filter the markets by.\nsep (optional, default is '/'): the separator used in market strings.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.futures-Tuple{Exchange}","page":"Exchanges","title":"Exchanges.futures","text":"Returns the matching futures exchange instance, if it exists, or the input exchange otherwise.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.getexchange!","page":"Exchanges","title":"Exchanges.getexchange!","text":"getexchage!: ccxt exchange by symbol either from cache or anew.\n\ngetexchange!(x::Symbol; ...) -> Exchange\ngetexchange!(\n    x::Symbol,\n    params;\n    sandbox,\n    markets,\n    kwargs...\n) -> Exchange\n\n\nIt uses a WS instance if available, otherwise an async instance.\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.getexchange-Tuple{}","page":"Exchanges","title":"Exchanges.getexchange","text":"Get the global exchange.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.has_leverage-Tuple{Any, Any}","page":"Exchanges","title":"Exchanges.has_leverage","text":"True if pair is a leveraged pair.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.hastickers-Tuple{Exchange}","page":"Exchanges","title":"Exchanges.hastickers","text":"Check if exchange has tickers list.\n\nhastickers(exc::Exchange) -> Union{Missing, Bool}\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.hasvolume-Tuple{Any, Any}","page":"Exchanges","title":"Exchanges.hasvolume","text":"True if symbol sym has a quote volume less than min_vol.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.is_pair_active","page":"Exchanges","title":"Exchanges.is_pair_active","text":"Check if a currency pair is active on an exchange.\n\nis_pair_active(pair::AbstractString) -> Any\nis_pair_active(pair::AbstractString, exc::Exchange) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.isfileyounger-Tuple{AbstractString, Dates.Period}","page":"Exchanges","title":"Exchanges.isfileyounger","text":"Checks if a file is younger than a specified period.\n\nisfileyounger(f::AbstractString, p::Dates.Period) -> Any\n\n\nf: a string that represents the path to the file.\np: a Period object that represents the time period.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.ismargin-Tuple{Any}","page":"Exchanges","title":"Exchanges.ismargin","text":"True if mkt is a leveraged market.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.ispercentage-Tuple{Any}","page":"Exchanges","title":"Exchanges.ispercentage","text":"Check if market has percentage or absolute fees.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.isquote-Tuple{Any, Any}","page":"Exchanges","title":"Exchanges.isquote","text":"True if id is a quote id.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.issandbox","page":"Exchanges","title":"Exchanges.issandbox","text":"Check if exchange is in sandbox mode.\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.jlpyconvert-Tuple{Any}","page":"Exchanges","title":"Exchanges.jlpyconvert","text":"Convert a Python object into a Julia object.\n\njlpyconvert(py) -> Union{Nothing, Dict{Any, Any}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.lastprice-Tuple{AbstractString, Exchange}","page":"Exchanges","title":"Exchanges.lastprice","text":"Fetch the latest price for a specific pair from an exchange.\n\nlastprice(\n    pair::AbstractString,\n    exc::Exchange;\n    kwargs...\n) -> Any\n\n\npair: a string representing the currency pair to fetch the latest price for.\nexc: an Exchange object to fetch the latest price from.\nkwargs (optional): any additional keyword arguments are passed on to the underlying fetch operation.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.leverage!-Tuple{Exchange, Any, Any}","page":"Exchanges","title":"Exchanges.leverage!","text":"Update the leverage for a specific symbol.\n\nleverage!(exc::Exchange, v, sym; side, timeout) -> Any\n\n\nexc: an Exchange object to update the leverage on.\nv: a Real number representing the new leverage value.\nsym: a string representing the symbol to update the leverage for.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.leverage_func","page":"Exchanges","title":"Exchanges.leverage_func","text":"Constructor that returns a function that checks if a pair is leveraged.\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.leverage_tiers-Tuple{Exchange, AbstractString}","page":"Exchanges","title":"Exchanges.leverage_tiers","text":"Fetch the leverage tiers for a specific symbol from an exchange.\n\nleverage_tiers(exc::Exchange, sym::AbstractString) -> Any\n\n\nexc: an Exchange object to fetch the leverage tiers from.\nsym: a string representing the symbol to fetch the leverage tiers for.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.loadmarkets!-Tuple{Any}","page":"Exchanges","title":"Exchanges.loadmarkets!","text":"Load exchange markets.\n\nloadmarkets!(exc; cache, agemax)\n\n\nexc: an Exchange object that represents the exchange to load markets from.\ncache (optional, default is true): a boolean that indicates whether to rely on storage cache.\nagemax (optional, default is Day(1)): a Period object that represents the maximum cache valid period.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.marginmode!-Tuple{Exchange, Any, Any}","page":"Exchanges","title":"Exchanges.marginmode!","text":"Update margin mode for a specific symbol on the exchange.\n\nAlso sets if the position is hedged or one sided. For customizations, dispatch to dosetmargin.\n\nmarginmode!(\n    exc::Exchange,\n    mode,\n    symbol;\n    hedged,\n    kwargs...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.market!","page":"Exchanges","title":"Exchanges.market!","text":"Retrieves a cached market (1minute) or fetches it from exchange.\n\nmarket!(pair) -> Any\nmarket!(pair, exc::Exchange) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.market_fees","page":"Exchanges","title":"Exchanges.market_fees","text":"Fetch the market fees for a specific pair from an exchange.\n\nmarket_fees(\n    pair::AbstractString;\n    ...\n) -> NamedTuple{(:taker, :maker, :min, :max), <:NTuple{4, Any}}\nmarket_fees(\n    pair::AbstractString,\n    exc::Exchange;\n    only_taker\n) -> NamedTuple{(:taker, :maker, :min, :max), <:NTuple{4, Any}}\n\n\npair: a string representing the currency pair to fetch the market fees for.\nexc (optional, default is the current exchange): an Exchange object to fetch the market fees from.\nonly_taker (optional, default is nothing): a boolean indicating whether to fetch only the taker fee. If nothing, both maker and taker fees are fetched.\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.market_limits-Tuple{AbstractString, Exchange}","page":"Exchanges","title":"Exchanges.market_limits","text":"Fetch the market limits for a specific pair from an exchange.\n\nmarket_limits(\n    pair::AbstractString,\n    exc::Exchange;\n    precision,\n    default_leverage,\n    default_amount,\n    default_price,\n    default_cost\n) -> NamedTuple\n\n\npair: a string representing the currency pair to fetch the market limits for.\nexc: an Exchange object to fetch the market limits from.\nprecision (optional, default is price=nothing, amount=nothing): a named tuple specifying the precision for price and amount.\ndefault_leverage (optional, default is DEFAULT_LEVERAGE): the default leverage to use if not specified in the market data.\ndefault_amount (optional, default is DEFAULT_AMOUNT): the default amount to use if not specified in the market data.\ndefault_price (optional, default is DEFAULT_PRICE): the default price to use if not specified in the market data.\ndefault_cost (optional, default is DEFAULT_COST for non-fiat quote pairs and DEFAULT_FIAT_COST for fiat quote pairs): the default cost to use if not specified in the market data.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.market_precision-Tuple{AbstractString, Exchange}","page":"Exchanges","title":"Exchanges.market_precision","text":"Precision of the (base, quote) currencies of the market.\n\nmarket_precision(\n    pair::AbstractString,\n    exc::Exchange\n) -> NamedTuple{(:amount, :price), <:Tuple{Any, Any}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.marketsid-Tuple{Exchange, Vararg{Any}}","page":"Exchanges","title":"Exchanges.marketsid","text":"Get the exchange market ids.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.markettype","page":"Exchanges","title":"Exchanges.markettype","text":"Any of (:spot, :future, :swap, :option, :margin, :delivery)\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.maxleverage-Tuple{Exchange, AbstractString, Real}","page":"Exchanges","title":"Exchanges.maxleverage","text":"Get the maximum leverage for a specific size and symbol from an exchange.\n\nmaxleverage(\n    exc::Exchange,\n    sym::AbstractString,\n    size::Real\n) -> Real\n\n\nexc: an Exchange object to fetch the maximum leverage from.\nsym: a string representing the symbol to fetch the maximum leverage for.\nsize: a Real number representing the size to fetch the maximum leverage for.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.price_ranges-Tuple{AbstractString, Vararg{Any}}","page":"Exchanges","title":"Exchanges.price_ranges","text":"Get price ranges using tickers data from exchange.\n\nprice_ranges(pair::AbstractString, args...; exc, kwargs...)\n\n\nThe price_ranges function takes the following parameters:\n\npair: a string representing the currency pair.\nargs...: a variable number of arguments to pass to the price ranges calculation.\nexc (optional, default is global exc): an Exchange object to get the tickers data from.\nkwargs...: a variable number of keyword arguments to pass to the price ranges calculation.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.quoteid-Tuple{Any}","page":"Exchanges","title":"Exchanges.quoteid","text":"Quote id of the market.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.quotevol-Tuple{AbstractDict}","page":"Exchanges","title":"Exchanges.quotevol","text":"Get quote volume from ticker.\n\nquotevol(tkr::AbstractDict) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.ratelimit!","page":"Exchanges","title":"Exchanges.ratelimit!","text":"Enable or disable rate limit.\n\nratelimit!() -> Bool\nratelimit!(exc::Exchange) -> Bool\nratelimit!(exc::Exchange, flag) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.sandbox!","page":"Exchanges","title":"Exchanges.sandbox!","text":"Enable sandbox mode for exchange. Should only be called on exchange construction.\n\nsandbox!(; ...) -> Union{Nothing, Bool}\nsandbox!(\n    exc::Exchange;\n    flag,\n    remove_keys\n) -> Union{Nothing, Bool}\n\n\nexc (optional, default is global exc): an Exchange object to set the sandbox mode for.\nflag (optional, default is the inverse of the current sandbox mode status): a boolean indicating whether to enable or disable sandbox mode.\nremove_keys (optional, default is true): a boolean indicating whether to remove the API keys while enabling sandbox mode.\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.setexchange!-Tuple{Exchange, Vararg{Any}}","page":"Exchanges","title":"Exchanges.setexchange!","text":"Initializes an exchange struct.\n\nsetexchange!(\n    exc::Exchange,\n    args...;\n    markets,\n    kwargs...\n) -> Exchange\n\n\nexc: an Exchange object to be set.\nargs...: a variable number of arguments to pass to the exchange setup.\nmarkets (optional, default is :yes): a symbol that indicates whether to load markets during setup.\nkwargs...: a variable number of keyword arguments to pass to the exchange setup.\n\nConfigures the matching ccxt class, optionally loads the markets, sets the exchange timeframes, and sets the exchange API keys.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.setflags!-Tuple{ExchangeTypes.CcxtExchange}","page":"Exchanges","title":"Exchanges.setflags!","text":"Set the ccxt exchange has flags.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.spotsymbol-Tuple{Any, Any}","page":"Exchanges","title":"Exchanges.spotsymbol","text":"Trims the settlement currency in futures. (mkt is a ccxt market.)\n\nspotsymbol(sym, mkt) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.ticker!-Tuple{Any, Exchange}","page":"Exchanges","title":"Exchanges.ticker!","text":"Fetch the ticker for a specific pair from an exchange.\n\nticker!(pair, exc::Exchange; timeout, func, delay) -> Any\n\n\nThe ticker! function takes the following parameters:\n\npair: a string representing the currency pair to fetch the ticker for.\nexc: an Exchange object to fetch the ticker from.\ntimeout (optional, default is 3 seconds): the maximum time to wait for the ticker fetch operation.\nfunc (optional, default is the result of _tickerfunc(exc)): the function to use to fetch the ticker.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.tickerprice-Tuple{Any}","page":"Exchanges","title":"Exchanges.tickerprice","text":"Get price from ticker.\n\ntickerprice(tkr) -> Any\n\n\nThe tickerprice function takes the following parameters:\n\ntkr: a Ticker object.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.tickers-Tuple{Exchange, Any}","page":"Exchanges","title":"Exchanges.tickers","text":"Get the exchange tickers.\n\ntickers(\n    exc::Exchange,\n    quot;\n    min_vol,\n    skip_fiat,\n    with_margin,\n    with_leverage,\n    as_vec,\n    verbose,\n    type\n)\n\n\nexc: an Exchange object to fetch the tickers from.\nquot: only choose pairs where the quote currency equals quot.\nmin_vol: the minimum volume of each pair.\nskip_fiat (optional, default is true): ignore fiat/fiat pairs.\nwith_margin (optional, default is the result of config.margin != NoMargin()): only choose pairs enabled for margin trading.\nwith_leverage (optional, default is :no): if :no, skip all pairs where the base currency matches the leverage_pair_rgx regex.\nas_vec (optional, default is false): return the pair list as a Vector instead of as a Dict.\nverbose (optional, default is true): print detailed output about the operation.\ntype (optional, default is the result of markettype(exc)): the type of markets to fetch tickers for.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.tickers-Tuple{Symbol, Vararg{Any}}","page":"Exchanges","title":"Exchanges.tickers","text":"Get the tickers matching quote currency quot.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.tier-Tuple{SortedDict{Int64, Exchanges.LeverageTier}, Real}","page":"Exchanges","title":"Exchanges.tier","text":"Get the leverage tier for a specific size from a sorted dictionary of tiers.\n\ntier(\n    tiers::SortedDict{Int64, Exchanges.LeverageTier},\n    size::Real\n) -> Tuple{Union{Nothing, Int64}, Exchanges.LeverageTier}\n\n\ntiers: a SortedDict where the keys are integers representing the size thresholds and the values are LeverageTier objects.\nsize: a Real number representing the size to fetch the tier for.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.timeout!","page":"Exchanges","title":"Exchanges.timeout!","text":"Set exchange timeout. (milliseconds)\n\ntimeout!() -> Int64\ntimeout!(exc::Exchange) -> Int64\ntimeout!(exc::Exchange, v) -> Any\n\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.timestamp-Tuple{Exchange}","page":"Exchanges","title":"Exchanges.timestamp","text":"The current timestamp from the exchange.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.to_float","page":"Exchanges","title":"Exchanges.to_float","text":"Convert a Python object to a float number.\n\n\n\n\n\n","category":"function"},{"location":"API/exchanges/#Exchanges.to_num-Tuple{Py}","page":"Exchanges","title":"Exchanges.to_num","text":"Convert a Python object to a number.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Instruments.value-Tuple{Exchanges.CurrencyCash}","page":"Exchanges","title":"Instruments.value","text":"The currency cash as a number.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Serialization.deserialize-Tuple{Serialization.AbstractSerializer, Type{<:Exchange}}","page":"Exchanges","title":"Serialization.deserialize","text":"When deserializing an exchange, use the deserialized id to construct the exchange.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Serialization.serialize-Union{Tuple{E}, Tuple{Serialization.AbstractSerializer, E}} where E<:Exchange","page":"Exchanges","title":"Serialization.serialize","text":"When serializing an exchange, serialize only its id.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Exchanges.@exchange!-Tuple{Any}","page":"Exchanges","title":"Exchanges.@exchange!","text":"Define an exchange variable set to its matching exchange instance.\n\n\n\n\n\n","category":"macro"},{"location":"API/exchanges/#Exchanges.@tickers!","page":"Exchanges","title":"Exchanges.@tickers!","text":"Fetch and cache tickers data.\n\nThe @tickers! macro takes the following parameters:\n\ntype (optional, default is nothing): the type of tickers to fetch and cache.\nforce (optional, default is false): a boolean that indicates whether to force the data fetch, even if the data is already present.\n\n\n\n\n\n","category":"macro"},{"location":"API/exchanges/#ExchangeTypes.HOOKS","page":"Exchanges","title":"ExchangeTypes.HOOKS","text":"Functions f(::Exchange) to call when an exchange is loaded\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#ExchangeTypes.exc","page":"Exchanges","title":"ExchangeTypes.exc","text":"Global var implicit exchange instance.\n\nWhen working interactively, a global exc variable is available, updated through globalexchange!, which is used as the default for some functions when the exchange argument is omitted.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#ExchangeTypes.exchangeIds","page":"Exchanges","title":"ExchangeTypes.exchangeIds","text":"All possible exchanges that can be instantiated by ccxt.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#ExchangeTypes.exchanges","page":"Exchanges","title":"ExchangeTypes.exchanges","text":"Global var holding Exchange instances. Used as a cache.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#ExchangeTypes.sb_exchanges","page":"Exchanges","title":"ExchangeTypes.sb_exchanges","text":"Global var holding Sandbox Exchange instances. Used as a cache.\n\n\n\n\n\n","category":"constant"},{"location":"API/exchanges/#ExchangeTypes.CcxtExchange","page":"Exchanges","title":"ExchangeTypes.CcxtExchange","text":"The CcxtExchange type wraps a ccxt exchange instance. Some attributes frequently accessed are copied over to avoid round tripping python. More attributes might be added in the future. To instantiate an exchange call getexchange! or setexchange!.\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#ExchangeTypes.ExcPrecisionMode","page":"Exchanges","title":"ExchangeTypes.ExcPrecisionMode","text":"Same as ccxt precision mode enums.\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#ExchangeTypes.Exchange","page":"Exchanges","title":"ExchangeTypes.Exchange","text":"Abstract exchange type.\n\nDefines the interface for interacting with crypto exchanges. Implemented for CCXT in CcxtExchange.\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#ExchangeTypes.Exchange-Tuple{Py}","page":"Exchanges","title":"ExchangeTypes.Exchange","text":"Instantiates a new Exchange wrapper for the provided x Python object.\n\nThis constructs a CcxtExchange struct with the provided Python object. It extracts the exchange ID, name, and other metadata. It runs any registered hook functions for that exchange. It sets a finalizer to close the exchange when garbage collected.\n\nReturns the new Exchange instance, or an empty one if x is None.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#ExchangeTypes.ExchangeID","page":"Exchanges","title":"ExchangeTypes.ExchangeID","text":"A structure for handling Exchange IDs in CCXT.\n\nThis structure is used to manage Exchange IDs in the CCXT library. It contains methods for creating an Exchange ID from a symbol, a Python object, or directly from a symbol type. It ensures that the symbol is in the list of valid exchange IDs.\n\n\n\n\n\n","category":"type"},{"location":"API/exchanges/#Base.first-Tuple{Exchange, Vararg{Symbol}}","page":"Exchanges","title":"Base.first","text":"Return the first available property from a variable number of Symbol arguments in the given Exchange.\n\nfirst(exc::Exchange, args::Symbol...) -> Any\n\n\nThis function iterates through the provided Symbols and returns the value of the first property that exists in the Exchange object.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Base.getproperty-Union{Tuple{E}, Tuple{E, Symbol}} where E<:Exchange","page":"Exchanges","title":"Base.getproperty","text":"Attributes not matching the Exchange struct fields are forwarded to the wrapped ccxt class instance.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#Base.hash-Tuple{Exchange, UInt64}","page":"Exchanges","title":"Base.hash","text":"The hash of an exchange object is reduced to its symbol (the function used to instantiate the object from ccxt).\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#ExchangeTypes._has-Tuple{Symbol}","page":"Exchanges","title":"ExchangeTypes._has","text":"Checks if the specified feature feat is supported by any of the exchanges available through the ccxt library.\n\nArguments\n\ns::Symbol: The feature to check for support across exchanges.\nfull::Bool=true: If true, checks both static and instantiated properties of the exchange for support.\n\nReturns\n\nVector{String}: A list of exchange names that support the specified feature.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#ExchangeTypes.close_exc-Tuple{ExchangeTypes.CcxtExchange}","page":"Exchanges","title":"ExchangeTypes.close_exc","text":"Closes the given exchange.\n\nclose_exc(\n    exc::ExchangeTypes.CcxtExchange\n) -> Union{Nothing, Task}\n\n\nThis function attempts to close the given exchange if it exists. It checks if the exchange has a 'close' attribute and if so, it schedules the 'close' coroutine for execution.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#ExchangeTypes.decimal_to_size-Tuple{Any, ExcPrecisionMode}","page":"Exchanges","title":"ExchangeTypes.decimal_to_size","text":"Converts value v to integer size with precision p.\n\ndecimal_to_size(v, p::ExcPrecisionMode) -> Any\n\n\nUsed when converting exchange API responses to integer sizes for orders.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#ExchangeTypes.eids-Tuple","page":"Exchanges","title":"ExchangeTypes.eids","text":"Union type of many exchange ids (from Symbol arguments)\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#ExchangeTypes.exchangeid-Tuple{ExchangeID}","page":"Exchanges","title":"ExchangeTypes.exchangeid","text":"Return the given ExchangeID instance.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#ExchangeTypes.exchangeid-Tuple{Symbol}","page":"Exchanges","title":"ExchangeTypes.exchangeid","text":"Create an ExchangeID instance from a symbol.\n\n\n\n\n\n","category":"method"},{"location":"API/exchanges/#ExchangeTypes.globalexchange!-Tuple{Exchange}","page":"Exchanges","title":"ExchangeTypes.globalexchange!","text":"Updates the global exchange exc variable.\n\n\n\n\n\n","category":"method"},{"location":"engine/engine_notes/#Backtesting-overview","page":"Backtesting overview","title":"Backtesting overview","text":"","category":"section"},{"location":"engine/engine_notes/#Goals","page":"Backtesting overview","title":"Goals","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"The backtest should be able to be executed given a custom start and end date.\nThe strategy has to have access to the OHLCV and all past trade history.\nIt must be able to run during live trading.","category":"page"},{"location":"engine/engine_notes/#Main-loop","page":"Backtesting overview","title":"Main loop","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"for each timestamp:\nwhile true:\nprocess(strategy, timestamp, context)","category":"page"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"The loop is just a timestamp feeder!, and the strategy holds all the state.","category":"page"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"Because we use the TimeFrames abstraction, the step can be arbitrary, the strategy will just index into ohlcv data according to the last candle compatible with the given timestamp. This is a performance trade-off, we prefer to always index with dates, and never with integers, because it reduces the assumptions to the row data must match its timestamp (its not corrupted!) compared to spurious bugs that might arise by integer indexing.\nThe simulation is adversarial to the strategy, it is the job of the simulation to decide how much loss a trade has incurred.","category":"page"},{"location":"engine/engine_notes/#Strategy-General-Considerations","page":"Backtesting overview","title":"Strategy General Considerations","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"The strategy must account for a  tie breaker to choose which trades to perform on the same candle since we don't know which pair we observed first. In general this is a good use case for MC.","category":"page"},{"location":"engine/engine_notes/#What-does-executing-an-order-mean?","page":"Backtesting overview","title":"What does executing an order mean?","text":"","category":"section"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"When the engine executes an order, it does the following for every order:","category":"page"},{"location":"engine/engine_notes/","page":"Backtesting overview","title":"Backtesting overview","text":"Decide if order should be honored or fail\nPerform simulations, like spread, slippage, market impact.\nSignal to the strategy about failed (canceled) orders.","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"The bot is configured using a file named user/pingpong.toml, which serves as the default configuration file. This file typically contains:","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"Minor exchange configurations, which are referenced using the ExchangeID symbol as the key for the exchange's config section.\nStrategy settings, where the strategy module's name is used as the section key. Each strategy section may include:\ninclude_file: Specifies the path to the strategy's entry file.\nmargin: Defines the margin mode used when initializing the strategy.","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"It is generally unnecessary to populate the configuration file with numerous options, as most settings should be predefined as constants within the strategy's module. This design helps to prevent confusion that could arise from a combination of config options and strategy constants potentially conflicting with each other.","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"Exchange API keys are stored in dedicated files named following the pattern \\${ExchangeID}[_sandbox].json. The _sandbox suffix is added for keys associated with sandbox endpoints. By default, exchanges are initiated in sandbox mode. In scenarios where an exchange does not offer a sandbox environment, the sandbox parameter must be explicitly set to false when calling the exchange creation function. Here's an example of such a call:","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"getexchange!(:okx, sandbox=false)","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"For third-party applications within the Watchers module, the configuration is managed via a separate file named secrets.toml.","category":"page"},{"location":"API/instruments/#Instruments","page":"Instruments","title":"Instruments","text":"","category":"section"},{"location":"API/instruments/","page":"Instruments","title":"Instruments","text":"Modules = [Instruments, Instruments.Derivatives]\nOrder = [:type]","category":"page"},{"location":"API/instruments/#Instruments.AbstractAsset","page":"Instruments","title":"Instruments.AbstractAsset","text":"Abstract base type for representing an asset.\n\nDefines the interface and common functionality for all asset types.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.AbstractCash","page":"Instruments","title":"Instruments.AbstractCash","text":"Abstract base type for representing a variable quantity of some currency.\n\nThis type defines the interface and common functionality for all cash types.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.Asset","page":"Instruments","title":"Instruments.Asset","text":"An Asset represents a parsed raw (usually ccxt) pair of base and quote currency.\n\nraw: The raw underlying string e.g. 'BTC/USDT'\nbc: base currency (Symbol)\nqc: quote currency (Symbol)\nfiat: if both the base and quote currencies match a known fiat symbol e.g. 'USDT/USDC'\nleveraged: if parsing matched a leveraged token e.g. 'ETH3L/USDT' or 'ETH3S/USDT'\nunleveraged_bc: a leveraged token with the mod removed, e.g. ETH3L => ETH\n\n> asset = a\"BTC/USDT\"\n> typeof(asset)\nAsset{:BTC, :USDT}\nend\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.BaseCurrency","page":"Instruments","title":"Instruments.BaseCurrency","text":"A symbol checked to be a valid base currency.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.Cash","page":"Instruments","title":"Instruments.Cash","text":"A variable quantity of some currency.\n\nvalue\n\n> ca = c\"USDT\"\n> typeof(ca)\n# Instruments.Cash{:USDT}\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.QuoteCurrency","page":"Instruments","title":"Instruments.QuoteCurrency","text":"A symbol checked to be a valid quote currency.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.Derivatives.Derivative8","page":"Instruments","title":"Instruments.Derivatives.Derivative8","text":"Derivative parsed accordingly to regex.\n\nasset\nsc\nid\nstrike\nkind\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.Derivatives.DerivativeKind","page":"Instruments","title":"Instruments.Derivatives.DerivativeKind","text":"Differentiates between perpetuals and options.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/#Instruments.Derivatives.SettlementCurrency","page":"Instruments","title":"Instruments.Derivatives.SettlementCurrency","text":"A symbol parsed as settlement currency.\n\n\n\n\n\n","category":"type"},{"location":"API/instruments/","page":"Instruments","title":"Instruments","text":"Modules = [Instruments, Instruments.Derivatives]\nOrder = [:function]","category":"page"},{"location":"API/instruments/#Instruments.addzero!-Tuple{Cash, Any, Vararg{Any}}","page":"Instruments","title":"Instruments.addzero!","text":"Add v to cash, approximating to zero if cash is a small value.\n\naddzero!(c::Cash, v, args...; kwargs...) -> Cash\n\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.bc-Tuple{AbstractAsset}","page":"Instruments","title":"Instruments.bc","text":"Returns the base currency of a.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.cash!-Tuple{Cash, Any, Vararg{Any}}","page":"Instruments","title":"Instruments.cash!","text":"Sets the cash object to v.\n\ncash!(c::Cash, v, args...; kwargs...) -> Cash\n\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.compactnum-Tuple{N} where N<:Number","page":"Instruments","title":"Instruments.compactnum","text":"Compact a numeric value num to a smaller unit if possible.\n\ncompactnum(val::Number) -> Any\n\n\nThe function converts the numeric value to a smaller unit of time if the value is greater than or equal to 1000, and returns the compacted value.\n\nExample:\n\nnum = 5000\nresult = compactnum(num)  # returns 5 since 5000 can be compacted to 5\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.deleverage_pair-Tuple{T} where T<:AbstractString","page":"Instruments","title":"Instruments.deleverage_pair","text":"Remove leveraged pair pre/suffixes from base currency.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.deleverage_qc-Union{Tuple{Vector{T}}, Tuple{T}} where T<:AbstractString","page":"Instruments","title":"Instruments.deleverage_qc","text":"Remove the leverage component from a CCXT quote currency quote.\n\ndeleverage_qc(pair::Array{T<:AbstractString, 1})\n\n\nThe function returns a new string with the leverage component removed.\n\nExample:\n\nquote = \"3BTC/USDT\"\ndeleveraged_quote = deleverage_qc(quote)  # returns \"USDT\"\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.div!-Tuple{Cash, Any, Vararg{Any}}","page":"Instruments","title":"Instruments.div!","text":"Inplace division for Cash objects.\n\ndiv!(c::Cash, v, args...; kwargs...) -> Cash\n\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.has_punct-Tuple{AbstractString}","page":"Instruments","title":"Instruments.has_punct","text":"Check if a string s contains any punctuation characters.\n\nhas_punct(s::AbstractString) -> Bool\n\n\nThe function returns true if s contains any punctuation characters, and false otherwise.\n\nExample:\n\ns = \"Hello, world!\"\nresult = has_punct(s)  # returns true since the string contains a punctuation character\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.isfiatpair-Union{Tuple{T}, Tuple{T, T}} where T<:AbstractString","page":"Instruments","title":"Instruments.isfiatpair","text":"Check if both base and quote are fiat currencies.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.isfiatquote-Tuple{AbstractAsset}","page":"Instruments","title":"Instruments.isfiatquote","text":"Check if quote currency is a stablecoin.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.isleveragedpair-Tuple{Any}","page":"Instruments","title":"Instruments.isleveragedpair","text":"Test if pair has leveraged naming.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.mod!-Tuple{Cash, Any, Vararg{Any}}","page":"Instruments","title":"Instruments.mod!","text":"Inplace modulo for Cash objects.\n\nmod!(c::Cash, v, args...; kwargs...) -> Cash\n\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.mul!-Tuple{Cash, Any, Vararg{Any}}","page":"Instruments","title":"Instruments.mul!","text":"Inplace multiplication for Cash objects.\n\nmul!(c::Cash, v, args...; kwargs...) -> Cash\n\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.qc-Tuple{AbstractAsset}","page":"Instruments","title":"Instruments.qc","text":"Returns the quote currency of a.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.raw-Tuple{AbstractAsset}","page":"Instruments","title":"Instruments.raw","text":"Convert an AbstractAsset object a to its raw representation.\n\nraw(a::AbstractAsset) -> Any\n\n\nThe function returns a new AbstractAsset object with special characters escaped using backslashes.\n\nExample:\n\na = parse(\"BTC/USDT\")\nraw(a) # returns \"BTC/USDT\"\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.rdiv!-Tuple{Cash, Any, Vararg{Any}}","page":"Instruments","title":"Instruments.rdiv!","text":"Inplace remaineder division for Cash objects.\n\nrdiv!(c::Cash, v, args...; kwargs...) -> Cash\n\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.splitpair-Tuple{AbstractString}","page":"Instruments","title":"Instruments.splitpair","text":"Split a CCXT pair (symbol) pair into its base and quote currencies.\n\nsplitpair(\n    pair::AbstractString\n) -> Vector{T} where T<:(SubString{_A} where _A)\n\n\nThe function returns a tuple containing the base currency and quote currency.\n\nExample: pair = \"BTC/USDT\" base, quote = splitpair(pair)  # returns (\"BTC\", \"USDT\")\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.spotpair-Tuple{AbstractString}","page":"Instruments","title":"Instruments.spotpair","text":"Strips the settlement currency from a symbol.\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.subzero!-Tuple{Instruments.AbstractCash, Any, Vararg{Any}}","page":"Instruments","title":"Instruments.subzero!","text":"Sub v to cash, approximating to zero if cash is a small value.\n\nsubzero!(\n    c::Instruments.AbstractCash,\n    v,\n    args...;\n    kwargs...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.Derivatives.is_settled-Tuple{Instruments.Derivatives.Derivative8}","page":"Instruments","title":"Instruments.Derivatives.is_settled","text":"Predicates according to OctoBot\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.Derivatives.perpetual-Tuple{AbstractString, Any, Any}","page":"Instruments","title":"Instruments.Derivatives.perpetual","text":"Create a Derivative from a raw string representation raw, base currency bc, and quote currency qc.\n\nperpetual(raw::AbstractString, bc, qc) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/#Instruments.Derivatives.sc-Tuple{Instruments.Derivatives.Derivative8}","page":"Instruments","title":"Instruments.Derivatives.sc","text":"Short-circuit the execution of a derivative calculation if the derivative d is zero.\n\nsc(d::Instruments.Derivatives.Derivative8; orqc) -> Symbol\n\n\n\n\n\n\n","category":"method"},{"location":"API/instruments/","page":"Instruments","title":"Instruments","text":"Modules = [Instruments, Instruments.Derivatives]\nOrder = [:macro, :constant]","category":"page"},{"location":"API/instruments/#Instruments.@a_str-Tuple{Any}","page":"Instruments","title":"Instruments.@a_str","text":"Parses pair to an Asset type. ```julia\n\ntypeof(a\"BTC/USDT\")\n\nInstruments.Asset\n\n\n\n\n\n","category":"macro"},{"location":"API/instruments/#Instruments.@c_str","page":"Instruments","title":"Instruments.@c_str","text":"Macro to instantiate Cash statically.\n\nDon't put spaces between the id and the value.\n\n> ca = c\"USDT\"1000\nUSDT: 1000.0\n\n\n\n\n\n","category":"macro"},{"location":"API/instruments/#Instruments.@importcash!-Tuple{}","page":"Instruments","title":"Instruments.@importcash!","text":"Cash should not be edited by a strategy, therefore functions that mutate its value should be explicitly imported.\n\n\n\n\n\n","category":"macro"},{"location":"API/instruments/#Instruments.@pusdt_str-Tuple{Any}","page":"Instruments","title":"Instruments.@pusdt_str","text":"Rewrites sym as a perpetual usdt symbol.\n\n> pusdt\"btc\"\nBTC/USDT:USDT\n\n\n\n\n\n","category":"macro"},{"location":"API/instruments/#Instruments.ALL_MARKET_SEPARATORS","page":"Instruments","title":"Instruments.ALL_MARKET_SEPARATORS","text":"A collection of all possible separators used in market symbols\n\n\n\n\n\n","category":"constant"},{"location":"API/instruments/#Instruments.DEFAULT_MARKET_SEPARATOR","page":"Instruments","title":"Instruments.DEFAULT_MARKET_SEPARATOR","text":"The default separator used in market symbols\n\n\n\n\n\n","category":"constant"},{"location":"API/instruments/#Instruments.FULL_SYMBOL_GROUPS_REGEX","page":"Instruments","title":"Instruments.FULL_SYMBOL_GROUPS_REGEX","text":"From CCTX\n\n\n\n\n\n","category":"constant"},{"location":"API/instruments/#Instruments.SETTLEMENT_SEPARATOR","page":"Instruments","title":"Instruments.SETTLEMENT_SEPARATOR","text":"The separator used to separate the settlement currency from the quote currency in a market symbol.\n\n\n\n\n\n","category":"constant"},{"location":"API/instruments/#Instruments.fiatnames","page":"Instruments","title":"Instruments.fiatnames","text":"A list of fiat and fiat-like assets names.\n\n\n\n\n\n","category":"constant"},{"location":"API/instruments/#Instruments.fiatsyms","page":"Instruments","title":"Instruments.fiatsyms","text":"A set of symbols representing fiat and fiat-like assets\n\n\n\n\n\n","category":"constant"},{"location":"API/instruments/#Instruments.leverage_pair_rgx","page":"Instruments","title":"Instruments.leverage_pair_rgx","text":"A regular expression pattern used to match leveraged naming conventions in market symbols. It captures the separator used in leveraged pairs.\n\n\n\n\n\n","category":"constant"},{"location":"API/instruments/#Instruments.Derivatives.@d_str-Tuple{Any}","page":"Instruments","title":"Instruments.Derivatives.@d_str","text":"Shortand for parsing derivatives:\n\n> drv = d\"BTC/USDT:USDT\"\n> typeof(drv)\n# Instruments.Derivatives.Derivative{Asset{:BTC, :USDT}}\n\n\n\n\n\n","category":"macro"},{"location":"customizations/orders/#Custom-Orders","page":"Orders","title":"Custom Orders","text":"","category":"section"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"This section demonstrates how to implement an OCO (One-Cancels-the-Other) order type for simulation purposes:","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"using OrderTypes: OrderType, @deforders\n\nabstract type OCOOrderType{S} <: OrderType{S}\n@deforders OCO","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"We can base our implementation on the existing constructor for limit orders and modify it to meet the requirements of an OCO order:","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"const _OCOOrderState = NamedTuple{(:committed, :filled, :trades, :twin), Tuple{Vector{Float64}, Vector{Float64}, Vector{Trade}, Ref{OCOOrder}}}\n\nfunction oco_order_state(\n    committed::Vector{T}, filled::Vector{Float64}=[0.0], trades::Vector{Trade}=Vector{Trade}()\n) where T\n    _OCOOrderState((committed, filled, trades, Ref{OCOOrder}()))\nend\n\nfunction ocoorder(\n    ai::AssetInstance,\n    ::SanitizeOff;\n    price_lower::Float64,\n    amount_lower::Float64,\n    price_upper::Float64,\n    amount_upper::Float64,\n    committed_lower::Vector{Float64},\n    committed_upper::Vector{Float64},\n    date::Datetime\n)\n    ismonotonic(price_lower, price_upper) || return nothing\n    iscost(ai, amount_lower, price_lower) || return nothing\n    iscost(ai, amount_upper, price_upper) || return nothing\n\n    lower_order = OrderTypes.Order(\n        ai,\n        OCOOrderType{Sell};\n        date,\n        price_lower,\n        amount_lower,\n        committed_lower,\n        attrs=oco_order_state(committed_lower)\n    )\n    upper_order = OrderTypes.Order(\n        ai,\n        OCOOrderType{Buy};\n        date,\n        price_upper,\n        amount_upper,\n        committed_upper,\n        attrs=oco_order_state(committed_upper)\n    )\n\n    lower_order.attrs[:twin] = upper_order\n    upper_order.attrs[:twin] = lower_order\n    return lower_order\nend","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"Next, we introduce two pong! functions to handle creating and updating simulated OCO orders:","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"@doc \"Creates a simulated OCO order.\"\nfunction pong!(\n    s::Strategy{Sim}, ::Type{Order{<:OCOOrderType}}, ai; date, kwargs...\n)\n    o = ocoorder(s, ai; date, kwargs...)\n    isnothing(o) && return nothing\n    iscommittable(s, o, ai) || return nothing\n    # TODO: Implement logic to execute the order and return resulting trades.\nend\n\n@doc \"Updates a simulated OCO order.\"\nfunction pong!(\n    s::Strategy{Sim}, ::Type{<:Order{OCOOrderType}}, date::Datetime, ai; kwargs...\n)\n    o = ocoorder(s, ai; date, kwargs...)\n    isnothing(o) && return nothing\n    iscommittable(s, o, ai) || return nothing\n    iscommittable(s, o.attrs[:twin], ai) || return nothing\n    # TODO: Implement logic to execute the order update and return resulting trades.\nend","category":"page"},{"location":"customizations/orders/#Custom-Instruments","page":"Orders","title":"Custom Instruments","text":"","category":"section"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"We can extend instruments to create new types such as Asset and Derivative, which are subtypes of AbstractAsset. They are named using the CCXT convention (QUOTE/BASE:SETTLE), and it's expected that all instruments define a base and a quote currency.","category":"page"},{"location":"customizations/orders/#Instances-and-Exchanges","page":"Orders","title":"Instances and Exchanges","text":"","category":"section"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"Asset instances are parameterized by the type of the asset (e.g., asset, derivative) and the exchange they are associated with. By using ExchangeID as a parameter, we can fine-tune the behavior for specific exchanges.","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"For example, if we want to handle OCO orders differently across exchanges in live mode, we can define pong! functions that are specialized based on the exchange parameter of the asset instance.","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"function pong!(\n    s::Strategy{Live}, \n    ::Type{Order{<:OCOOrderType}}, \n    ai::AssetInstance{A, ExchangeID{:bybit}}; \n    date, \n    kwargs...\n)\n    # Replace the following comment with the actual call to a private method of the ccxt exchange class to execute the order.\n    ### Call some private method of the ccxt exchange class to execute the order\nend","category":"page"},{"location":"customizations/orders/","page":"Orders","title":"Orders","text":"The function above is designed to handle asset instances that are specifically tied to the bybit exchange.","category":"page"},{"location":"API/engine/#Engine","page":"Engine","title":"Engine","text":"","category":"section"},{"location":"API/engine/","page":"Engine","title":"Engine","text":"Modules = [PingPong.Engine]","category":"page"},{"location":"API/engine/#Strategies.Strategy-Tuple{Module, Union{AbstractSet{String}, Tuple{Vararg{String}}, Dict, AbstractVector{String}}}","page":"Engine","title":"Strategies.Strategy","text":"Initializes a Strategy object in the Strategies module.\n\nStrategy(\n    self::Module,\n    assets::Union{AbstractSet{String}, Tuple{Vararg{String}}, Dict, AbstractVector{String}};\n    load_data,\n    config,\n    mode,\n    margin,\n    sandbox,\n    timeframe\n)\n\n\nThe Strategy function takes the following parameters:\n\nself: a Module object representing the current module.\nassets: a Union of a dictionary or iterable of strings representing the assets to be included in the strategy.\nload_data (optional, default is true): a boolean indicating whether to load data for the assets.\nconfig: a Config object representing the configuration settings for the strategy.\nmode (optional, default is config.mode): a mode setting for the strategy.\nmargin (optional, default is config.margin): a margin setting for the strategy.\nsandbox (optional, default is true): a boolean indicating whether to run the strategy in a sandbox environment.\ntimeframe (optional, default is config.min_timeframe): a timeframe setting for the strategy.\n\nThe function initializes a Strategy object with the specified settings and assets.\n\n\n\n\n\n","category":"method"},{"location":"API/engine/#Base.fill!-Tuple{Collections.AssetCollection, Vararg{Any}}","page":"Engine","title":"Base.fill!","text":"Main.Engine.Instances.fill! all the instances with given timeframes data...\n\nfill!(\n    ac::Collections.AssetCollection,\n    tfs...;\n    kwargs...\n) -> DataFrames.DataFrame\n\n\n\n\n\n\n","category":"method"},{"location":"API/engine/#Base.fill!-Tuple{Instances.AssetInstance, Vararg{Any}}","page":"Engine","title":"Base.fill!","text":"Pulls data from storage, or resamples from the shortest timeframe available.\n\nfill!(ai::Instances.AssetInstance, tfs...; exc, force, from)\n\n\nThis fill! function takes the following parameters:\n\nai: an AssetInstance object which represents an instance of an asset.\ntfs...: one or more TimeFrame objects that represent the desired timeframes to fill the data for.\nexc (optional, default is ai.exchange): an Exchange object that represents the exchange to pull data from.\nforce (optional, default is false): a boolean that indicates whether to force the data filling, even if the data is already present.\nfrom (optional, default is nothing): a DateTime object that represents the starting date from which to fill the data.\n\nFills the data for the specified timeframes. If the data is already present and force is false, the function does nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/engine/#Data.stub!-Tuple{Collections.AssetCollection, Any}","page":"Engine","title":"Data.stub!","text":"Replaces the data of the asset instances with src which should be a mapping. Used for backtesting.\n\nstub!(ac::Collections.AssetCollection, src; fromfiat)\n\n\nThe stub! function takes the following parameters:\n\nac: an AssetCollection object which encapsulates a collection of assets.\nsrc: The mapping, should be a pair TimeFrame => Dict{String, PairData}.\nfromfiat (optional, default is true): a boolean that indicates whether the assets are priced in fiat currency. If true, the assets are priced in fiat currency.\n\nThe function replaces the OHLCV data of the assets in the ac collection with the data from the src mapping. This is useful for backtesting trading strategies.\n\nExample:\n\nusing Scrapers.BinanceData as bn\nusing Strategies\nusing Exchanges\nsetexchange!(:binanceusdm)\ncfg = Config(Symbol(exc.id))\nstrat = strategy!(:Example, cfg)\ndata = bn.binanceload()\nstub!(strat.universe, data)\n\n\n\n\n\n","category":"method"},{"location":"presentation/#Why-PingPong?","page":"Why PingPong?","title":"Why PingPong?","text":"","category":"section"},{"location":"presentation/","page":"Why PingPong?","title":"Why PingPong?","text":"using Markdown\nlet lines = readlines(\"../../README.md\", keep=true)\nstart_idx = 1\nline = \"\"\nwhile !occursin(\"PRESENTATION BEGIN\", lines[start_idx])\n    start_idx+=1\nend\nstop_idx = start_idx + 1\nwhile !occursin(\"PRESENTATION END\", lines[stop_idx])\n    stop_idx+=1\nend\njoin(lines[start_idx+1:stop_idx-1]) |> Markdown.parse\nend\n","category":"page"},{"location":"API/executors/#Executors","page":"Executors","title":"Executors","text":"","category":"section"},{"location":"API/executors/","page":"Executors","title":"Executors","text":"Modules = [PingPong.Engine.Executors]","category":"page"},{"location":"API/executors/#Executors.AnyFOKOrder","page":"Executors","title":"Executors.AnyFOKOrder","text":"Type alias for any FOK order \n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.AnyGTCOrder","page":"Executors","title":"Executors.AnyGTCOrder","text":"Type alias for any GTC order \n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.AnyIOCOrder","page":"Executors","title":"Executors.AnyIOCOrder","text":"Type alias for any IOC order \n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.IncreaseLimitOrder","page":"Executors","title":"Executors.IncreaseLimitOrder","text":"Union type representing limit order increase operations. Includes Buy and Sell Short orders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.IncreaseLimitTrade","page":"Executors","title":"Executors.IncreaseLimitTrade","text":"Union type representing limit trade increase operations. Includes Buy and Sell Short trades.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.LIQUIDATION_BUFFER","page":"Executors","title":"Executors.LIQUIDATION_BUFFER","text":"Some exchanges add funding rates and trading fees to the liquidation price, we use a default buffer of -0.02.\n\n\n\n\n\n","category":"constant"},{"location":"API/executors/#Executors.ReduceLimitOrder","page":"Executors","title":"Executors.ReduceLimitOrder","text":"Union type representing limit order reduction operations. Includes Sell and Buy Short orders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.ReduceLimitTrade","page":"Executors","title":"Executors.ReduceLimitTrade","text":"Union type representing limit trade reduction operations. Includes Sell and Buy Short trades.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.AnyLimitOrder","page":"Executors","title":"Executors.AnyLimitOrder","text":"Type alias for any limit order \n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.AnyMarketOrder","page":"Executors","title":"Executors.AnyMarketOrder","text":"Type alias for any market order \n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.AnyPostOnlyOrder","page":"Executors","title":"Executors.AnyPostOnlyOrder","text":"Type alias for any post only order \n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.CancelOrders","page":"Executors","title":"Executors.CancelOrders","text":"Action to cancel open orders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.Context","page":"Executors","title":"Executors.Context","text":"The configuration against which a strategy is tested.\n\nThe Context struct has the following type parameter:\n\nM: a subtype of ExecMode.\n\nThe struct has the following fields:\n\nrange: The date range to backtest around.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.Context-Tuple{Strategies.Strategy}","page":"Executors","title":"Executors.Context","text":"Create an instance of Context for a given strategy using the shortest timeframe.\n\nContext(s::Strategies.Strategy) -> Executors.Context\n\n\nThe Context function takes the following parameters:\n\ns: a Strategy object of subtype ExecMode.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.InitData","page":"Executors","title":"Executors.InitData","text":"Action to initialize OHLCV data.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.LimitBuyTrade","page":"Executors","title":"Executors.LimitBuyTrade","text":"Type representing a limit buy trade, specific to long position buy limit orders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.LimitSellTrade","page":"Executors","title":"Executors.LimitSellTrade","text":"Type representing a limit sell trade, specific to long position sell limit orders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.LimitTrade","page":"Executors","title":"Executors.LimitTrade","text":"Type representing a limit trade, includes long position limit orders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.LongMarketBuyTrade","page":"Executors","title":"Executors.LongMarketBuyTrade","text":"Defines a long market buy trade type.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.LongMarketSellTrade","page":"Executors","title":"Executors.LongMarketSellTrade","text":"Represents a long market sell trade on a certain exchange for a specific asset.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.NewTrade","page":"Executors","title":"Executors.NewTrade","text":"Action executed after a new trade occurs.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.OptRun","page":"Executors","title":"Executors.OptRun","text":"Action run before a single simulation during optimization.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.OptScore","page":"Executors","title":"Executors.OptScore","text":"Action to get the score of a single simulation (after it has finished).\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.OptSetup","page":"Executors","title":"Executors.OptSetup","text":"Action to setup an optimizer (context and params).\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.OrderIterator","page":"Executors","title":"Executors.OrderIterator","text":"A data structure for maintaining a collection of iterators.\n\niters\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.ShortLimitBuyTrade","page":"Executors","title":"Executors.ShortLimitBuyTrade","text":"Type representing a short limit buy trade, specific to short position buy limit orders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.ShortLimitSellTrade","page":"Executors","title":"Executors.ShortLimitSellTrade","text":"Type representing a short limit sell trade, specific to short position sell limit orders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.ShortLimitTrade","page":"Executors","title":"Executors.ShortLimitTrade","text":"Type representing a short limit trade, includes short position limit orders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.UpdateData","page":"Executors","title":"Executors.UpdateData","text":"Action to update OHLCV data (from watchers).\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.UpdateLeverage","page":"Executors","title":"Executors.UpdateLeverage","text":"Action to update leverage.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.UpdateMargin","page":"Executors","title":"Executors.UpdateMargin","text":"Action to update margin mode.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.UpdateOrders","page":"Executors","title":"Executors.UpdateOrders","text":"(DEPRECATED) order updates are done internally now.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.UpdateOrdersShuffled","page":"Executors","title":"Executors.UpdateOrdersShuffled","text":"(DEPRECATED) The shuffled version of UpdateOrders.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.UpdatePositions","page":"Executors","title":"Executors.UpdatePositions","text":"Action to update positions size.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Executors.WatchOHLCV","page":"Executors","title":"Executors.WatchOHLCV","text":"Action to setup an OHLCV watcher.\n\n\n\n\n\n","category":"type"},{"location":"API/executors/#Base.collect-Tuple{Executors.OrderIterator}","page":"Executors","title":"Base.collect","text":"Collects all elements of the OrderIterator into a Vector.\n\ncollect(\n    oi::Executors.OrderIterator\n) -> Vector{Pair{@NamedTuple{price::Float64, time::Dates.DateTime}, <:OrderTypes.Order}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.count-Tuple{Executors.OrderIterator}","page":"Executors","title":"Base.count","text":"Counts the number of elements in the OrderIterator.\n\ncount(oi::Executors.OrderIterator) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.delete!-Tuple{Strategies.Strategy, Any, OrderTypes.IncreaseOrder}","page":"Executors","title":"Base.delete!","text":"Removes a single order from the order queue.\n\ndelete!(\n    s::Strategies.Strategy,\n    ai,\n    o::OrderTypes.IncreaseOrder\n) -> Union{Nothing, Set{Instances.AssetInstance{T, E} where T<:AbstractAsset} where E<:ExchangeID}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.delete!-Tuple{Strategies.Strategy, Any, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E}}","page":"Executors","title":"Base.delete!","text":"Removes a single short buy order from the order queue.\n\ndelete!(\n    s::Strategies.Strategy,\n    ai,\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E}\n) -> Union{Nothing, Set{Instances.AssetInstance{T, E} where T<:AbstractAsset} where E<:ExchangeID}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.delete!-Tuple{Strategies.Strategy, Any, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E}}","page":"Executors","title":"Base.delete!","text":"Removes a single sell order from the order queue.\n\ndelete!(\n    s::Strategies.Strategy,\n    ai,\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E}\n) -> Union{Nothing, Set{Instances.AssetInstance{T, E} where T<:AbstractAsset} where E<:ExchangeID}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.delete!-Tuple{Strategies.Strategy, Any, Type{<:Union{OrderTypes.Buy, OrderTypes.Sell}}}","page":"Executors","title":"Base.delete!","text":"Removes all buy/sell orders for an asset instance.\n\ndelete!(\n    s::Strategies.Strategy,\n    ai,\n    t::Type{<:Union{OrderTypes.Buy, OrderTypes.Sell}}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.delete!-Tuple{Strategies.Strategy, Any, Type{OrderTypes.BuyOrSell}}","page":"Executors","title":"Base.delete!","text":"Removes all buy and sell orders for an asset instance.\n\ndelete!(\n    s::Strategies.Strategy,\n    ai,\n    _::Type{OrderTypes.BuyOrSell}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.delete!-Tuple{Strategies.Strategy, Any}","page":"Executors","title":"Base.delete!","text":"Removes all orders for an asset instance.\n\ndelete!(s::Strategies.Strategy, ai) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.eltype-Tuple{Executors.OrderIterator}","page":"Executors","title":"Base.eltype","text":"Returns the element type of the OrderIterator.\n\neltype(\n    _::Executors.OrderIterator\n) -> Type{Pair{@NamedTuple{price::Float64, time::Dates.DateTime}, <:OrderTypes.Order}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.fill!-Tuple{Strategies.Strategy{<:Union{Misc.Paper, Misc.Sim}}, Instances.AssetInstance, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E}, OrderTypes.ShortBuyTrade}","page":"Executors","title":"Base.fill!","text":"Fills a short buy order.\n\nfill!(\n    _::Strategies.Strategy{<:Union{Misc.Paper, Misc.Sim}},\n    ai::Instances.AssetInstance,\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E},\n    t::OrderTypes.ShortBuyTrade\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.fill!-Tuple{Strategies.Strategy{<:Union{Misc.Paper, Misc.Sim}}, Instances.AssetInstance, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E}, OrderTypes.SellTrade}","page":"Executors","title":"Base.fill!","text":"Fills a sell order.\n\nfill!(\n    _::Strategies.Strategy{<:Union{Misc.Paper, Misc.Sim}},\n    ai::Instances.AssetInstance,\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E},\n    t::OrderTypes.SellTrade\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.fill!-Tuple{Strategies.Strategy{<:Union{Misc.Paper, Misc.Sim}}, Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Long} where {A, E}, OrderTypes.BuyTrade}","page":"Executors","title":"Base.fill!","text":"Fills a buy order for a no-margin strategy.\n\nfill!(\n    _::Strategies.Strategy{<:Union{Misc.Paper, Misc.Sim}},\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin},\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Long} where {A, E},\n    t::OrderTypes.BuyTrade\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.fill!-Tuple{Strategies.Strategy{var\"#s254\", N, <:ExchangeID, <:Misc.WithMargin, C} where {var\"#s254\"<:Union{Misc.Paper, Misc.Sim}, N, C}, Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, OrderTypes.IncreaseOrder, OrderTypes.IncreaseTrade}","page":"Executors","title":"Base.fill!","text":"Fills an increase order for a margin strategy.\n\nfill!(\n    _::Strategies.Strategy{var\"#s254\", N, <:ExchangeID, <:Misc.WithMargin, C} where {var\"#s254\"<:Union{Misc.Paper, Misc.Sim}, N, C},\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    o::OrderTypes.IncreaseOrder,\n    t::OrderTypes.IncreaseTrade\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.first-Union{Tuple{E}, Tuple{S}, Tuple{M}, Tuple{Strategies.Strategy{M, S, E}, Any}, Tuple{Strategies.Strategy{M, S, E}, Any, OrderTypes.BySide}} where {M, S, E}","page":"Executors","title":"Base.first","text":"Returns the first order for an asset in a strategy.\n\nfirst(s::Strategies.Strategy{M, S, E}, ai) -> Any\nfirst(\n    s::Strategies.Strategy{M, S, E},\n    ai,\n    bs::OrderTypes.BySide\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.firstindex-Union{Tuple{E}, Tuple{S}, Tuple{M}, Tuple{Strategies.Strategy{M, S, E}, Any}, Tuple{Strategies.Strategy{M, S, E}, Any, OrderTypes.BySide}} where {M, S, E}","page":"Executors","title":"Base.firstindex","text":"Returns the first index for an order for an asset in a strategy.\n\nfirstindex(s::Strategies.Strategy{M, S, E}, ai) -> Any\nfirstindex(\n    s::Strategies.Strategy{M, S, E},\n    ai,\n    bs::OrderTypes.BySide\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.haskey-Tuple{Strategies.Strategy, Any, @NamedTuple{price::Float64, time::Dates.DateTime}, Union{Type{OrderTypes.BuyOrSell}, OrderTypes.BuyOrSell, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.BuyOrSell}}}, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.BuyOrSell}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.BuyOrSell}}}}","page":"Executors","title":"Base.haskey","text":"Checks if a strategy has a specific order for an asset by price and time.\n\nhaskey(\n    s::Strategies.Strategy,\n    ai,\n    pt::@NamedTuple{price::Float64, time::Dates.DateTime},\n    _::Union{Type{OrderTypes.BuyOrSell}, OrderTypes.BuyOrSell, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.BuyOrSell}}}, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.BuyOrSell}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.BuyOrSell}}}\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.haskey-Tuple{Strategies.Strategy, Any, @NamedTuple{price::Float64, time::Dates.DateTime}, Union{Type{var\"#s254\"}, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{var\"#s254\"}}}, OrderTypes.Order{<:OrderTypes.OrderType{var\"#s254\"}}, OrderTypes.Trade{<:OrderTypes.OrderType{var\"#s254\"}}, var\"#s254\"} where var\"#s254\"<:Union{OrderTypes.Buy, OrderTypes.Sell}}","page":"Executors","title":"Base.haskey","text":"Checks if a strategy has a specific order for an asset by price and time.\n\nhaskey(\n    s::Strategies.Strategy,\n    ai,\n    pt::@NamedTuple{price::Float64, time::Dates.DateTime},\n    side::Union{Type{var\"#s254\"}, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{var\"#s254\"}}}, OrderTypes.Order{<:OrderTypes.OrderType{var\"#s254\"}}, OrderTypes.Trade{<:OrderTypes.OrderType{var\"#s254\"}}, var\"#s254\"} where var\"#s254\"<:Union{OrderTypes.Buy, OrderTypes.Sell}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.haskey-Tuple{Strategies.Strategy, Any, @NamedTuple{price::Float64, time::Dates.DateTime}}","page":"Executors","title":"Base.haskey","text":"Checks if a strategy has a specific order for an asset by price and time.\n\nhaskey(\n    s::Strategies.Strategy,\n    ai,\n    pt::@NamedTuple{price::Float64, time::Dates.DateTime}\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.haskey-Tuple{Strategies.Strategy, Any, OrderTypes.Order}","page":"Executors","title":"Base.haskey","text":"Checks if a strategy has a specific order for an asset.\n\nhaskey(\n    s::Strategies.Strategy,\n    ai,\n    o::OrderTypes.Order\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.isdone-Tuple{Executors.OrderIterator}","page":"Executors","title":"Base.isdone","text":"Checks if the OrderIterator is empty.\n\nisdone(oi::Executors.OrderIterator) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.isopen-Tuple{Instances.AssetInstance, OrderTypes.Order}","page":"Executors","title":"Base.isopen","text":"Checks if an order is open.\n\nisopen(\n    ai::Instances.AssetInstance,\n    o::OrderTypes.Order\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.iszero-Tuple{Instances.AssetInstance, OrderTypes.Order}","page":"Executors","title":"Base.iszero","text":"Checks if the order amount left to fill is below minimum qty.\n\niszero(\n    ai::Instances.AssetInstance,\n    o::OrderTypes.Order\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.iterate-Tuple{Executors.OrderIterator, Any}","page":"Executors","title":"Base.iterate","text":"Returns the next element in the OrderIterator.\n\niterate(\n    oi::Executors.OrderIterator,\n    _\n) -> Union{Nothing, Tuple{Any, Nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.keys-Tuple{Strategies.Strategy, Vararg{Any}}","page":"Executors","title":"Base.keys","text":"Returns all keys for orders in a strategy.\n\nkeys(s::Strategies.Strategy, args...; kwargs...) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.last-Tuple{Executors.OrderIterator}","page":"Executors","title":"Base.last","text":"Returns the last element in the OrderIterator.\n\nlast(oi::Executors.OrderIterator) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.last-Union{Tuple{E}, Tuple{S}, Tuple{M}, Tuple{Strategies.Strategy{M, S, E}, Any}, Tuple{Strategies.Strategy{M, S, E}, Any, OrderTypes.BySide}} where {M, S, E}","page":"Executors","title":"Base.last","text":"Returns the last order for an asset in a strategy.\n\nlast(s::Strategies.Strategy{M, S, E}, ai) -> Any\nlast(\n    s::Strategies.Strategy{M, S, E},\n    ai,\n    bs::OrderTypes.BySide\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.lastindex-Union{Tuple{E}, Tuple{S}, Tuple{M}, Tuple{Strategies.Strategy{M, S, E}, Any}, Tuple{Strategies.Strategy{M, S, E}, Any, OrderTypes.BySide}} where {M, S, E}","page":"Executors","title":"Base.lastindex","text":"Returns the last index for an order for an asset in a strategy.\n\nlastindex(s::Strategies.Strategy{M, S, E}, ai) -> Any\nlastindex(\n    s::Strategies.Strategy{M, S, E},\n    ai,\n    bs::OrderTypes.BySide\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.push!-Union{Tuple{S}, Tuple{Strategies.Strategy, Any, OrderTypes.Order{<:OrderTypes.OrderType{S}}}} where S<:OrderTypes.OrderSide","page":"Executors","title":"Base.push!","text":"Inserts an order into the order dict of the asset instance. Orders should be identifiable by a unique (price, date) tuple.\n\npush!(\n    s::Strategies.Strategy,\n    ai,\n    o::OrderTypes.Order{<:OrderTypes.OrderType{S<:OrderTypes.OrderSide}}\n) -> OrderTypes.Order{<:OrderTypes.OrderType{S}} where S<:OrderTypes.OrderSide\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Base.values-Tuple{Strategies.Strategy, Vararg{Any}}","page":"Executors","title":"Base.values","text":"Returns all values for orders in a strategy.\n\nvalues(s::Strategies.Strategy, args...; kwargs...) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.Checks.cost-Tuple{OrderTypes.Order}","page":"Executors","title":"Executors.Checks.cost","text":"Returns the cost of an order.\n\ncost(o::OrderTypes.Order) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_cash-Tuple{Instances.AssetInstance, Misc.Long}","page":"Executors","title":"Executors._check_cash","text":"Checks the cash for an asset instance in a strategy for long.\n\n_check_cash(ai::Instances.AssetInstance, _::Misc.Long)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_cash-Tuple{Instances.AssetInstance, Misc.Short}","page":"Executors","title":"Executors._check_cash","text":"Checks the cash for an asset instance in a strategy for short.\n\n_check_cash(ai::Instances.AssetInstance, _::Misc.Short)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_committment-Tuple{Any}","page":"Executors","title":"Executors._check_committment","text":"Checks order committment to be within expected values.\n\n_check_committment(o)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_trade-Tuple{OrderTypes.BuyTrade, Any}","page":"Executors","title":"Executors._check_trade","text":"Checks a buy trade.\n\n_check_trade(t::OrderTypes.BuyTrade, ai)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_trade-Tuple{OrderTypes.SellTrade, Any}","page":"Executors","title":"Executors._check_trade","text":"Checks a sell trade.\n\n_check_trade(t::OrderTypes.SellTrade, ai)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_trade-Tuple{OrderTypes.ShortBuyTrade, Any}","page":"Executors","title":"Executors._check_trade","text":"Checks a short buy trade.\n\n_check_trade(t::OrderTypes.ShortBuyTrade, ai)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_trade-Tuple{OrderTypes.ShortSellTrade, Any}","page":"Executors","title":"Executors._check_trade","text":"Checks a short sell trade.\n\n_check_trade(t::OrderTypes.ShortSellTrade, ai)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_unfillment-Tuple{OrderTypes.AnyBuyOrder{P, <:AbstractAsset, <:ExchangeID, var\"#s255\"} where {P<:Misc.PositionSide, var\"#s255\"<:OrderTypes.LimitOrderType{OrderTypes.Buy}}}","page":"Executors","title":"Executors._check_unfillment","text":"Checks if the unfilled amount for a limit buy order is negative.\n\n_check_unfillment(\n    o::OrderTypes.AnyBuyOrder{P, <:AbstractAsset, <:ExchangeID, var\"#s255\"} where {P<:Misc.PositionSide, var\"#s255\"<:OrderTypes.LimitOrderType{OrderTypes.Buy}}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_unfillment-Tuple{OrderTypes.AnyBuyOrder{P, <:AbstractAsset, <:ExchangeID, var\"#s255\"} where {P<:Misc.PositionSide, var\"#s255\"<:OrderTypes.MarketOrderType{OrderTypes.Buy}}}","page":"Executors","title":"Executors._check_unfillment","text":"Checks if the unfilled amount for a market buy order is negative.\n\n_check_unfillment(\n    o::OrderTypes.AnyBuyOrder{P, <:AbstractAsset, <:ExchangeID, var\"#s255\"} where {P<:Misc.PositionSide, var\"#s255\"<:OrderTypes.MarketOrderType{OrderTypes.Buy}}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_unfillment-Tuple{OrderTypes.AnySellOrder{P, <:AbstractAsset, <:ExchangeID, var\"#s255\"} where {P<:Misc.PositionSide, var\"#s255\"<:OrderTypes.LimitOrderType{OrderTypes.Sell}}}","page":"Executors","title":"Executors._check_unfillment","text":"Checks if the unfilled amount for a limit sell order is positive.\n\n_check_unfillment(\n    o::OrderTypes.AnySellOrder{P, <:AbstractAsset, <:ExchangeID, var\"#s255\"} where {P<:Misc.PositionSide, var\"#s255\"<:OrderTypes.LimitOrderType{OrderTypes.Sell}}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_unfillment-Tuple{OrderTypes.AnySellOrder{P, <:AbstractAsset, <:ExchangeID, var\"#s255\"} where {P<:Misc.PositionSide, var\"#s255\"<:OrderTypes.MarketOrderType{OrderTypes.Sell}}}","page":"Executors","title":"Executors._check_unfillment","text":"Checks if the unfilled amount for a market sell order is positive.\n\n_check_unfillment(\n    o::OrderTypes.AnySellOrder{P, <:AbstractAsset, <:ExchangeID, var\"#s255\"} where {P<:Misc.PositionSide, var\"#s255\"<:OrderTypes.MarketOrderType{OrderTypes.Sell}}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_unfillment-Tuple{OrderTypes.LongOrder}","page":"Executors","title":"Executors._check_unfillment","text":"Checks if the unfilled amount for a long order is positive.\n\n_check_unfillment(o::OrderTypes.LongOrder) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._check_unfillment-Tuple{OrderTypes.ShortOrder}","page":"Executors","title":"Executors._check_unfillment","text":"Checks if the unfilled amount for a short order is negative.\n\n_check_unfillment(o::OrderTypes.ShortOrder) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._do_orders_iter-Tuple{Any}","page":"Executors","title":"Executors._do_orders_iter","text":"Filters out empty iterators and returns the smallest value.\n\n_do_orders_iter(oi) -> Union{Nothing, Tuple{Any, Nothing}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._doclamp-Tuple{Any, Any, Vararg{Any}}","page":"Executors","title":"Executors._doclamp","text":"Clamps the given values within the correct boundaries.\n\n_doclamp(clamper, ai, whats...) -> Expr\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._findmin-Tuple{Any}","page":"Executors","title":"Executors._findmin","text":"Finds and returns the iterator with the smallest value.\n\n_findmin(non_empty_iters) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors._hasany-Tuple{Any}","page":"Executors","title":"Executors._hasany","text":"Checks if an array has any elements.\n\n_hasany(arr) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.aftertrade!-NTuple{4, Any}","page":"Executors","title":"Executors.aftertrade!","text":"Performs cleanups after a trade (attempt).\n\naftertrade!(s, ai, o, t) -> OrderTypes.Trade\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.aftertrade!-Tuple{Strategies.Strategy, Any, OrderTypes.Order{<:OrderTypes.LimitOrderType{S}, <:AbstractAsset, <:ExchangeID, P} where {S<:OrderTypes.OrderSide, P<:Misc.PositionSide}}","page":"Executors","title":"Executors.aftertrade!","text":"Removes a filled limit order from the queue\n\naftertrade!(\n    s::Strategies.Strategy,\n    ai,\n    o::OrderTypes.Order{<:OrderTypes.LimitOrderType{S}, <:AbstractAsset, <:ExchangeID, P} where {S<:OrderTypes.OrderSide, P<:Misc.PositionSide}\n) -> Any\n\n\nThe function is used post-trade to clean up the strategy's order queue.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.aftertrade!-Tuple{Strategies.Strategy, Any, Union{OrderTypes.Order{<:OrderTypes.MarketOrderType{S}, <:AbstractAsset, <:ExchangeID, P} where {S<:OrderTypes.OrderSide, P<:Misc.PositionSide}, OrderTypes.FOKOrder, OrderTypes.IOCOrder, OrderTypes.ShortFOKOrder, OrderTypes.ShortIOCOrder}}","page":"Executors","title":"Executors.aftertrade!","text":"Unconditionally dequeues immediate orders.\n\naftertrade!(\n    s::Strategies.Strategy,\n    ai,\n    o::Union{OrderTypes.Order{<:OrderTypes.MarketOrderType{S}, <:AbstractAsset, <:ExchangeID, P} where {S<:OrderTypes.OrderSide, P<:Misc.PositionSide}, OrderTypes.FOKOrder, OrderTypes.IOCOrder, OrderTypes.ShortFOKOrder, OrderTypes.ShortIOCOrder}\n) -> Any\n\n\nThis function is called after a trade to remove filled 'Fill Or Kill' (FOK) or 'Immediate Or Cancel' (IOC) orders from the strategy's order queue.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.amount-Tuple{OrderTypes.Order}","page":"Executors","title":"Executors.amount","text":"Returns the amount of an order.\n\namount(o::OrderTypes.Order) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.basic_order_state-Union{Tuple{T}, Tuple{Any, Any, Ref{T}, Ref{T}}, Tuple{Any, Any, Ref{T}, Ref{T}, Any}} where T<:Real","page":"Executors","title":"Executors.basic_order_state","text":"Constructs a basic order state with given parameters.\n\nbasic_order_state(\n    take,\n    stop,\n    committed::Ref{T<:Real},\n    unfilled::Ref{T<:Real}\n) -> NamedTuple{(:take, :stop, :committed, :unfilled, :trades), T1} where {T<:Real, T1<:Union{Tuple{Nothing, Nothing, Ref{T}, Ref{T}, Vector{OrderTypes.Trade}}, Tuple{Nothing, Real, Ref{T}, Ref{T}, Vector{OrderTypes.Trade}}, Tuple{Real, Nothing, Ref{T}, Ref{T}, Vector{OrderTypes.Trade}}, Tuple{Real, Real, Ref{T}, Ref{T}, Vector{OrderTypes.Trade}}}}\nbasic_order_state(\n    take,\n    stop,\n    committed::Ref{T<:Real},\n    unfilled::Ref{T<:Real},\n    trades\n) -> NamedTuple{(:take, :stop, :committed, :unfilled, :trades), T1} where {T<:Real, T1<:Union{Tuple{Nothing, Nothing, Ref{T}, Ref{T}, Vector{OrderTypes.Trade}}, Tuple{Nothing, Real, Ref{T}, Ref{T}, Vector{OrderTypes.Trade}}, Tuple{Real, Nothing, Ref{T}, Ref{T}, Vector{OrderTypes.Trade}}, Tuple{Real, Real, Ref{T}, Ref{T}, Vector{OrderTypes.Trade}}}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.basicorder-Tuple{Instances.AssetInstance, Any, Any, Any, Executors.Checks.SanitizeOff}","page":"Executors","title":"Executors.basicorder","text":"Constructs an Order for a given OrderType type and inputs.\n\nbasicorder(\n    ai::Instances.AssetInstance,\n    price,\n    amount,\n    committed,\n    ::Executors.Checks.SanitizeOff;\n    type,\n    date,\n    loss,\n    profit,\n    id,\n    tag\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.buyorders-Tuple{Strategies.Strategy, Any}","page":"Executors","title":"Executors.buyorders","text":"Returns buy orders for an asset in a strategy.\n\nbuyorders(\n    s::Strategies.Strategy,\n    ai\n) -> SortedDict{@NamedTuple{price::Float64, time::Dates.DateTime}, D, Strategies.BuyPriceTimeOrdering} where D<:(OrderTypes.AnyBuyOrder{P, T, E} where {E<:ExchangeID, P<:Misc.PositionSide, T<:AbstractAsset})\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.cancel!-Tuple{Strategies.Strategy, OrderTypes.Order, Any}","page":"Executors","title":"Executors.cancel!","text":"Cancels an order with given error.\n\ncancel!(\n    s::Strategies.Strategy,\n    o::OrderTypes.Order,\n    ai;\n    err\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.committment-Tuple{Instances.AssetInstance, OrderTypes.Order}","page":"Executors","title":"Executors.committment","text":"Calculates the commitment for an order.\n\ncommittment(\n    ai::Instances.AssetInstance,\n    o::OrderTypes.Order;\n    kwargs...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.committment-Tuple{Instances.AssetInstance, OrderTypes.Trade}","page":"Executors","title":"Executors.committment","text":"Calculates the partial commitment of a trade.\n\ncommittment(\n    ai::Instances.AssetInstance,\n    t::OrderTypes.Trade\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.committment-Tuple{Type{<:OrderTypes.IncreaseOrder}, Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Any, Any}","page":"Executors","title":"Executors.committment","text":"Calculates the commitment for a leveraged position.\n\ncommittment(\n    o::Type{<:OrderTypes.IncreaseOrder},\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    price,\n    amount;\n    ntl,\n    fees,\n    lev,\n    kwargs...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.committment-Tuple{Type{<:OrderTypes.IncreaseOrder}, Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin}, Any, Any}","page":"Executors","title":"Executors.committment","text":"Calculates the commitment for an increase order without margin.\n\ncommittment(\n    ::Type{<:OrderTypes.IncreaseOrder},\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, NoMargin},\n    price,\n    amount;\n    kwargs...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.committment-Tuple{Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E}}, Any, Any, Any}","page":"Executors","title":"Executors.committment","text":"Calculates the commitment when exiting a position for shorts.\n\ncommittment(\n    ::Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E}},\n    ai,\n    price,\n    amount;\n    fees_base,\n    kwargs...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.committment-Tuple{Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E}}, Any, Any, Any}","page":"Executors","title":"Executors.committment","text":"Calculates the commitment when exiting a position for longs.\n\ncommittment(\n    ::Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E}},\n    ai,\n    price,\n    amount;\n    fees_base,\n    kwargs...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.decommit!","page":"Executors","title":"Executors.decommit!","text":"Decommits an increase order from a strategy.\n\ndecommit!(\n    s::Strategies.Strategy,\n    o::OrderTypes.IncreaseOrder,\n    ai\n) -> Float64\ndecommit!(\n    s::Strategies.Strategy,\n    o::OrderTypes.IncreaseOrder,\n    ai,\n    canceled\n) -> Float64\n\n\n\n\n\n\n","category":"function"},{"location":"API/executors/#Executors.decommit!-Tuple{Strategies.Strategy, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E}, Any, Vararg{Any}}","page":"Executors","title":"Executors.decommit!","text":"Decommits a short buy order from an asset instance.\n\ndecommit!(\n    s::Strategies.Strategy,\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E},\n    ai,\n    args...\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.decommit!-Tuple{Strategies.Strategy, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E}, Any, Vararg{Any}}","page":"Executors","title":"Executors.decommit!","text":"Decommits a sell order from an asset instance.\n\ndecommit!(\n    s::Strategies.Strategy,\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E},\n    ai,\n    args...\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.feespaid-Tuple{OrderTypes.Order}","page":"Executors","title":"Executors.feespaid","text":"The sum of all the trades fees that have heppened for the order.\n\nfeespaid(o::OrderTypes.Order) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.filled_amount-Tuple{Any}","page":"Executors","title":"Executors.filled_amount","text":"Returns the filled amount of an order.\n\nfilled_amount(o) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hascash-Tuple{Strategies.Strategy}","page":"Executors","title":"Executors.hascash","text":"Checks if any of the holdings has non dust cash.\n\nhascash(s::Strategies.Strategy) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hasorders-Tuple{Strategies.Strategy, Any, Type{OrderTypes.Buy}}","page":"Executors","title":"Executors.hasorders","text":"Checks if an asset instance has pending buy orders in a strategy.\n\nhasorders(\n    s::Strategies.Strategy,\n    ai,\n    _::Type{OrderTypes.Buy}\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hasorders-Tuple{Strategies.Strategy, Any, Type{OrderTypes.Sell}}","page":"Executors","title":"Executors.hasorders","text":"Checks if an asset instance has pending sell orders in a strategy.\n\nhasorders(\n    s::Strategies.Strategy,\n    ai,\n    _::Type{OrderTypes.Sell}\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hasorders-Tuple{Strategies.Strategy, Instances.AssetInstance}","page":"Executors","title":"Executors.hasorders","text":"Checks if an asset instance has pending orders in a strategy.\n\nhasorders(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hasorders-Tuple{Strategies.Strategy, Type{OrderTypes.Buy}}","page":"Executors","title":"Executors.hasorders","text":"Checks if a strategy has buy orders.\n\nhasorders(\n    s::Strategies.Strategy,\n    _::Type{OrderTypes.Buy}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hasorders-Tuple{Strategies.Strategy, Type{OrderTypes.Sell}}","page":"Executors","title":"Executors.hasorders","text":"Checks if a strategy has sell orders.\n\nhasorders(\n    s::Strategies.Strategy,\n    _::Type{OrderTypes.Sell}\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hasorders-Tuple{Strategies.Strategy{X, N, <:ExchangeID, <:Misc.WithMargin, C} where {X<:Misc.ExecMode, N, C}, Any, Misc.PositionSide}","page":"Executors","title":"Executors.hasorders","text":"Checks if there are any orders for a given position side\n\nhasorders(\n    s::Strategies.Strategy{X, N, <:ExchangeID, <:Misc.WithMargin, C} where {X<:Misc.ExecMode, N, C},\n    ai,\n    ps::Misc.PositionSide\n) -> Any\n\n\nThis function checks both Buy and Sell sides for any orders that match the provided position side in the Margin Strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hasorders-Tuple{Strategies.Strategy}","page":"Executors","title":"Executors.hasorders","text":"Checks if a strategy has orders.\n\nhasorders(s::Strategies.Strategy) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hasorders-Union{Tuple{S}, Tuple{Strategies.Strategy, Any, String}, Tuple{Strategies.Strategy, Any, String, OrderTypes.BySide{S}}} where S<:OrderTypes.OrderSide","page":"Executors","title":"Executors.hasorders","text":"Checks if an asset instance has a specific order in a strategy by side.\n\nhasorders(s::Strategies.Strategy, ai, id::String) -> Bool\nhasorders(\n    s::Strategies.Strategy,\n    ai,\n    id::String,\n    ::Union{Type{S<:OrderTypes.OrderSide}, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{S<:OrderTypes.OrderSide}}}, OrderTypes.Order{<:OrderTypes.OrderType{S<:OrderTypes.OrderSide}}, OrderTypes.Trade{<:OrderTypes.OrderType{S<:OrderTypes.OrderSide}}, S<:OrderTypes.OrderSide}\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hastrade-Tuple{Instances.AssetInstance, OrderTypes.Order, OrderTypes.Trade}","page":"Executors","title":"Executors.hastrade","text":"More precise version of hastrade.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hastrade-Tuple{OrderTypes.Order, OrderTypes.Trade}","page":"Executors","title":"Executors.hastrade","text":"Check if the given trade is in the order.\n\nhastrade(o::OrderTypes.Order, t::OrderTypes.Trade) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hold!-Tuple{Strategies.Strategy, Any, OrderTypes.IncreaseOrder}","page":"Executors","title":"Executors.hold!","text":"When an increase order is added to a strategy, the asset is added to the holdings.\n\nhold!(\n    s::Strategies.Strategy,\n    ai,\n    o::OrderTypes.IncreaseOrder\n) -> Set{Instances.AssetInstance{T, E} where T<:AbstractAsset} where E<:ExchangeID\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.hold!-Tuple{Strategies.Strategy, Any, OrderTypes.ReduceOrder}","page":"Executors","title":"Executors.hold!","text":"Reduce orders can never switch an asset from not held to held.\n\nhold!(_::Strategies.Strategy, _, _::OrderTypes.ReduceOrder)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.iscommittable-Tuple{Strategies.Strategy, OrderTypes.IncreaseOrder, Any}","page":"Executors","title":"Executors.iscommittable","text":"Checks if an increase order can be committed to a strategy.\n\niscommittable(\n    s::Strategies.Strategy,\n    o::OrderTypes.IncreaseOrder,\n    ai\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.iscommittable-Tuple{Strategies.Strategy, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E}, Any}","page":"Executors","title":"Executors.iscommittable","text":"Checks if a short buy order can be committed to an asset instance.\n\niscommittable(\n    _::Strategies.Strategy,\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E},\n    ai\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.iscommittable-Tuple{Strategies.Strategy, OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E}, Any}","page":"Executors","title":"Executors.iscommittable","text":"Checks if a sell order can be committed to an asset instance.\n\niscommittable(\n    _::Strategies.Strategy,\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E},\n    ai\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.iscommittable-Tuple{Strategies.Strategy, Type{<:OrderTypes.IncreaseOrder}, Any, Any}","page":"Executors","title":"Executors.iscommittable","text":"Checks if a strategy can commit to an increase order.\n\niscommittable(\n    s::Strategies.Strategy,\n    _::Type{<:OrderTypes.IncreaseOrder},\n    commit,\n    ai\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.iscommittable-Tuple{Strategies.Strategy, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E}}, Any, Any}","page":"Executors","title":"Executors.iscommittable","text":"Checks if a strategy can commit to a short buy order.\n\niscommittable(\n    _::Strategies.Strategy,\n    _::Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, A, E, Misc.Short} where {A, E}},\n    commit,\n    ai\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.iscommittable-Tuple{Strategies.Strategy, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E}}, Any, Any}","page":"Executors","title":"Executors.iscommittable","text":"Checks if a strategy can commit to a sell order.\n\niscommittable(\n    s::Strategies.Strategy,\n    _::Type{<:OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Sell}, A, E, Misc.Long} where {A, E}},\n    commit,\n    ai\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.isfilled-Tuple{Instances.AssetInstance, OrderTypes.Order}","page":"Executors","title":"Executors.isfilled","text":"Checks if an order is filled.\n\nisfilled(\n    ai::Instances.AssetInstance,\n    o::OrderTypes.Order\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.isfirstfill-Tuple{Instances.AssetInstance, OrderTypes.Trade{<:OrderTypes.LimitOrderType}}","page":"Executors","title":"Executors.isfirstfill","text":"Checks if the provided trade is the first fill for the given asset instance.\n\nisfirstfill(\n    _::Instances.AssetInstance,\n    t::OrderTypes.Trade{<:OrderTypes.LimitOrderType}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.islastfill-Tuple{Instances.AssetInstance, OrderTypes.Trade{<:OrderTypes.LimitOrderType}}","page":"Executors","title":"Executors.islastfill","text":"Checks if the provided trade is the last fill for the given asset instance.\n\nislastfill(\n    ai::Instances.AssetInstance,\n    t::OrderTypes.Trade{<:OrderTypes.LimitOrderType}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.isliquidatable-Tuple{Strategies.RTStrategy, Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Misc.PositionSide, Dates.DateTime}","page":"Executors","title":"Executors.isliquidatable","text":"Tests if a position should be liquidated at a particular price.\n\nisliquidatable(\n    _::Strategies.RTStrategy,\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    p::Misc.PositionSide,\n    date::Dates.DateTime\n) -> Any\n\n\nThis function checks whether a position in a Paper or Live strategy should be liquidated at the current price at the specified date.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.isliquidatable-Tuple{Strategies.SimStrategy, Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Misc.PositionSide, Dates.DateTime}","page":"Executors","title":"Executors.isliquidatable","text":"Checks if a position is liquidatable at a given date\n\nisliquidatable(\n    _::Strategies.SimStrategy,\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    p::Misc.PositionSide,\n    date::Dates.DateTime\n) -> Any\n\n\nThis function determines whether a position in a margin strategy is eligible for liquidation at the specified date.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.isoutof_orders-Tuple{Strategies.Strategy}","page":"Executors","title":"Executors.isoutof_orders","text":"Checks if a strategy is out of orders.\n\nisoutof_orders(s::Strategies.Strategy) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.isqueued-Union{Tuple{S}, Tuple{OrderTypes.Order{<:OrderTypes.OrderType{S}}, Strategies.Strategy, Any}} where S<:OrderTypes.OrderSide","page":"Executors","title":"Executors.isqueued","text":"Checks if an order is already added to the queue.\n\nisqueued(\n    o::OrderTypes.Order{<:OrderTypes.OrderType{S<:OrderTypes.OrderSide}},\n    s::Strategies.Strategy,\n    ai\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.limitorder-Tuple{Strategies.Strategy, Any, Any}","page":"Executors","title":"Executors.limitorder","text":"Places a limit order in the strategy\n\nlimitorder(\n    s::Strategies.Strategy,\n    ai,\n    amount;\n    date,\n    type,\n    price,\n    take,\n    stop,\n    skipcommit,\n    kwargs...\n)\n\n\nThis function places a limit order with specified parameters in the strategy s. The type argument specifies the type of the order. The price defaults to the current price at the given date if not provided. The take and stop arguments are optional and default to nothing. If skipcommit is true, the function will not commit the order. Additional arguments can be passed via kwargs.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.liquidations-Tuple{Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin}","page":"Executors","title":"Executors.liquidations","text":"The number of liquidations that have happened for an asset instance.\n\nliquidations(\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin\n) -> @NamedTuple{long::Vector{OrderTypes.Trade}, long_loss::Float64, short::Vector{OrderTypes.Trade}, short_loss::Float64}\n\n\nThis function counts the number of liquidations that have occurred in the history of a margin asset instance.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.longorders-Tuple{Strategies.Strategy, Any, Type{<:OrderTypes.OrderSide}}","page":"Executors","title":"Executors.longorders","text":"Returns a generator for long orders matching a given order side\n\nlongorders(\n    s::Strategies.Strategy,\n    ai,\n    os::Type{<:OrderTypes.OrderSide}\n) -> Base.Generator{I, typeof(identity)} where I<:(Base.Iterators.Filter{Executors.var\"#90#91\"{Misc.Long}})\n\n\nThis function utilizes the orders function to generate orders for the Long position side that match the provided order side.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.marketorder-Tuple{Strategies.Strategy, Any, Any}","page":"Executors","title":"Executors.marketorder","text":"Executes a market order.\n\nmarketorder(\n    s::Strategies.Strategy,\n    ai,\n    amount;\n    date,\n    type,\n    take,\n    stop,\n    price,\n    skipcommit,\n    kwargs...\n)\n\n\nThis function takes a strategy, an ai, an amount, and other optional arguments such as date, type, take, stop, price, and kwargs. It executes a market order with the given parameters. If skipcommit is set to false (default), the order is committed. Returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.order_byid-Tuple{Strategies.Strategy, Instances.AssetInstance, String}","page":"Executors","title":"Executors.order_byid","text":"Returns the order that matches the given id (if any).\n\norder_byid(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance,\n    id::String\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Any, Any, Type{OrderTypes.BuyOrSell}}","page":"Executors","title":"Executors.orders","text":"Returns all orders for an asset instance in a strategy.\n\norders(s, ai, _::Type{OrderTypes.BuyOrSell}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy, Any, Misc.PositionSide, Type{<:OrderTypes.OrderSide}}","page":"Executors","title":"Executors.orders","text":"Returns a generator for orders matching a given position side and order side\n\norders(\n    s::Strategies.Strategy,\n    ai,\n    pos::Misc.PositionSide,\n    os::Type{<:OrderTypes.OrderSide}\n) -> Base.Generator{I, typeof(identity)} where I<:(Base.Iterators.Filter{F} where F<:(Executors.var\"#90#91\"{<:Misc.PositionSide}))\n\n\nThis function iterates over the orders of a strategy, returning only those that match the provided position side and order side.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy, Any, Misc.PositionSide}","page":"Executors","title":"Executors.orders","text":"Returns a generator for orders matching a given position side\n\norders(\n    s::Strategies.Strategy,\n    ai,\n    pos::Misc.PositionSide\n) -> Base.Iterators.Flatten{I} where I<:(Base.Generator{Tuple{DataType, DataType}, F} where F<:(Executors.var\"#92#93\"{Strategies.Strategy{X, N, E, M, C}, _A, <:Misc.PositionSide} where {X<:Misc.ExecMode, N, E<:ExchangeID, M<:Misc.MarginMode, C, _A}))\n\n\nThis function iterates over the orders of a strategy for both Buy and Sell sides, returning those that match the provided position side.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy, Instances.AssetInstance, Val{:orderless}}","page":"Executors","title":"Executors.orders","text":"Iterates over all the orderless orders for an asset instance in a strategy.\n\norders(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance,\n    _::Val{:orderless}\n) -> Base.Iterators.Flatten{I} where I<:(Base.Generator{Tuple{DataType, DataType}, F} where F<:(Executors.var\"#50#51\"{Strategies.Strategy{X, N, E, M, C}, Instances.AssetInstance{T, E1, M1}} where {X<:Misc.ExecMode, N, E<:ExchangeID, M<:Misc.MarginMode, C, T<:AbstractAsset, E1<:ExchangeID, M1<:Misc.MarginMode}))\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy, Instances.AssetInstance}","page":"Executors","title":"Executors.orders","text":"Iterates over all the orders for an asset instance in a strategy.\n\norders(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance\n) -> Union{Executors.OrderIterator, SortedDict{@NamedTuple{price::Float64, time::Dates.DateTime}}}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy, Union{Type{OrderTypes.Buy}, OrderTypes.Buy, Type{<:OrderTypes.AnyBuyOrder{P, A, E, var\"#s253\"} where {var\"#s253\"<:OrderTypes.OrderType{OrderTypes.Buy}, A<:AbstractAsset, E<:ExchangeID, P<:Misc.PositionSide}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.Buy}}, OrderTypes.AnyBuyOrder{P, A, E} where {P<:Misc.PositionSide, A<:AbstractAsset, E<:ExchangeID}}}","page":"Executors","title":"Executors.orders","text":"Returns all buy orders for a strategy.\n\norders(\n    s::Strategies.Strategy,\n    _::Union{Type{OrderTypes.Buy}, OrderTypes.Buy, Type{<:OrderTypes.AnyBuyOrder{P, A, E, var\"#s253\"} where {var\"#s253\"<:OrderTypes.OrderType{OrderTypes.Buy}, A<:AbstractAsset, E<:ExchangeID, P<:Misc.PositionSide}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.Buy}}, OrderTypes.AnyBuyOrder{P, A, E} where {P<:Misc.PositionSide, A<:AbstractAsset, E<:ExchangeID}}\n) -> Executors.OrderIterator\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy, Union{Type{OrderTypes.Sell}, OrderTypes.Sell, Type{<:OrderTypes.AnySellOrder{P, A, E, var\"#s253\"} where {var\"#s253\"<:OrderTypes.OrderType{OrderTypes.Sell}, A<:AbstractAsset, E<:ExchangeID, P<:Misc.PositionSide}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.Sell}}, OrderTypes.AnySellOrder{P, A, E} where {P<:Misc.PositionSide, A<:AbstractAsset, E<:ExchangeID}}}","page":"Executors","title":"Executors.orders","text":"Returns all sell orders for a strategy.\n\norders(\n    s::Strategies.Strategy,\n    _::Union{Type{OrderTypes.Sell}, OrderTypes.Sell, Type{<:OrderTypes.AnySellOrder{P, A, E, var\"#s253\"} where {var\"#s253\"<:OrderTypes.OrderType{OrderTypes.Sell}, A<:AbstractAsset, E<:ExchangeID, P<:Misc.PositionSide}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.Sell}}, OrderTypes.AnySellOrder{P, A, E} where {P<:Misc.PositionSide, A<:AbstractAsset, E<:ExchangeID}}\n) -> Executors.OrderIterator\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy, Val{:orderless}, Val{:universe}}","page":"Executors","title":"Executors.orders","text":"Iterates orderlessly over all the orders in a strategy (all the assets in the universe).\n\norders(\n    s::Strategies.Strategy,\n    _::Val{:orderless},\n    _::Val{:universe}\n) -> Executors.OrderIterator\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy, Val{:orderless}}","page":"Executors","title":"Executors.orders","text":"Iterates over all the orderless orders in a strategy.\n\norders(\n    s::Strategies.Strategy,\n    _::Val{:orderless}\n) -> Base.Iterators.Flatten{I} where I<:(Base.Generator{Tuple{DataType, DataType}, F} where F<:(Executors.var\"#37#38\"{Strategies.Strategy{X, N, E, M, C}} where {X<:Misc.ExecMode, N, E<:ExchangeID, M<:Misc.MarginMode, C}))\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy, Val{:universe}}","page":"Executors","title":"Executors.orders","text":"Iterates over all the orders in a strategy (all the assets in the universe).\n\norders(\n    s::Strategies.Strategy,\n    _::Val{:universe}\n) -> Executors.OrderIterator\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Tuple{Strategies.Strategy}","page":"Executors","title":"Executors.orders","text":"Iterates over all the orders in a strategy.\n\norders(s::Strategies.Strategy) -> Executors.OrderIterator\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Union{Tuple{E}, Tuple{S}, Tuple{M}, Tuple{Strategies.Strategy{M, S, E}, Any, Union{Type{OrderTypes.Buy}, OrderTypes.Buy, Type{<:OrderTypes.AnyBuyOrder{P, A, E, var\"#s253\"} where {var\"#s253\"<:OrderTypes.OrderType{OrderTypes.Buy}, A<:AbstractAsset, E<:ExchangeID, P<:Misc.PositionSide}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.Buy}}, OrderTypes.AnyBuyOrder{P, A, E} where {P<:Misc.PositionSide, A<:AbstractAsset, E<:ExchangeID}}}} where {M, S, E}","page":"Executors","title":"Executors.orders","text":"Returns all buy orders for an asset in a strategy.\n\norders(\n    s::Strategies.Strategy{M, S, E},\n    ai,\n    _::Union{Type{OrderTypes.Buy}, OrderTypes.Buy, Type{<:OrderTypes.AnyBuyOrder{P, A, E, var\"#s253\"} where {var\"#s253\"<:OrderTypes.OrderType{OrderTypes.Buy}, A<:AbstractAsset, E<:ExchangeID, P<:Misc.PositionSide}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.Buy}}, OrderTypes.AnyBuyOrder{P, A, E} where {P<:Misc.PositionSide, A<:AbstractAsset, E<:ExchangeID}}\n) -> SortedDict{@NamedTuple{price::Float64, time::Dates.DateTime}, D, Strategies.BuyPriceTimeOrdering} where D<:(OrderTypes.AnyBuyOrder{P, T, _A} where {_A, P<:Misc.PositionSide, T<:AbstractAsset})\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orders-Union{Tuple{E}, Tuple{S}, Tuple{M}, Tuple{Strategies.Strategy{M, S, E}, Any, Union{Type{OrderTypes.Sell}, OrderTypes.Sell, Type{<:OrderTypes.AnySellOrder{P, A, E, var\"#s253\"} where {var\"#s253\"<:OrderTypes.OrderType{OrderTypes.Sell}, A<:AbstractAsset, E<:ExchangeID, P<:Misc.PositionSide}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.Sell}}, OrderTypes.AnySellOrder{P, A, E} where {P<:Misc.PositionSide, A<:AbstractAsset, E<:ExchangeID}}}} where {M, S, E}","page":"Executors","title":"Executors.orders","text":"Returns all sell orders for an asset in a strategy.\n\norders(\n    s::Strategies.Strategy{M, S, E},\n    ai,\n    _::Union{Type{OrderTypes.Sell}, OrderTypes.Sell, Type{<:OrderTypes.AnySellOrder{P, A, E, var\"#s253\"} where {var\"#s253\"<:OrderTypes.OrderType{OrderTypes.Sell}, A<:AbstractAsset, E<:ExchangeID, P<:Misc.PositionSide}}, OrderTypes.Trade{<:OrderTypes.OrderType{OrderTypes.Sell}}, OrderTypes.AnySellOrder{P, A, E} where {P<:Misc.PositionSide, A<:AbstractAsset, E<:ExchangeID}}\n) -> SortedDict{@NamedTuple{price::Float64, time::Dates.DateTime}, D, Strategies.SellPriceTimeOrdering} where D<:(OrderTypes.AnySellOrder{P, T, _A} where {_A, P<:Misc.PositionSide, T<:AbstractAsset})\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orderscount-Tuple{Strategies.Strategy, Instances.AssetInstance, Type{OrderTypes.BuyOrSell}}","page":"Executors","title":"Executors.orderscount","text":"Returns the count of orders for an asset in a strategy.\n\norderscount(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance,\n    _::Type{OrderTypes.BuyOrSell}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orderscount-Tuple{Strategies.Strategy, Instances.AssetInstance, Type{OrderTypes.Buy}}","page":"Executors","title":"Executors.orderscount","text":"Returns the count of buy orders for an asset in a strategy.\n\norderscount(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance,\n    _::Type{OrderTypes.Buy}\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orderscount-Tuple{Strategies.Strategy, Instances.AssetInstance, Type{OrderTypes.Sell}}","page":"Executors","title":"Executors.orderscount","text":"Returns the count of sell orders for an asset in a strategy.\n\norderscount(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance,\n    _::Type{OrderTypes.Sell}\n) -> Int64\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orderscount-Tuple{Strategies.Strategy, Instances.AssetInstance}","page":"Executors","title":"Executors.orderscount","text":"Returns the count of orders for an asset in a strategy.\n\norderscount(\n    s::Strategies.Strategy,\n    ai::Instances.AssetInstance\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orderscount-Tuple{Strategies.Strategy, Val{:increase}}","page":"Executors","title":"Executors.orderscount","text":"Returns the count of pending entry orders in a strategy.\n\norderscount(\n    s::Strategies.Strategy,\n    _::Val{:increase}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orderscount-Tuple{Strategies.Strategy, Val{:reduce}}","page":"Executors","title":"Executors.orderscount","text":"Returns the count of pending exit orders in a strategy.\n\norderscount(s::Strategies.Strategy, _::Val{:reduce}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orderscount-Tuple{Strategies.Strategy}","page":"Executors","title":"Executors.orderscount","text":"Returns the total count of pending orders in a strategy.\n\norderscount(s::Strategies.Strategy) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.orderscount-Union{Tuple{O}, Tuple{Strategies.Strategy, Union{Type{O}, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{O}}}, OrderTypes.Order{<:OrderTypes.OrderType{O}}, OrderTypes.Trade{<:OrderTypes.OrderType{O}}, O}}} where O","page":"Executors","title":"Executors.orderscount","text":"Returns the count of orders in a strategy.\n\norderscount(\n    s::Strategies.Strategy,\n    _::Union{Type{O}, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{O}}}, OrderTypes.Order{<:OrderTypes.OrderType{O}}, OrderTypes.Trade{<:OrderTypes.OrderType{O}}, O}\n) -> Tuple{Any, Any}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.position!-Tuple{Strategies.IsolatedStrategy, Any, Dates.DateTime, Misc.PositionSide}","page":"Executors","title":"Executors.position!","text":"Updates the position of the isolated strategy to the given position side at the specified date\n\nposition!(\n    s::Strategies.IsolatedStrategy,\n    ai,\n    date::Dates.DateTime,\n    p::Misc.PositionSide\n)\n\n\nThis function updates the position of the strategy for the asset in question at the given date to the provided position side.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.position!-Tuple{Strategies.Strategy{X, N, <:ExchangeID, NoMargin, C} where {X<:Misc.ExecMode, N, C}, Vararg{Any}}","page":"Executors","title":"Executors.position!","text":"Non margin strategies don't have positions.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.priceat-Tuple{Strategies.Strategy, Type{<:OrderTypes.Order}, Any, Any}","page":"Executors","title":"Executors.priceat","text":"The price for an order at a particular date.\n\npriceat(\n    _::Strategies.Strategy,\n    _::Type{<:OrderTypes.Order},\n    ai,\n    date\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.queue!-Union{Tuple{S}, Tuple{Strategies.Strategy, OrderTypes.Order{<:OrderTypes.LimitOrderType{S}}, Any}} where S<:OrderTypes.OrderSide","page":"Executors","title":"Executors.queue!","text":"Adds a limit order to the pending orders of the strategy.\n\nqueue!(\n    s::Strategies.Strategy,\n    o::OrderTypes.Order{<:OrderTypes.LimitOrderType{S<:OrderTypes.OrderSide}},\n    ai;\n    skipcommit\n) -> Bool\n\n\nThis function takes a strategy, a limit order of type LimitOrderType{S}, and an asset instance as arguments. It adds the limit order to the pending orders of the strategy. If skipcommit is set to false (default), the order is committed and held. Returns true if the order was successfully added, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.release!-Tuple{Strategies.Strategy, Any}","page":"Executors","title":"Executors.release!","text":"An asset is released when there are no orders for it and its balance is zero.\n\nrelease!(\n    s::Strategies.Strategy,\n    ai\n) -> Union{Nothing, Set{Instances.AssetInstance{T, E} where T<:AbstractAsset} where E<:ExchangeID}\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.sellorders-Tuple{Strategies.Strategy, Any}","page":"Executors","title":"Executors.sellorders","text":"Returns sell orders for an asset in a strategy.\n\nsellorders(\n    s::Strategies.Strategy,\n    ai\n) -> SortedDict{@NamedTuple{price::Float64, time::Dates.DateTime}, D, Strategies.SellPriceTimeOrdering} where D<:(OrderTypes.AnySellOrder{P, T, E} where {E<:ExchangeID, P<:Misc.PositionSide, T<:AbstractAsset})\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.shortorders-Tuple{Strategies.Strategy, Any, Type{<:OrderTypes.OrderSide}}","page":"Executors","title":"Executors.shortorders","text":"Returns a generator for short orders matching a given order side\n\nshortorders(\n    s::Strategies.Strategy,\n    ai,\n    os::Type{<:OrderTypes.OrderSide}\n) -> Base.Generator{I, typeof(identity)} where I<:(Base.Iterators.Filter{Executors.var\"#90#91\"{Misc.Short}})\n\n\nThis function utilizes the orders function to generate orders for the Short position side that match the provided order side.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.sideorders-Tuple{Strategies.Strategy, Any, Type{OrderTypes.Buy}}","page":"Executors","title":"Executors.sideorders","text":"Returns orders for an asset in a strategy by side.\n\nsideorders(\n    s::Strategies.Strategy,\n    ai,\n    _::Type{OrderTypes.Buy}\n) -> SortedDict{@NamedTuple{price::Float64, time::Dates.DateTime}, D, Strategies.BuyPriceTimeOrdering} where D<:(OrderTypes.AnyBuyOrder{P, T, E} where {E<:ExchangeID, P<:Misc.PositionSide, T<:AbstractAsset})\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.sideorders-Tuple{Strategies.Strategy, Any, Type{OrderTypes.Sell}}","page":"Executors","title":"Executors.sideorders","text":"Returns orders for an asset in a strategy by side.\n\nsideorders(\n    s::Strategies.Strategy,\n    ai,\n    _::Type{OrderTypes.Sell}\n) -> SortedDict{@NamedTuple{price::Float64, time::Dates.DateTime}, D, Strategies.SellPriceTimeOrdering} where D<:(OrderTypes.AnySellOrder{P, T, E} where {E<:ExchangeID, P<:Misc.PositionSide, T<:AbstractAsset})\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.sideorders-Union{Tuple{S}, Tuple{Strategies.Strategy, Any, Union{Type{S}, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{S}}}, OrderTypes.Order{<:OrderTypes.OrderType{S}}, OrderTypes.Trade{<:OrderTypes.OrderType{S}}, S}}} where S","page":"Executors","title":"Executors.sideorders","text":"Returns orders for an asset in a strategy by side.\n\nsideorders(\n    s::Strategies.Strategy,\n    ai,\n    _::Union{Type{S}, Type{<:OrderTypes.Order{<:OrderTypes.OrderType{S}}}, OrderTypes.Order{<:OrderTypes.OrderType{S}}, OrderTypes.Trade{<:OrderTypes.OrderType{S}}, S}\n) -> SortedDict{@NamedTuple{price::Float64, time::Dates.DateTime}, D, Strategies.SellPriceTimeOrdering} where D<:(OrderTypes.AnySellOrder{P, T, E} where {E<:ExchangeID, P<:Misc.PositionSide, T<:AbstractAsset})\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.strategycash!-Tuple{Strategies.IsolatedStrategy, Any, OrderTypes.IncreaseTrade}","page":"Executors","title":"Executors.strategycash!","text":"Updates the strategy's cash after an increase trade.\n\nstrategycash!(\n    s::Strategies.IsolatedStrategy,\n    ai,\n    t::OrderTypes.IncreaseTrade\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.strategycash!-Tuple{Strategies.IsolatedStrategy, Any, OrderTypes.ReduceTrade}","page":"Executors","title":"Executors.strategycash!","text":"Updates the strategy's cash after a reduce trade.\n\nstrategycash!(\n    s::Strategies.IsolatedStrategy,\n    ai,\n    t::OrderTypes.ReduceTrade\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.strategycash!-Tuple{Strategies.Strategy{X, N, <:ExchangeID, NoMargin, C} where {X<:Misc.ExecMode, N, C}, Any, OrderTypes.BuyTrade}","page":"Executors","title":"Executors.strategycash!","text":"Updates the strategy's cash after a buy trade.\n\nstrategycash!(\n    s::Strategies.Strategy{X, N, <:ExchangeID, NoMargin, C} where {X<:Misc.ExecMode, N, C},\n    ai,\n    t::OrderTypes.BuyTrade\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.strategycash!-Tuple{Strategies.Strategy{X, N, <:ExchangeID, NoMargin, C} where {X<:Misc.ExecMode, N, C}, Any, OrderTypes.SellTrade}","page":"Executors","title":"Executors.strategycash!","text":"Updates the strategy's cash after a sell trade.\n\nstrategycash!(\n    s::Strategies.Strategy{X, N, <:ExchangeID, NoMargin, C} where {X<:Misc.ExecMode, N, C},\n    _,\n    t::OrderTypes.SellTrade\n)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.unfilled-Tuple{OrderTypes.Order}","page":"Executors","title":"Executors.unfilled","text":"Returns the absolute value of the unfilled amount of an order.\n\nunfilled(o::OrderTypes.Order) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.unfillment-Tuple{OrderTypes.Order}","page":"Executors","title":"Executors.unfillment","text":"Calculates the unfulfilled amount for an order.\n\nunfillment(o::OrderTypes.Order) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.unfillment-Tuple{Type{<:OrderTypes.AnyBuyOrder}, Any}","page":"Executors","title":"Executors.unfillment","text":"Calculates the unfulfilled amount for a buy order.\n\nunfillment(t::Type{<:OrderTypes.AnyBuyOrder}, amount) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.unfillment-Tuple{Type{<:OrderTypes.AnySellOrder}, Any}","page":"Executors","title":"Executors.unfillment","text":"Calculates the unfulfilled amount for a sell order.\n\nunfillment(\n    t::Type{<:OrderTypes.AnySellOrder},\n    amount\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.update_leverage!-Union{Tuple{Instances.Position{P}}, Tuple{P}} where P","page":"Executors","title":"Executors.update_leverage!","text":"Updates leverage based on position state.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.update_maintenance!-Tuple{Instances.Position}","page":"Executors","title":"Executors.update_maintenance!","text":"Updates leverage based on position state.\n\nupdate_maintenance!(po::Instances.Position; ntl, mmr) -> Any\n\n\nThis function updates the leverage of a position based on its current state, using the provided leverage, price, and maintenance margin ratio.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.update_notional!-Tuple{Instances.Position}","page":"Executors","title":"Executors.update_notional!","text":"Updates notional value.\n\nupdate_notional!(po::Instances.Position; ntl, size)\n\n\nThis function updates the notional value of a position using the provided notional amount and size.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.update_price!-Tuple{Instances.Position}","page":"Executors","title":"Executors.update_price!","text":"Update the entry price from notional, amount diff and cash.\n\nupdate_price!(po::Instances.Position; ntl, prev_ntl, size)\n\n\nThis function calculates the new entry price of a position using the notional amount, the difference in amount, and the cash in the position.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.withtrade!-Union{Tuple{P}, Tuple{Instances.Position{P}, OrderTypes.Trade{O, A, E, P} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID}}} where P","page":"Executors","title":"Executors.withtrade!","text":"Update position price, notional and leverage from a new trade.\n\nwithtrade!(\n    po::Instances.Position{P},\n    t::OrderTypes.Trade{O, A, E, P} where {O<:OrderTypes.OrderType, A<:AbstractAsset, E<:ExchangeID};\n    settle_price\n) -> Any\n\n\nThis function adjusts the price, notional value, and leverage of a position based on a new trade at the given settlement price.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Instances.committed-Tuple{OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, var\"#s253\", var\"#s252\", Misc.Short} where {var\"#s253\"<:AbstractAsset, var\"#s252\"<:ExchangeID}}","page":"Executors","title":"Instances.committed","text":"Returns the committed amount of a short buy order.\n\ncommitted(\n    o::OrderTypes.Order{<:OrderTypes.OrderType{OrderTypes.Buy}, var\"#s253\", var\"#s252\", Misc.Short} where {var\"#s253\"<:AbstractAsset, var\"#s252\"<:ExchangeID}\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Instances.committed-Tuple{OrderTypes.Order}","page":"Executors","title":"Instances.committed","text":"Returns the committed amount of an order.\n\ncommitted(o::OrderTypes.Order) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Instances.committed-Union{Tuple{P}, Tuple{Strategies.Strategy{X, N, <:ExchangeID, <:Misc.WithMargin, C} where {X<:Misc.ExecMode, N, C}, Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin, Union{Type{P}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, P}}} where P","page":"Executors","title":"Instances.committed","text":"Calculates the committed amount for a given position\n\ncommitted(\n    s::Strategies.Strategy{X, N, <:ExchangeID, <:Misc.WithMargin, C} where {X<:Misc.ExecMode, N, C},\n    ai::Instances.AssetInstance{<:AbstractAsset, <:ExchangeID, M} where M<:Misc.WithMargin,\n    _::Union{Type{P}, Type{O} where O<:(OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), Type{T} where T<:(OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}), OrderTypes.Order{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, OrderTypes.Trade{<:OrderTypes.OrderType, <:AbstractAsset, <:ExchangeID, P}, P}\n) -> Any\n\n\nThis function sums the amounts of all the orders that match the given position in the Margin Strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Instances.isdust-Tuple{Instances.AssetInstance, OrderTypes.Order}","page":"Executors","title":"Instances.isdust","text":"Checks if the order committed value is below minimum quantity.\n\nisdust(\n    ai::Instances.AssetInstance,\n    o::OrderTypes.Order\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Instances.liqprice-Tuple{Misc.PositionSide, Any, Any, Any}","page":"Executors","title":"Instances.liqprice","text":"Calculates the liquidation price of a position\n\nliqprice(\n    p::Misc.PositionSide,\n    entryprice,\n    leverage,\n    mmr;\n    additional,\n    notional\n) -> Any\n\n\nThis function calculates the price at which a position would be liquidated, given the entry price, leverage, maintenance margin ratio, additional margin, and notional value.\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Instruments.cash!-Tuple{Strategies.Strategy, Any, OrderTypes.Trade}","page":"Executors","title":"Instruments.cash!","text":"Updates the strategy's and asset instance's cash after a trade.\n\ncash!(s::Strategies.Strategy, ai, t::OrderTypes.Trade)\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Misc.attr-Tuple{OrderTypes.Order, Any}","page":"Executors","title":"Misc.attr","text":"Returns the attribute of an order.\n\nattr(o::OrderTypes.Order, sym) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Misc.reset!-Tuple{OrderTypes.Order, Any}","page":"Executors","title":"Misc.reset!","text":"Resets an order committment and unfilled amount.\n\nreset!(o::OrderTypes.Order, ai) -> Float64\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#OrderTypes.commit!-Tuple{Strategies.Strategy, OrderTypes.IncreaseOrder, Any}","page":"Executors","title":"OrderTypes.commit!","text":"Commits an increase order to a strategy.\n\ncommit!(\n    s::Strategies.Strategy,\n    o::OrderTypes.IncreaseOrder,\n    _\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#OrderTypes.commit!-Tuple{Strategies.Strategy, OrderTypes.ReduceOrder, Any}","page":"Executors","title":"OrderTypes.commit!","text":"Commits a reduce order to an asset instance.\n\ncommit!(\n    _::Strategies.Strategy,\n    o::OrderTypes.ReduceOrder,\n    ai\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#OrderTypes.trades-Tuple{OrderTypes.Order}","page":"Executors","title":"OrderTypes.trades","text":"Returns the trades of an order.\n\ntrades(o::OrderTypes.Order) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/executors/#Executors.@amount!-Tuple{Any, Vararg{Any}}","page":"Executors","title":"Executors.@amount!","text":"Ensures the amount is within correct boundaries.\n\n\n\n\n\n","category":"macro"},{"location":"API/executors/#Executors.@price!-Tuple{Any, Vararg{Any}}","page":"Executors","title":"Executors.@price!","text":"Ensures the price is within correct boundaries.\n\n\n\n\n\n","category":"macro"},{"location":"API/python/#Python","page":"Python","title":"Python","text":"","category":"section"},{"location":"API/python/","page":"Python","title":"Python","text":"Provides python bindings, some helper functions and async management.","category":"page"},{"location":"API/python/","page":"Python","title":"Python","text":"Modules = [Python]","category":"page"},{"location":"API/python/#Python.Python","page":"Python","title":"Python.Python","text":"Defines the Python module which sets up the Python interpreter and imports required modules and constants.\n\n\n\n\n\n","category":"module"},{"location":"API/python/#Python.CALLBACKS","page":"Python","title":"Python.CALLBACKS","text":"An array of callback functions.\n\n\n\n\n\n","category":"constant"},{"location":"API/python/#Python.PYMODPATHS","page":"Python","title":"Python.PYMODPATHS","text":"An array of Python module paths.\n\n\n\n\n\n","category":"constant"},{"location":"API/python/#Python.PYTHONPATH","page":"Python","title":"Python.PYTHONPATH","text":"The Python module search path.\n\n\n\n\n\n","category":"constant"},{"location":"API/python/#Python.PY_V","page":"Python","title":"Python.PY_V","text":"The Python version.\n\n\n\n\n\n","category":"constant"},{"location":"API/python/#Python._INITIALIZED","page":"Python","title":"Python._INITIALIZED","text":"This constant indicates whether the Python runtime has been initialized. It is used to delay initialization until the first Python call.\n\n\n\n\n\n","category":"constant"},{"location":"API/python/#Python.pyCached","page":"Python","title":"Python.pyCached","text":"A dictionary for caching Python objects.\n\n\n\n\n\n","category":"constant"},{"location":"API/python/#Python.pyisvalue_func","page":"Python","title":"Python.pyisvalue_func","text":"A Python object used for checking if a value is a Python object.\n\n\n\n\n\n","category":"constant"},{"location":"API/python/#Python.pytryfloat","page":"Python","title":"Python.pytryfloat","text":"A Python object used for converting values to float.\n\n\n\n\n\n","category":"constant"},{"location":"API/python/#Python.PythonAsync","page":"Python","title":"Python.PythonAsync","text":"A structure for handling Python's asynchronous operations.\n\npyaio\npythreads\npyloop\npycoro_type\nglobs\nstart_func\ntask\ntask_running\n\nThis structure is used to manage Python's asynchronous operations. It contains fields for Python's asyncio, threads, event loop, coroutine type, global variables, start function, and task status.\n\n\n\n\n\n","category":"type"},{"location":"API/python/#PythonCall.Wrap.PyDict-Tuple{Pair}","page":"Python","title":"PythonCall.Wrap.PyDict","text":"PyDict(p::Pair)\n\nCreate a Python dictionary from a pair.\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Base.copyto!-Tuple{Python.PythonAsync, Python.PythonAsync}","page":"Python","title":"Base.copyto!","text":"Copies a python async structures.\n\ncopyto!(\n    pa_to::Python.PythonAsync,\n    pa_from::Python.PythonAsync\n) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.__pyfetch-Tuple{Py, Val{:try}, Vararg{Any}}","page":"Python","title":"Python.__pyfetch","text":"Fetches the result of a Python function call synchronously and returns an exception if any.\n\n__pyfetch(f::Py, ::Val{:try}, args...; kwargs...) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.__pyfetch-Tuple{Py, Vararg{Any}}","page":"Python","title":"Python.__pyfetch","text":"Fetches the result of a Python function call synchronously.\n\n__pyfetch(f::Py, args...; kwargs...) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python._async_init-Tuple{Python.PythonAsync}","page":"Python","title":"Python._async_init","text":"Initialized a PythonAsync structure (which holds a reference to the event loop.)\n\n_async_init(pa::Python.PythonAsync)\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python._isfutdone-Tuple{Py}","page":"Python","title":"Python._isfutdone","text":"Checks if a Python future is done.\n\n_isfutdone(fut::Py) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python._pyfetch-Tuple{Function, Vararg{Any}}","page":"Python","title":"Python._pyfetch","text":"Fetches the result of a Julia function call synchronously.\n\n_pyfetch(f::Function, args...; kwargs...) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python._pyfetch_timeout-Tuple{Py, Union{Function, Py}, Dates.Period, Vararg{Any}}","page":"Python","title":"Python._pyfetch_timeout","text":"Fetches the result of a Python function call synchronously with a timeout. If the timeout is reached, it calls another function and returns its result.\n\n_pyfetch_timeout(\n    f1::Py,\n    f2::Union{Function, Py},\n    timeout::Dates.Period,\n    args...;\n    kwargs...\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.async_start_runner_func!-Tuple{Any}","page":"Python","title":"Python.async_start_runner_func!","text":"Main async loop function, sleeps indefinitely and closes loop on exception.\n\nasync_start_runner_func!(pa) -> Py\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.clearpypath!-Tuple{}","page":"Python","title":"Python.clearpypath!","text":"Remove wrong python version libraries dirs from python loading path.\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.isdict-Tuple{Any}","page":"Python","title":"Python.isdict","text":"Test whether a Python object is a dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.isinitialized_async-Tuple{Python.PythonAsync}","page":"Python","title":"Python.isinitialized_async","text":"Checks if python async state (event loop) is initialized.\n\nisinitialized_async(pa::Python.PythonAsync) -> Bool\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.islist-Tuple{Any}","page":"Python","title":"Python.islist","text":"Test whether a Python object is a list.\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.py_except_name-Tuple{PyException}","page":"Python","title":"Python.py_except_name","text":"py_except_name(e::PyException)\n\nGet the name of a Python exception.\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.py_start_loop","page":"Python","title":"Python.py_start_loop","text":"Starts a python event loop, updating pa.\n\npy_start_loop()\npy_start_loop(pa::Python.PythonAsync)\n\n\n\n\n\n\n","category":"function"},{"location":"API/python/#Python.pycancel","page":"Python","title":"Python.pycancel","text":"Cancels a Python future.\n\npycancel(fut::Py) -> Bool\npycancel(fut::Py, ::Bool) -> Bool\n\n\n\n\n\n\n","category":"function"},{"location":"API/python/#Python.pydicthash-Tuple{Any}","page":"Python","title":"Python.pydicthash","text":"pydicthash(d)\n\nCalculate the hash of a Python dictionary.\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.pyisnonzero-Tuple{Py}","page":"Python","title":"Python.pyisnonzero","text":"pyisnonzero(v::Py)::Bool\n\nCheck if a Python value is nonzero.\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.pylist_to_matrix-Tuple{Py}","page":"Python","title":"Python.pylist_to_matrix","text":"pylist_to_matrix(data::Py)\n\nConvert a Python list to a Julia matrix.\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.pyloop_stop_fn-Tuple{}","page":"Python","title":"Python.pyloop_stop_fn","text":"Generates a function that terminates the python even loop.\n\npyloop_stop_fn() -> Python.var\"#fn#11\"\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.pyschedule-Tuple{Py}","page":"Python","title":"Python.pyschedule","text":"Schedules a Python coroutine to run on the event loop.\n\npyschedule(coro::Py) -> Py\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.pytask-Tuple{Py, Vararg{Any}}","page":"Python","title":"Python.pytask","text":"Creates a Julia task from a Python function call and runs it asynchronously.\n\npytask(f::Py, args...; kwargs...) -> Task\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.pytask-Tuple{Py}","page":"Python","title":"Python.pytask","text":"Creates a Julia task from a Python coroutine and returns the Python future and the Julia task.\n\npytask(coro::Py) -> Task\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.pytofloat-Union{Tuple{T}, Tuple{Py, T}} where T<:Number","page":"Python","title":"Python.pytofloat","text":"pytofloat(v::Py, def::T)::T where {T<:Number}\n\nConvert a Python value to a Julia float, with a default value.\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.pywait_fut-Tuple{Py}","page":"Python","title":"Python.pywait_fut","text":"Waits for a Python future to be done.\n\npywait_fut(fut::Py) -> Union{Nothing, Py}\n\n\n\n\n\n\n","category":"method"},{"location":"API/python/#Python.@pymodule","page":"Python","title":"Python.@pymodule","text":"Import a python module over a variable defined in global scope.\n\n\n\n\n\n","category":"macro"},{"location":"API/python/#Python.@pystr","page":"Python","title":"Python.@pystr","text":"@pystr(k, v=nothing)\n\nConvert a Julia value to a Python string representation.\n\n\n\n\n\n","category":"macro"},{"location":"disambiguation/","page":"Disambiguation (Glossary)","title":"Disambiguation (Glossary)","text":"asset: An asset refers to a structure created from parsing a symbol. It typically represents an Asset, Derivative, or AssetInstance. Variables representing asset instances are often named ai, while simple assets are named a or aa (for AbstractAsset).\nsym: Though Symbol is a built-in type in Julia, in a trading context \"symbol\" often denotes the pairing of a base currency with a quote currency. There is no strict rule for the usage of sym, but it commonly refers to a Symbol for single currencies and a String for currency pairs.\npair: A pair is usually a String in the format \"$BASE/$QUOTE\" where the slash separates the base and the quote currencies.\nbc, qc: These abbreviations stand for base currency (bc) and quote currency (qc). They are Symbol types and correspond to the fields of an AbstractAsset.\nfutures/swap/perps: While swaps are a type of futures contract, they are specifically \"perpetual futures\" and are thus referred to distinctly. Following the CCXT library's conventions, swaps have symbols formatted as \"$BASE/$QUOTE:$SETTLE\". Plain future contracts include an expiry date, denoted as \"$BASE/$QUOTE:$SETTLE-$EXPIRY\".\namount: The term \"amount\" generally refers to the quantity of the base currency. For example, if you purchase 100 USD worth of BTC at a price of 1000 USD per BTC, the amount is 100 / 1000 = 0.1 BTC.\nprice: The price always refers to the cost of the base currency quoted in the quote currency. For instance, if the price of BTC is 1000 USD, it means 1 BTC = 1000 USD.\nsize: Size typically indicates the quantity of quote currency used to execute a trade, inclusive of fees.\nlong/short: These terms are exclusively used in the context of margin trading. \"Long\" indicates a position betting on an increase in an asset's price, while \"short\" refers to a position betting on a decrease.\nohlc/v: This abbreviation stands for Open, High, Low, Close, and Volume, and it usually refers to a dataframe containing this market data.\npairdata: This term describes a complex data structure that associates a dataframe, a Zarr array, and a trading pair.\nexc/exchange: This can refer to an Exchange instance, an ExchangeID, or merely the Symbol of an exchange ID. For convenience, a global exc variable is defined in the ExchangeTypes module for use in the REPL.\nsandbox: Many exchanges offer a \"testnet\" to trial API endpoints. Note that this is distinct from paper trading and should not be confused with it.\ninstance: This term typically implies an AssetInstance.\ncandle: A candle can be a row from an OHLCV dataframe, a named tuple, or an actual Candle structure.\nresample: Resampling usually implies downsampling, as upsampling is seldom beneficial.\nside/position: The word \"side\" refers to either a \"buy\" or \"sell\" action. In contrast, when discussing the \"side of a position,\" such as \"long\" or \"short,\" the term \"position\" is used instead. Thus, a trade's side is either \"buy\" or \"sell,\" while its position is \"long\" or \"short.\"","category":"page"},{"location":"engine/paper/#Running-in-Paper-Mode","page":"Paper","title":"Running in Paper Mode","text":"","category":"section"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"In order to configure a strategy in paper mode, you can define the default mode in user/pingpong.toml or in your strategy project's Project.toml file. Alternatively, pass the mode as a keyword argument:","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"[Example]\nmode = \"Paper\"","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"using Strategies\ns = strategy(:Example, mode=Paper())","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"To start the strategy, use the following command:","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"using PaperMode\nstart!(s)","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"Upon executing this, the following log output is expected:","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"┌ Info: Starting strategy ExampleMargin in paper mode!\n│\n│     throttle: 5 seconds\n│     timeframes: 1m(main), 1m(optional), 1m 15m 1h 1d(extras)\n│     cash: USDT: 100.0 (on phemex) [100.0]\n│     assets: ETH/USDT:USDT, BTC/USDT:USDT, SOL/USDT:USDT\n│     margin: Isolated()\n└\n[ Info: 2023-07-07T04:49:51.051(ExampleMargin@phemex) 0.0/100.0[100.0](USDT), orders: 0/0(+/-) trades: 0/0/0(L/S/Q)\n[ Info: 2023-07-07T04:49:56.057(ExampleMargin@phemex) 0.0/100.0[100.0](USDT), orders: 0/0(+/-) trades: 0/0/0(L/S/Q)","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"To run the strategy as a background task:","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"start!(s, foreground=false)","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"The logs will be written either to the s[:logfile] key of the strategy object, if present, or to the output of the runlog(s) command.","category":"page"},{"location":"engine/paper/#Understanding-Paper-Mode","page":"Paper","title":"Understanding Paper Mode","text":"","category":"section"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"When you initiate paper mode, asset prices are monitored in real-time from the exchange. Order execution in Paper Mode is similar to SimMode, albeit the actual price, the trade amount, and the order execution sequence are guided by real-time exchange data.","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"In detail:","category":"page"},{"location":"engine/paper/","page":"Paper","title":"Paper","text":"Market Orders are executed by surveying the order book and sweeping available bids/asks. Consequently, the final price and amount reflect the average of all the entries available on the order book.\nLimit Orders sweep the order book as well, though only for bids/asks that are below the limit price set for the order. If a Good-Till-Canceled (GTC) order is not entirely filled, a task is generated that continuously monitors the exchange's trade history. Trades that align with the order's limit price are used to fulfill the remainder of the limit order amount.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The Plotting module utilizes Makie for creating visualizations. It is important to note that graphical backends are not automatically included with the module and must be installed manually:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"] add GLMakie\nusing GLMakie\n# Alternatively:\n] add WGLMakie\nusing WGLMakie","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"PingPong enhances Makie with specialized plotting recipes for financial analysis:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"OHLCV (Open-High-Low-Close Volume) charts\nDetailed trade history visualization\nSummarized trade history with volume and balance insights.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"info: Interactive Features\nInteractive backends, such as GLMakie and WGLMakie, allow for dynamic plots that can be clicked-and-dragged or zoomed. Additionally, interactive elements like tooltips are available on hover for candlesticks, trades, and balance charts.","category":"page"},{"location":"plotting/#OHLCV-Charts","page":"Plotting","title":"OHLCV Charts","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"OHLCV data is represented using candlesticks to indicate price movement, with red signifying a price decrease and green an increase. Volume is depicted as bars in the background of the chart. Here's an example:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Plotting\nusing Scrapers.BinanceData\ndf = binanceload(\"eth\").data\nfigure = Plotting.ohlcv(df)\ndisplay(figure)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: OHLCV Plot)","category":"page"},{"location":"plotting/#Trading-History","page":"Plotting","title":"Trading History","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The history of trades is illustrated using triangles, with upwards pointing triangles for buy transactions and downwards for sell transactions.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Lang\nusing Strategies\nusing Engine.Executors.SimMode: SimMode as bt\nstrategy = st.strategy(:Example)\nai = strategy.universe[m\"eth\"].instance\nbt.start!(strategy)\n# Display the first 100 trades for an asset with the symbol \"eth\"\nfigure = Plotting.tradesticks(strategy, m\"eth\", to=100)\ndisplay(figure)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: TradesTicks)","category":"page"},{"location":"plotting/#Aggregated-Trade-History-for-a-Single-Asset","page":"Plotting","title":"Aggregated Trade History for a Single Asset","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The balloons function provides an aggregated view of trade density within a specified timeframe. Each circle's size correlates with the trade volume—larger circles denote higher volume. Positive volume timeframes are labeled as sells and negative ones as buys. Circle opacity reflects the number of trades within the timeframe. The accompanying balance chart indicates the quote currency held: the orange band represents actual cash (Strategy.cash), while the blue band represents the value of held assets in quote currency (AssetInstance.cash * price).","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Aggregate trades within a 1-day timeframe for the \"eth\" asset.\nPlotting.balloons(strategy, m\"eth\", tf=tf\"1d\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Balloons)","category":"page"},{"location":"plotting/#Aggregated-Trade-History-for-Multiple-Assets","page":"Plotting","title":"Aggregated Trade History for Multiple Assets","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"For a comprehensive analysis, aggregated trade history can plot multiple assets. Balloons are overlaid on the price line of each asset, with the same opacity and radius settings as single asset plots. To benchmark against a specific asset, pass a symbol or a dataframe using the benchmark keyword argument.","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Aggregate trades within a 1-week timeframe for all assets in the strategy universe\nPlotting.balloons(strategy, tf=tf\"1w\")","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Balloons Multi)","category":"page"},{"location":"plotting/#Custom-Indicators","page":"Plotting","title":"Custom Indicators","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Custom indicators enhance chart analysis and can be integrated into plots. For example, a moving average can be represented using the line_indicator function:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"analyze!()\nusing Indicators\n# Calculate 7-period and 14-period simple moving averages (SMA)\nsimple_moving_average_7 = Indicators.sma(df.close, n=7)\nsimple_moving_average_14 = Indicators.sma(df.close, n=14)\n# Generate an OHLCV chart and overlay it with the SMA lines\nfigure = Plotting.ohlcv(df)\nfigure = line_indicator!(figure, simple_moving_average_7, simple_moving_average_14)\ndisplay(figure)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Line Indicator)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Channels or envelopes can be visualized using the channel_indicator function. This tool is useful for identifying trends and potential breakouts:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Compute Bollinger Bands\nbb = Indicators.bbands(df.close)\n# Create a channel indicator plot with the Bollinger Bands data\nPlotting.channel_indicator(df, eachcol(bb)...)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: Channel Indicator)","category":"page"},{"location":"API/processing/#Processing","page":"Processing","title":"Processing","text":"","category":"section"},{"location":"API/processing/","page":"Processing","title":"Processing","text":"Modules = [Processing]","category":"page"},{"location":"API/processing/#Processing.Processing","page":"Processing","title":"Processing.Processing","text":"Module for data resampling, cleaning, aligning, etc.\n\n\n\n\n\n","category":"module"},{"location":"API/processing/#Data.propagate_ohlcv!","page":"Processing","title":"Data.propagate_ohlcv!","text":"Updates OHLCV data across multiple time frames.\n\npropagate_ohlcv!(\n    data::SortedDict{TimeFrames.TimeFrame, DataFrames.DataFrame}\n) -> Union{Nothing, SortedDict{TimeFrames.TimeFrame, DataFrames.DataFrame}}\npropagate_ohlcv!(\n    data::SortedDict{TimeFrames.TimeFrame, DataFrames.DataFrame},\n    update_func::Function\n) -> Union{Nothing, SortedDict{TimeFrames.TimeFrame, DataFrames.DataFrame}}\n\n\nThis function takes a dictionary data and an aggregation function update_func. It updates the OHLCV data from the base time frame to the higher time frames in data, using update_func to aggregate the OHLCV values from the base to the target time frame. The function modifies data in place and returns it. If the base time frame data frame in data is empty, the function clears all the higher time frames data frames. Otherwise, it asynchronously updates each higher time frame data frame and ensures that the timestamps are synchronized across all time frames.\n\n\n\n\n\n","category":"function"},{"location":"API/processing/#Data.propagate_ohlcv!-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Processing","title":"Data.propagate_ohlcv!","text":"Resamples OHLCV data between different time frames.\n\npropagate_ohlcv!(\n    src::DataFrames.DataFrame,\n    dst::DataFrames.DataFrame;\n    src_tf,\n    dst_tf,\n    strict\n) -> DataFrames.DataFrame\n\n\nThis function resamples the OHLCV data from a source DataFrame to a destination DataFrame with different timeframes. If the latest timestamp in the destination DataFrame is earlier than the earliest timestamp in the resampled source DataFrame, the function appends the resampled data to the destination DataFrame. If not, the function returns the destination DataFrame as is. Both the source and destination DataFrames must have columns named 'timestamp', 'open', 'high', 'low', 'close', and 'volume'. The source and destination timeframes must be suitable for the resampling operation.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing._deltas-Tuple{Any, Any}","page":"Processing","title":"Processing._deltas","text":"Computes the deltas for a given transformation.\n\n_deltas(\n    data,\n    to_tf\n) -> Tuple{Union{Float64, Integer}, Any, Any, Any}\n\n\nThis function takes a data vector and a target transformation function, and computes the deltas (changes) in the data that would result from applying the transformation.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing._fill_missing_candles!-Tuple{Any, AbstractString}","page":"Processing","title":"Processing._fill_missing_candles!","text":"_fill_missing_candles!(\n    df,\n    timeframe::AbstractString;\n    strategy\n) -> Any\n\n\nSee fill_missing_candles.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing._left_and_right-NTuple{4, Any}","page":"Processing","title":"Processing._left_and_right","text":"Returns the left and right indices for a given frame.\n\n_left_and_right(\n    data,\n    frame_size,\n    src_td,\n    td\n) -> Tuple{Int64, Any}\n\n\nThis function takes a data vector, frame size, source time delta, and target time delta, and computes the left and right indices for the frame based on these parameters.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing._remove_incomplete_candle-Tuple{Any, Any}","page":"Processing","title":"Processing._remove_incomplete_candle","text":"Removes incomplete candles from a DataFrame.\n\n_remove_incomplete_candle(in_df, tf) -> Any\n\n\nThis function takes a DataFrame in_df and a TimeFrame tf. It identifies any incomplete candles in in_df based on tf and removes them.\n\nSee isincomplete for more information.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.cleanup_ohlcv!-Tuple{Zarr.ZArray, AbstractString}","page":"Processing","title":"Processing.cleanup_ohlcv!","text":"Cleans up OHLCV data in a ZArray.\n\ncleanup_ohlcv!(\n    z::Zarr.ZArray,\n    timeframe::AbstractString\n) -> Union{Nothing, Zarr.ZArray}\n\n\nThis function takes a ZArray z and a string timeframe. It cleans up the OHLCV data in z by removing any incomplete candles based on timeframe and filling any missing candles using the specified filling strategy.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.cleanup_ohlcv_data-Tuple{Any, AbstractString}","page":"Processing","title":"Processing.cleanup_ohlcv_data","text":"cleanup_ohlcv_data(\n    data,\n    tf::AbstractString;\n    kwargs...\n) -> Any\n\n\nSee cleanup_ohlcv_data.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.cleanup_ohlcv_data-Tuple{Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.cleanup_ohlcv_data","text":"Cleans up OHLCV data in a DataFrame.\n\ncleanup_ohlcv_data(\n    data,\n    tf::TimeFrames.TimeFrame;\n    col,\n    fill_missing\n) -> Any\n\n\nThis function takes a DataFrame data, a TimeFrame tf, and optionally a column index col and a filling strategy fill_missing. It cleans up the OHLCV data in data by removing any incomplete candles based on tf, filling any missing candles using the specified filling strategy, and sorting the data by the specified column.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.fill_missing_candles!-Tuple{Any, Dates.Period}","page":"Processing","title":"Processing.fill_missing_candles!","text":"fill_missing_candles!(\n    df,\n    prd::Dates.Period;\n    strategy\n) -> Any\n\n\nSee fill_missing_candles.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.fill_missing_candles-Tuple{Any, AbstractString}","page":"Processing","title":"Processing.fill_missing_candles","text":"Fills missing candles in a DataFrame.\n\nfill_missing_candles(\n    df,\n    timeframe::AbstractString;\n    strategy\n) -> Any\n\n\nThis function takes a DataFrame df, a string timeframe, and optionally a filling strategy strategy. It identifies the missing candles in df based on the timeframe, and fills them using the specified strategy.\n\nfilling strategies:\n\n:close: fill with the close price of the previous candle.\n:open: fill with the open price of the next candle.\n:linear: linearly interpolate between the close price of the previous candle and the open price of the next candle.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.isadjacent-Tuple{Any, Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isadjacent","text":"a is adjacent to b if either isleftadj or isrightadj.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.iscomplete-Tuple{Any, Any}","page":"Processing","title":"Processing.iscomplete","text":"Checks if a candle is old enough to be complete.\n\niscomplete(v, tf) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.isincomplete-Tuple{Data.Candle, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isincomplete","text":"Checks if a candle is too new.\n\nisincomplete(\n    candle::Data.Candle,\n    tf::TimeFrames.TimeFrame\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.isincomplete-Tuple{Dates.DateTime, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isincomplete","text":"Checks if a DateTime is incomplete based on a TimeFrame.\n\nisincomplete(\n    d::Dates.DateTime,\n    tf::TimeFrames.TimeFrame\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.islast-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Processing","title":"Processing.islast","text":"Checks if the last row of a smaller DataFrame is also the last row of a larger DataFrame.\n\nislast(\n    larger::DataFrames.DataFrame,\n    smaller::DataFrames.DataFrame\n) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.islast-Tuple{Dates.DateTime, Any, Val{:raw}}","page":"Processing","title":"Processing.islast","text":"Checks if a candle is exactly the latest candle.\n\nislast(d::Dates.DateTime, tf, _::Val{:raw}) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.isleftadj-Tuple{Any, Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isleftadj","text":"a is left adjacent to b if in order ..ab..\n\nisleftadj(a, b, tf::TimeFrames.TimeFrame) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.isrightadj-Tuple{Any, Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.isrightadj","text":"a is right adjacent to b if in order ..ba..\n\nisrightadj(a, b, tf::TimeFrames.TimeFrame) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.maptf-Tuple{AbstractVector{T} where T<:String, Any, Function}","page":"Processing","title":"Processing.maptf","text":"Apply a function over data, resampling data to each timeframe in tfs.\n\nmaptf(\n    tfs::AbstractVector{T} where T<:String,\n    data,\n    f::Function;\n    tfsum,\n    kwargs...\n) -> Any\n\n\nf: signature is (data; kwargs...)::DataFrame\ntfsum: sum the scores across multiple timeframes for every pair.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.normalize!-Tuple{Any}","page":"Processing","title":"Processing.normalize!","text":"Applies either a unitrange transform or a zscore tranform over the data in place.\n\nnormalize!(arr; unit, dims) -> Any\n\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.normalize-Tuple{Any}","page":"Processing","title":"Processing.normalize","text":"See normalize!. Copies.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.resample","page":"Processing","title":"Processing.resample","text":"Resamples data based on transformation functions.\n\nresample(data, from_tf, to_tf) -> Any\nresample(data, from_tf, to_tf, cleanup) -> Any\nresample(data, from_tf, to_tf, cleanup, style) -> Any\nresample(data, from_tf, to_tf, cleanup, style, chop)\n\n\nThis function takes a data vector, a source transformation function from_tf, a target transformation function to_tf, and optionally a boolean cleanup and a style style. It resamples the data from the source time frame to the target time frame. If cleanup is true, it removes any invalid data points after resampling. The resampling style is determined by style. If chop is true, it removes the leftovers at the end of the data that can't fill a complete frame.\n\n\n\n\n\n","category":"function"},{"location":"API/processing/#Processing.resample-2","page":"Processing","title":"Processing.resample","text":"resample(\n    df::DataFrames.AbstractDataFrame,\n    tf::TimeFrames.TimeFrame;\n    ...\n) -> Any\nresample(\n    df::DataFrames.AbstractDataFrame,\n    tf::TimeFrames.TimeFrame,\n    b::Bool,\n    args...;\n    kwargs...\n) -> Any\n\n\n. See resample.\n\n\n\n\n\n","category":"function"},{"location":"API/processing/#Processing.resample-Tuple","page":"Processing","title":"Processing.resample","text":"Resamples data, and saves to storage.\n\nresample(args...; exc_name, name, dosave) -> Any\n\n\nwarning: Usually not worth it\nResampling is quite fast, so it is simpler to keep only the smaller timeframe on storage, and resample the longer ones on demand.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.resample-Tuple{AbstractDict{String, Data.PairData}, Any}","page":"Processing","title":"Processing.resample","text":"resample(\n    mkts::AbstractDict{String, Data.PairData},\n    timeframe;\n    progress\n) -> Dict{String, Data.PairData}\n\n\n. See resample.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.resample-Tuple{Data.PairData, Any}","page":"Processing","title":"Processing.resample","text":"resample(pair::Data.PairData, to_tf) -> Any\n\n\n. See resample.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.resample_style-Tuple{Any, Any}","page":"Processing","title":"Processing.resample_style","text":"Resamples a style based on a transformation function.\n\nresample_style(style, tf) -> Any\n\n\nThis function takes a style and a transformation function tf, and resamples the style based on the transformation.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.trail!-Tuple{Any, TimeFrames.TimeFrame}","page":"Processing","title":"Processing.trail!","text":"Applies trailing operation on a DataFrame based on a time frame.\n\ntrail!(df, tf::TimeFrames.TimeFrame; to, from, cap)\n\n\nThis function takes a DataFrame df, a TimeFrame tf, and optionally a timestamp to, a timestamp from, and a cap cap. It applies a trailing window operation on df for the specified tf. The operation starts from the timestamp specified by from (default is the last timestamp in the DataFrame) and ends at the timestamp specified by to. The cap argument determines the maximum number of rows to keep in the dataframe.\n\n\n\n\n\n","category":"method"},{"location":"API/processing/#Processing.@resample-Tuple{Any, Any, Any, Vararg{Any}}","page":"Processing","title":"Processing.@resample","text":". See resample.\n\n\n\n\n\n","category":"macro"}]
}
